{"posts":[{"title":"Background Fetch API","text":"后台获取 API 提供了一种管理可能需要大量时间的下载的方法，例如电影、音频文件和软件等。 其提供了一种让浏览器在后台执行某些获取的方法。然后，浏览器以用户可见的方式执行提取，向用户显示进度并为他们提供取消下载的方法。下载完成后，浏览器就会在 ServiceWorker 触发相关事件，此时应用程序可以根据需要对响应执行某些操作。 如果用户在离线状态下启动进程，后台获取 API 将启用。一旦网络连接，该过程就会开始。如果网络离线，该过程将暂停，直到用户再次上线。 后台获取 API 通过 BackgroundFetchManager 接口提供，并基于 ServiceWorkerRegistration 接口的 backgroundFetch 属性向开发者暴露。 发起 Background FetchBackgroundFetchManager 接口的 fetch() 方法用于注册一条后台获取。 方法接收一个字符串参数作为该后台获取的 ID； 然后接收一个 Request 或者一组 Request，可以是代表 URL 的字符串（会被传递给 Request 构造函数）或者 Request 实例； 最后接收一组可选的配置项，用于配置浏览器向用户展示的获取进度条对话框： 配置项的 title 参数指定对话框的标题； 配置项的 icons 参数指定对话框的一组图标，浏览器会从中选择一个图标用于对话框的展示：每个图标的 src 参数指定图标路径、sizes 参数指定图标的大小（格式同 link 标签的 sizes 属性的格式相同）、type 参数指定图标的 MIME 类型、label 参数指定图标的名称； 配置项的 downloadTotal 参数指定预计的获取资源总大小（字节），若实际获取资源总大小超出该数值，获取会终止； 方法返回一个 Promise 的 BackgroundFetchRegistration 实例。 1234567891011121314151617181920const ID = 'fetch'window.navigator.serviceWorker.ready.then((registration) =&gt; { registration.backgroundFetch.fetch( ID, [&quot;/ep-5.mp3&quot;, &quot;ep-5-artwork.jpg&quot;], { title: &quot;Episode 5: Interesting things.&quot;, icons: [ { sizes: &quot;300x300&quot;, src: &quot;/ep-5-icon.png&quot;, type: &quot;image/png&quot;, label: &quot;ep-icon&quot;, }, ], downloadTotal: 60 * 1024 * 1024, }, )}) Background Fetch 信息可以使用 BackgroundFetchManager 接口的 get() 方法根据给定的 ID 获取对应的 Background Fetch。 若存在，方法返回一个 Promise 的 BackgroundFetchRegistration 接口实例，否则返回一个 Promise 的 undefined。 此外，可以使用 BackgroundFetchManager 接口的 getIds() 方法获取当前所有 Background Fetch 的 ID 列表，返回一个 Promise 的字符串数组。 BackgroundFetchRegistration 接口用于表示后台获取的实时信息，以及一些控制方法。 BackgroundFetchRegistration 接口的 id 属性表示后台获取的 ID。 BackgroundFetchRegistration 接口的 downloaded 属性表示后台获取已下载资源的大小，初始值为 0。 BackgroundFetchRegistration 接口的 downloadTotal 属性表示后台获取将下载资源的总大小，该值在初始化时设置，若未设置则为 0。 BackgroundFetchRegistration 接口的 uploaded 属性表示后台获取已成功发送内容的大小，初始值为 0。 BackgroundFetchRegistration 接口的 uploadTotal 属性表示后台获取将发送内容的总大小。 BackgroundFetchRegistration 接口的 recordsAvailable 属性表示当前是否有可以获取的请求及响应，该值同样用于表示是否可以调用 match() 和 matchAll()。 BackgroundFetchRegistration 接口的 result 属性表示后台获取是否成功，可能的值为 '' success failure。 BackgroundFetchRegistration 接口的 failureReason 属性表示后台获取错误的原因，可能的值为 '' 'aborted' 'bad-status' 'fetch-error' 'quota-exceeded' 'download-total-exceeded'。 BackgroundFetchRegistration 接口的 match() 方法用于匹配当前后台获取中的后台请求。返回一个 Promise 的 BackgroundFetchRecord 接口实例或 undefined，表示首个匹配。 BackgroundFetchRegistration 接口的 matchAll() 方法用于匹配当前后台获取中的后台请求。返回一个 Promise 的 BackgroundFetchRecord 接口实例数组，表示所有的匹配。 两方法支持传入一个请求实例 Request 或 URL 或路径字符串，同时支持传入一个可选的配置项，ignoreSearch 参数指定是否忽略搜索参数，ignoreMethod 参数指定是否忽略请求方法，ignoreVary 参数指定是否忽略 Vary 响应头。 BackgroundFetchRecord 接口用于表示单个后台请求及响应信息。 BackgroundFetchRecord 接口的 request 属性表示请求信息，返回一个 Request。 BackgroundFetchRecord 接口的 responseReady 属性表示响应信息，返回一个 Promise 的 Response。 BackgroundFetchRegistration 接口的 progress 事件在当前后台获取的信息更新时触发，包括 downloaded 属性、uploaded 属性、 result 属性、failureReason 属性，事件只抛出一个普通的 Event 事件。 注销 Background FetchBackgroundFetchRegistration 接口的 abort() 方法用于终止当前后台获取。返回一个 Promise 的 boolean，表示是否终止成功。 1234567const ID = 'fetch'window.navigator.serviceWorker.ready.then((registration) =&gt; { registration.backgroundFetch.get(ID).then((registration) =&gt; { registration.abort() })}) Background Fetch 结束处理ServiceWorkerGlobalScope 接口的 backgroundfetchclick 事件在用户点击浏览器提供的下载进度条弹出框时触发。返回一个 BackgroundFetchEvent 事件。 ServiceWorkerGlobalScope 接口的 backgroundfetchabort 事件在后台获取被取消时触发。返回一个 BackgroundFetchEvent 事件。 ServiceWorkerGlobalScope 接口的 backgroundfetchfail 事件在后台获取失败时触发，即至少有一个后台获取内的网络请求失败。返回一个 BackgroundFetchUpdateUIEvent 事件。 ServiceWorkerGlobalScope 接口的 backgroundfetchsuccess 事件在后台获取完成时触发，此时所有后台获取内的网络请求已经完成。返回一个 BackgroundFetchUpdateUIEvent 事件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263self.addEventListener('backgroundfetchsuccess', (e) =&gt; { e.waitUntil(() =&gt; self.caches.open('movies').then((cache) =&gt; e.registration.matchAll().then((records) =&gt; Promise.all( records.map((record) =&gt; record.responseReady.then((response) =&gt; cache.put(record.request, response) ) ) ) ) ).then(() =&gt; e.updateUI({ title: 'Move download complete', }) ) )})self.addEventListener('backgroundfetchfail', (e) =&gt; { e.waitUntil(() =&gt; self.caches.open('movies').then((cache) =&gt; e.registration.recordsAvailable &amp;&amp; e.registration.matchAll().then((records) =&gt; Promise.all( records.map((record) =&gt; record.responseReady.then((response) =&gt; cache.put(record.request, response) ) ) ) ) ).then(() =&gt; e.updateUI({ title: 'Download Fail', }) ) )})self.addEventListener('backgroundfetchabort', (e) =&gt; { e.waitUntil(() =&gt; self.caches.open('movies').then((cache) =&gt; e.registration.recordsAvailable &amp;&amp; e.registration.matchAll().then((records) =&gt; Promise.all( records.map((record) =&gt; record.responseReady.then((response) =&gt; cache.put(record.request, response) ) ) ) ) ) )})self.addEventListener('backgroundfetchclick', (e) =&gt; { if (e.registration.result === 'success') { self.clients.openWindow('/play-movie'); } else { self.clients.openWindow('/movie-download-progress'); }}) BackgroundFetchEvent 接口继承自 ExtendableEvent 接口，其 registration 属性代表与之对应的 BackgroundFetchRegistration 实例。 BackgroundFetchUpdateUIEvent 接口继承自 BackgroundFetchEvent 接口，其 updateUI() 方法用于更新浏览器提供的下载进度条弹出框的信息。接收一组参数，包括 icons 及 title 参数，与 BackgroundFetchManager 接口的 fetch() 方法中的相应参数相同。返回一个 Promise。 权限 API该 API 调用需要用户授予 background-fetch 权限，可以调用 Permission.query() 方法检查用户是否已授予了该权限 示例 https://github.com/skyclouds2001/Frontend-Learning/blob/main/next-learning/background-fetch.html https://github.com/skyclouds2001/Frontend-Learning/blob/main/next-learning/background-fetch.js 类型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263type BackgroundFetchFailureReason = &quot;&quot; | &quot;aborted&quot; | &quot;bad-status&quot; | &quot;fetch-error&quot; | &quot;quota-exceeded&quot; | &quot;download-total-exceeded&quot;;type BackgroundFetchResult = &quot;&quot; | &quot;success&quot; | &quot;failure&quot;;interface BackgroundFetchEvent extends ExtendableEvent { readonly registration: BackgroundFetchRegistration;}interface BackgroundFetchUpdateUIEvent extends BackgroundFetchEvent { updateUI(options?: BackgroundFetchUIOptions);}interface BackgroundFetchManager { fetch(id: string, requests: RequestInfo | RequestInfo[], options?: BackgroundFetchOptions): Promise&lt;BackgroundFetchRegistration&gt;; get(id: string): Promise&lt;BackgroundFetchRegistration | undefined&gt;; getIds(): Promise&lt;ReadonlyArray&lt;string&gt;&gt;;}interface BackgroundFetchOptions extends BackgroundFetchUIOptions { downloadTotal: number;}interface BackgroundFetchRecord { readonly request: Request; readonly responseReady: Promise&lt;Response&gt;;}interface BackgroundFetchRegistration extends EventTarget { abort(): Promise&lt;boolean&gt;; readonly downloaded: number; readonly downloadTotal: number; readonly failureReason: BackgroundFetchFailureReason; readonly id: string; match(request: RequestInfo, options?: CacheQueryOptions): Promise&lt;BackgroundFetchRecord | undefined&gt;; matchAll(request?: RequestInfo, options?: CacheQueryOptions): Promise&lt;BackgroundFetchRecord[]&gt;; readonly recordsAvailable: boolean; readonly result: BackgroundFetchResult; readonly uploaded: number; readonly uploadTotal: number; onprogress: ((this: BackgroundFetchRegistration, ev: Event) =&gt; any) | null;}interface BackgroundFetchUIOptions { icons: ReadonlyArray&lt;ImageResource&gt;; title: string;}interface ImageResource { src: string; sizes: string; type: string; label: string;}interface ServiceWorkerRegistration extends EventTarget { readonly backgroundFetch: BackgroundFetchManager;}interface ServiceWorkerGlobalScope extends WorkerGlobalScope { onbackgroundfetchabort: ((this: ServiceWorkerGlobalScope, ev: BackgroundFetchUpdateUIEvent) =&gt; any) | null; onbackgroundfetchclic: ((this: ServiceWorkerGlobalScope, ev: BackgroundFetchUpdateUIEvent) =&gt; any) | null; onbackgroundfetchfail: ((this: ServiceWorkerGlobalScope, ev: BackgroundFetchUpdateUIEvent) =&gt; any) | null; onbackgroundfetchsuccess: ((this: ServiceWorkerGlobalScope, ev: BackgroundFetchUpdateUIEvent) =&gt; any) | null;} 链接 https://developer.mozilla.org/en-US/docs/Web/API/Background_Fetch_API https://wicg.github.io/background-fetch/","link":"/2023/09/13/Background-Fetch-API/"},{"title":"Badging API","text":"Badging API 用于设置 PWA 应用的图标上的徽章信息 该 API 需要在 Secure Context 下使用 某些情况下该 API 需要请求用户授予 notifications 权限，并可以调用 Notification.requestPermission() 方法来请求获取相关权限 设置 Badge使用 Navigator 接口上的 setAppBadge() 方法给图标设置徽章 方法支持传递一个可选的数字参数，徽章将显示为对应的数字；若未传递，徽章将显示为对应的点 方法返回一个 Promise 的 undefined 方法不支持时会抛出 NotSupportedError 异常 12navigator.setAppBadge()navigator.setAppBadge(10) 清除 Badge使用 Navigator 接口的 clearAppBadge() 方法清除图标上设置的徽章 方法返回一个 Promise 的 undefined 方法不支持时会抛出 NotSupportedError 异常 12navigator.setAppBadge(0)navigator.clearAppBadge() 使用 Navigator 接口的 setAppBadge() 方法并传递参数 0 同样具有类似的效果 权限 API该 API 调用需要用户授予 notifications 权限，可以调用 Permission.query() 方法或读取 Notification.permission 属性检查用户是否已授予了该权限 示例 https://github.com/skyclouds2001/Frontend-Learning/blob/main/next-learning/PWA-eg 类型123456789interface Navigator { clearAppBadge(): Promise&lt;void&gt; setAppBadge(contents?: number): Promise&lt;void&gt;}interface WorkerNavigator { clearAppBadge(): Promise&lt;void&gt; setAppBadge(contents?: number): Promise&lt;void&gt;} 链接 https://developer.mozilla.org/en-US/docs/Web/API/Badging_API https://w3c.github.io/badging/","link":"/2023/10/02/Badging-API/"},{"title":"Battery Status API","text":"Battery Status API 提供了访问设备电源信息和监听电源信息变化的功能，可以用于动态根据用户设备的电源情况调整一些功能的策略 获取电源管理实例使用 Navigator 接口的 getBattery() 方法获取到电源管理实例，方法返回一个 Promise 的 BatteryManager 实例 1const batteryManager = await navigator.getBattery() 获取设备电源信息BatteryManager 接口提供了访问设备电源信息的属性 BatteryManager 接口的 charging 属性返回一个 boolean，表示当前设备是否处于充电状态 BatteryManager 接口的 chargingTime 属性返回一个 number，表示当前设备充电完成所需的充电时间，若设备已充满或无法获取电源信息则返回 0，若设备未处于充电状态则返回 +Infinity BatteryManager 接口的 dischargingTime 属性返回一个 number，表示当前设备至完全耗尽电量的时间，若设备处于充电状态或无法获取电源信息则返回 +Infinity BatteryManager 接口的 level 属性返回一个范围从 0.0 到 1.0 之间的 number，表示当前设备电源的电量百分比，若无法获取电源信息则返回 1.0 1234batteryManager.chargingbatteryManager.chargingTimebatteryManager.dischargingTimebatteryManager.level 监听设备电源信息更新BatteryManager 接口提供了监听设备电源信息变化的事件 BatteryManager 接口的 chargingchange 事件在电源充电状态改变时触发，即 charging 属性改变时触发 BatteryManager 接口的 chargingtimechange 事件在电源充电完成时间改变时触发，即 chargingTime 属性改变时触发 BatteryManager 接口的 dischargingtimechange 事件在电源电量耗尽时间改变时触发，即 dischargingTime 属性改变时触发 BatteryManager 接口的 levelchange 事件在电源电量改变时触发，即 level 属性改变时触发 123456789101112batteryManager.addEventListener('chargingchange', () =&gt; { console.log(batteryManager.charging)})batteryManager.addEventListener('chargingtimechange', () =&gt; { console.log(batteryManager.chargingTime)})batteryManager.addEventListener('dischargingtimechange', () =&gt; { console.log(batteryManager.dischargingTime)})batteryManager.addEventListener('levelchange', () =&gt; { console.log(batteryManager.level)}) 权限策略该 API 受 battery 权限策略的限制（无论是通过 Permissions-Policy 响应头指定抑或是通过 iframe 元素的 allow 属性指定） 默认为 self，即允许在当前上下文或内嵌的其他同源上下文中使用 类型1234567891011121314interface Navigator { getBattery: () =&gt; Promise&lt;BatteryManager&gt;}interface BatteryManager extends EventTarget { readonly charging: boolean readonly chargingTime: number readonly dischargingTime: number readonly level: number onchargingchange: ((this: BatteryManager, ev: Event) =&gt; any) | null onchargingtimechange: ((this: BatteryManager, ev: Event) =&gt; any) | null ondischargingtimechange: ((this: BatteryManager, ev: Event) =&gt; any) | null onlevelchange: ((this: BatteryManager, ev: Event) =&gt; any) | null} 链接 https://developer.mozilla.org/en-US/docs/Web/API/Battery_Status_API https://w3c.github.io/battery/","link":"/2023/10/21/Battery-Status-API/"},{"title":"Beacon API","text":"Beacon API 可用于向服务器发送 HTTP POST 网络请求 通常目的旨在向服务器发送用户数据，特别是在页面关闭时机（能够避免阻碍下一网页的加载） 使用使用 Navigator 接口的 sendBeacon() 方法发送数据 方法需要传递一个 string 或 URL，代表请求的目标 URL 方法可以可选地携带一个 ReadableStream Blob ArrayBuffer TypedArray DataView FormData URLSearchParams string，代表请求需要携带的数据 方法返回一个 boolean，表示是否成功完成数据转换 避免使用 beforeunload unload 事件，而是 visibilitychange 事件（或在不兼容时使用 pagehide 事件），因为在移动端网页时卸载事件不能确定地触发 类型123interface Navigator { sendBeacon(url: string, data?: BodyInit): boolean} 链接 https://w3c.github.io/beacon/","link":"/2023/11/04/Beacon-API/"},{"title":"Contact Picker API","text":"Contact Picker API 允许用户从通讯录选择记录并与网页应用分享 该 API 通过 ContactsManager 接口使用，并通过 Navigator.contacts 向用户暴露 检测支持的参数调用 ContactsManager 接口的 getProperties() 方法以获取当前设备支持的参数列表 方法返回 Promise 的字符串列表，值具体在 &quot;address&quot; &quot;email&quot; &quot;icon&quot; &quot;name&quot; &quot;tel&quot; 之中，代表设备通讯录支持的参数类型 1const properties = await navigator.contacts.getProperties() 获取通讯录记录调用 ContactsManager 接口的 select() 方法以获取通讯录记录 方法接收一个字符串数组，值需要在 &quot;address&quot; &quot;email&quot; &quot;icon&quot; &quot;name&quot; &quot;tel&quot; 之中，代表需要获取的通讯录记录的参数 方法可以接收一个可选的配置项参数，其 multiple 选项指定是否支持选择多条记录，默认 false 方法返回一个对象数组，代表获取到的通讯录记录；数组各项均包含 &quot;address&quot; &quot;email&quot; &quot;icon&quot; &quot;name&quot; &quot;tel&quot; 字段 若方法未在顶层浏览上下文调用，或当前已有其他该方法的调用，或启动通讯录选择器失败，则抛出 InvalidStateError 异常 若方法非因为用户交互调用，则抛出 SecurityError 异常 若方法传入一个空数组，或传入的数组任一项当前设备不支持，则抛出 TypeError 异常 1const contacts = await navigator.contacts.select(properties) 通讯录记录细节 &quot;address&quot; 返回 ContactAddress 数组，代表各记录的地址 &quot;email&quot; 返回 string 数组，代表各记录的邮箱 &quot;icon&quot; 返回 Blob 数组，代表各记录的图标 &quot;name&quot; 返回 string 数组，代表各记录的名称 &quot;tel&quot; 返回 string 数组，代表各记录的电话 类型123456789101112131415161718192021222324252627282930313233343536interface Navigator { readonly contacts: ContactsManager}type ContactProperty = &quot;address&quot; | &quot;email&quot; | &quot;icon&quot; | &quot;name&quot; | &quot;tel&quot;interface ContactAddress { toJSON(): Object readonly city: string readonly country: string readonly dependentLocality: string readonly organization: string readonly phone: string readonly postalCode: string readonly recipient: string readonly region: string readonly sortingCode: string readonly addressLine: string[]}interface ContactInfo { address: ContactAddress[] email: string[] icon: Blob[] name: string[] tel: string[]}interface ContactsSelectOptions { multiple?: boolean}interface ContactsManager { getProperties(): Promise&lt;ContactProperty[]&gt; select(properties: ContactProperty[], options?: ContactsSelectOptions): Promise&lt;ContactInfo[]&gt;} 链接 https://developer.mozilla.org/en-US/docs/Web/API/Contact_Picker_API https://w3c.github.io/contact-picker/","link":"/2023/11/12/Contact-Picker-API/"},{"title":"Clipboard API","text":"Clipboard API 允许异步地读写剪切板 剪切板操作通过 Navigator 接口的 clipboard 属性暴露的 Clipboard 接口实例使用 剪切板的部分操作需要获得 clipboard-write 权限和 clipboard-read 权限 读写文本使用 Clipboard 接口的 writeText() 方法向剪切板中写入文本 方法接收一个字符串参数，代表向剪切板写入的文本内容 1navigator.clipboard.writeText('data') 若存在用户交互，方法调用会自动授予 clipboard-write 权限 使用 Clipboard 接口的 readText() 方法从剪切板中读取文本 方法返回一个字符串，代表从剪切板读取的文本内容 1const data = await navigator.clipboard.readText() 方法调用需要用户授予 clipboard-read 权限 读写复杂格式使用 Clipboard 接口的 write() 方法向剪切板中写入复杂格式内容 方法接收一个 ClipboardItem 数组，代表要向剪切板写入的数据 调用 ClipboardItem() 构造函数创建 ClipboardItem 实例 需传入一个数据对象，该对象要求键为数据的 MIME 类型，值为实际数据（允许为 Promise） 12345navigator.clipboard.write([ new ClipboardItem({ 'text/plain': new Blob(['data'], { type: 'text/plain' }), }),]) 方法调用需要用户授予 clipboard-write 权限 使用 Clipboard 接口的 read() 方法从剪切板中读取复杂格式内容 方法返回一个 ClipboardItem 数组，代表要从剪切板读取的数据 ClipboardItem 实例的 types 属性反映其支持的 MIME 类型 ClipboardItem 实例的 getType() 方法根据指定的 MIME 类型返回对应的 Blob 123const datas = await navigator.clipboard.read()const blob = await datas.at(0).getType('text/plain') 方法调用需要用户授予 clipboard-read 权限 权限 API该 API 调用需要用户授予 clipboard-read 或 clipboard-write 权限，可以调用 Permission.query() 方法检查用户是否已授予了该权限 类型1234567891011121314151617181920interface Clipboard extends EventTarget { read(): Promise&lt;ClipboardItems&gt; readText(): Promise&lt;string&gt; write(data: ClipboardItems): Promise&lt;void&gt; writeText(data: string): Promise&lt;void&gt;}declare var Clipboard: { prototype: Clipboard}interface ClipboardItem { readonly types: ReadonlyArray&lt;string&gt; getType(type: string): Promise&lt;Blob&gt;}declare var ClipboardItem: { prototype: ClipboardItem new(items: Record&lt;string, string | Blob | PromiseLike&lt;string | Blob&gt;&gt;): ClipboardItem} 链接 https://developer.mozilla.org/en-US/docs/Web/API/Clipboard_API https://w3c.github.io/clipboard-apis/","link":"/2023/11/02/Clipboard-API/"},{"title":"Cookie API","text":"Cookie 是一小段保存在用户端的信息，用于改善用户的网络浏览体验，通常包括用户的选项或识别信息，用户可以选择网站使用 Cookie 的方式 可用使用 navigator.cookieEnabled 判断页面是否允许使用 Cookie Cookie 的设置可以通过 Set-Cookie 响应头设置 Cookie 或使用 JS 脚本 document.cookie 设置 Cookie 12HTTP/2.0 200 OKSet-Cookie: cookie_a=a 1document.cookie = 'cookie_b=b'; Cookie 的读取执行请求时可以通过 Cookie 请求头自动带上 Cookie JS 脚本中可以通过 document.cookie 读取 Cookie 1const cookies = document.cookie; Cookie 的选项 Expires 属性 指定 Cookie 在给定时间后失效 Max-Age 属性 指定 Cookie 在超出给定时长后失效 Secure 属性 指定 Cookie 仅在 Secure Context 下才发送；并且非 Secure Context 下无法设置该属性 HttpOnly 属性 指定 Cookie 无法通过 document.cookie 读取和修改 常用于防御 XSS 攻击 Domain 属性 指定 Cookie 可用的域名（及子域名），默认会包含当前的域名 Path 属性 指定 Cookie 可用的路径（及子路径） SameSite 属性 指定 Cookie 是否在跨域请求中发送 常用于防御 CSRF 攻击 Strict 值指定仅在同域请求中发送 Lax 值允许在用户导航至 Cookie 的域名时发送，该值是默认的行为 None 值指定允许在跨域请求中发送，但需同时指定 Secure 属性 1Set-Cookie: cookie_b=b; Expires=Thu, 31 Oct 2021 07:28:00 GMT; Secure; HttpOnly; Domain=example.com; Path=/; SameSite=Strict __Host- 前缀 指定对应的 Cookie 需指定 Secure 属性（即需要在 Secure Context 发送），不得指定 Domain 属性，Path 属性需指定为 / __Secure- 前缀 指定对应的 Cookie 需指定 Secure 属性（即需要在 Secure Context 发送） 链接 https://html.spec.whatwg.org/multipage/dom.html#dom-document-cookie https://httpwg.org/specs/rfc6265.html#cookie https://httpwg.org/specs/rfc6265.html#sane-set-cookie","link":"/2023/10/20/Cookie-API/"},{"title":"Content Index API","text":"Content Index API 允许网站注册离线启用的内容，向用户告知网站支持的离线内容并允许开发者对其进行管理 该 API 仅支持 HTML 文档对应的 URL，不支持如媒体资源等类型的 URL 该 API 仅支持列举已注册的内容，不支持进行查找等操作 一般的使用方式是利用一个列表页，用于展示已注册的内容 需要注意的是，该 API 并非直接缓存内容，实际的缓存需要利用 Cache Storage 等策略实施 介于该 API 依赖于 ServiceWorker，因此该 API 同样需在 Secure Context 下使用，且需遵循同源策略 通过 ServiceWorkerRegistration.index 暴露 ContentIndex 接口实例使用 添加离线内容通过 ContentIndex 接口的 add() 方法添加离线内容 方法支持传入一组配置项 参数 id 指定离线内容的唯一标识符 参数 url 指定离线内容的 URL，需要与当前网页或脚本同源 参数 title 指定离线内容的标题 参数 description 指定离线内容的描述 可选参数 icons 指定离线内容的图标组，每组图标对象支持指定 src 参数和 可选的 sizes 及 type 参数，默认值是一个空数组 可选参数 category 指定离线内容的类别，可选的值为 ''、'homepage'、'article'、'video'、'audio'，默认值是 '' 方法返回一个 Promise 的 undefined 方法在以下情况下会抛出一个 TypeError 异常 当前 ContentIndex 对应的 ServiceWorker 未激活或 ServiceWorker 未包含 FetchEvent id、 title、 description、 url 参数未指定或参数类型不为字符串或参数为空串 icons 参数某个 icon 的 URL 的类型不是图像或获取对应 icon 出现网络异常 1234567891011121314self.registration.index.add({ id: 'post', url: '/posts/post.html', title: 'Post', description: 'Post Information', icons: [ { src: '/media/dark.png', sizes: '128x128', type: 'image/png', }, ], category: 'article',}) 获取离线内容通过 ContentIndex 接口的 getAll() 方法获取离线内容 方法返回一个 Promise 的代表离线内容的数组，结构同 ContentIndex.add() 方法的配置项参数 1self.registration.index.getAll() 删除离线内容通过 ContentIndex 接口的 delete() 方法删除离线内容 方法传入一个代表待删除的离线内容的 id 的字符串 方法返回一个 Promise 的 undefined 12345self.registration.index.delete(id).then(() =&gt; ( self.caches.open('v1').then((cache) =&gt; ( cache.delete(e.id) )))) 需要注意的是，调用该方法同时，需要手动从存储中移除对应的离线内容 此外，当离线内容被通过用户代理移除而非手动调用 ContentIndex.delete() 方法移除时，会在 ServiceWorker 全局触发 contentdelete 事件，并返回一个 ContentIndexEvent 事件 ContentIndexEvent 事件继承自 ExtendableEvent 事件，其属性 id 反映了被删除的离线内容的 id 1234567self.addEventListener('contentdelete', (e) =&gt; { e.waitUntil( self.caches.open('v1').then((cache) =&gt; ( cache.delete(e.id) )) )}) 通常利用该事件同步移除与待移除页面的相关的资源存储 示例 https://github.com/skyclouds2001/Frontend-Learning/blob/main/next-learning/PWA-eg 类型12345678910111213141516type ContentCategory = '' | 'homepage' | 'article' | 'video' | 'audio'interface ContentDescription { id: string title: string description: string category?: ContentCategory icons?: ImageResource[]; url: string}interface ContentIndex { add(description: ContentDescription): Promise&lt;undefined&gt; delete(id: string): Promise&lt;undefined&gt; getAll(): Promise&lt;ContentDescription[]&gt;}; 链接 https://developer.mozilla.org/en-US/docs/Web/API/Content_Index_API https://wicg.github.io/content-index/spec/","link":"/2023/10/01/Content-Index-API/"},{"title":"Cookie Store API","text":"Cookie Store API 提供了异步地管理 Cookie 的方式，同时允许在 ServiceWorker 中使用 在该 API 之前，使用 cookie 的方式是通过读写 document.cookie 属性，但其是单线程同步的，可能会阻碍事件循环；并且其无法在 ServiceWorker 中使用 Cookie 的读写Window 环境中通过 Window 接口的 cookieStore 属性使用 Window 环境中通过 ServiceWorkerGlobalScope 接口的 cookieStore 属性使用 12window.cookieStoreself.cookieStore 读取单条 CookieCookieStore 接口的 get() 方法用于获取单条 Cookie 方法接收一个字符串，代表 Cookie 的名称；或接收一个对象，其 name 参数与 url 参数均需指定 方法返回一个 Promise 的 CookieListItem 结构，代表匹配到的 Cookie 信息；反之返回 undefined 12345const cookie = await window.cookieStore.get('cookie')const cookie = await window.cookieStore.get({ name: 'cookie', url: 'https://www.example.com',}) 读取多条 CookieCookieStore 接口的 getAll() 方法用于获取单条 Cookie 方法接收一个字符串，代表 Cookie 的名称；或接收一个对象，其 name 参数与 url 参数均需指定 方法返回一个 Promise 的 CookieList 结构，代表匹配到的所有 Cookie 12345const cookies = await window.cookieStore.getAll('key')const cookies = await window.cookieStore.getAll({ name: 'key', url: 'https://www.example.com',}) 设置 CookieCookieStore 接口的 set() 方法用于设置 Cookie 方法可以接收两个字符串，分别代表 Cookie 的名称与值；亦可以接收一个配置项，各项如下所示： name 属性必需 value 属性必需 expires 属性可选，默认 null domain 属性可选，默认 null path 属性可选，默认 &quot;/&quot; sameSite 属性可选，默认 &quot;strict&quot; partitioned 属性可选，默认 false 方法返回一个 Promise 12345678910await window.cookieStore.set('key', 'value')await window.cookieStore.set({ name: 'key', value: 'value', expires: null, domain: null, path: '/', sameSite: 'strict', partitioned: false,}) 移除 CookieCookieStore 接口的 delete() 方法用于移除 Cookie 方法接收一个字符串，代表 Cookie 的名称；或接收一个对象，其 name 参数必需指定；path 参数 domain 参数 partitioned 参数可选 方法返回一个 Promise 1234567await window.cookieStore.delete('key')await window.cookieStore.delete({ name: 'key', path: '/', domain: null, partitioned: false,}) Cookie 详细信息CookieList 结构相当于 CookieListItem 结构的数组 CookieListItem 结构反映了 Cookie 的详细信息 CookieListItem 结构的 name 属性返回一个字符串，代表 Cookie 的名称 CookieListItem 结构的 value 属性返回一个字符串，代表 Cookie 的值 CookieListItem 结构的 domain 属性返回一个字符串，代表 Cookie 的域，该属性可能返回 null CookieListItem 结构的 path 属性返回一个字符串，代表 Cookie 的路径 CookieListItem 结构的 expires 属性返回一个数字，代表 Cookie 的过期时间，该属性可能返回 null CookieListItem 结构的 secure 属性返回一个布尔值，代表 Cookie 的严格上下文策略 CookieListItem 结构的 sameSite 属性返回一个字符串，代表 Cookie 的同域策略，为 &quot;strict&quot; &quot;lax&quot; &quot;none&quot; 之一 CookieListItem 结构的 partitioned 属性返回一个布尔值，代表 Cookie 的分区策略 监听 Cookie 变化CookieStore 接口的 change 事件在任一 Cookie 变化时触发，返回一个 CookieChangeEvent 事件 CookieChangeEvent 接口的 changed 属性返回一个 CookieListItem 结构只读数组，表示被修改的 Cookie CookieChangeEvent 接口的 deleted 属性返回一个 CookieListItem 结构只读数组，表示被移除的 Cookie 1234window.cookieStore.addEventListener('change', (e) =&gt; { e.changed e.deleted}) 但该事件仅在 Window 环境中可用 订阅 Cookie 变化ServiceWorker 中允许通过 CookieStoreManager 接口的方法动态控制 Cookie 变化的订阅 可通过 ServiceWorkerRegistration 接口的 cookies 属性获取到 CookieStoreManager 实例 1self.registration.cookies 获取订阅CookieStoreManager 接口的 getSubscriptions() 方法用于获取当前所有的订阅 方法返回一个对象数组，数组各项包含 name 参数和 url 参数 1const subscriptions = await self.registration.cookies.getSubscriptions() 添加订阅CookieStoreManager 接口的 subscribe() 方法用于添加订阅 方法传入一个对象数组参数，各项的 name 参数与 url 参数均需指定 方法返回一个 Promise 123456self.registration.cookies.subscribe([ { name: 'key', url: '/', },]) 移除订阅CookieStoreManager 接口的 unsubscribe() 方法用于移除订阅 方法传入一个对象数组参数，各项的 name 参数与 url 参数均需指定 方法返回一个 Promise 123456self.registration.cookies.unsubscribe([ { name: 'key', url: '/', },]) 监听 Cookie 变化ServiceWorkerGlobalScope 接口的 cookiechange 事件在订阅的 Cookie 发生变化时触发，返回一个 ExtendableCookieChangeEvent 事件 ExtendableCookieChangeEvent 接口的 changed 属性返回一个 CookieListItem 结构只读数组，表示被修改的 Cookie ExtendableCookieChangeEvent 接口的 deleted 属性返回一个 CookieListItem 结构只读数组，表示被移除的 Cookie 1234self.addEventListener('cookiechange', (e) =&gt; { e.changed e.deleted}) 示例 Name Value Operation name value submit #cookie-store { gap: 25px; backdrop-filter: invert(100%); } const generateRecordHTML = (cookie) => { const record = document.createElement('tr'); const name = document.createElement('td'); name.innerText = cookie.name; record.appendChild(name); const value = document.createElement('td'); value.innerText = cookie.value; record.appendChild(value); const operation = document.createElement('td'); operation.innerText = 'Delete'; operation.addEventListener('click', () => { if (window.confirm('delete cookie')) { window.cookieStore.delete(cookie); list.removeChild(record); } }); record.appendChild(operation); return record; }; const list = document.querySelector('#cookie-store table tbody'); const cookies = await window.cookieStore.getAll(); const fragment = document.createDocumentFragment(); for (const cookie of cookies) { fragment.appendChild(generateRecordHTML(cookie)); } list.appendChild(fragment); const name = document.querySelector('#cookie-store #name'); const value = document.querySelector('#cookie-store #value'); const submit = document.querySelector('#cookie-store #submit'); submit.addEventListener('click', () => { const cookie = { name: name.value, value: value.value, }; window.cookieStore.set(cookie); list.appendChild(generateRecordHTML(cookie)); }); 类型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798interface CookieStore extends EventTarget { get(name: string): Promise&lt;CookieListItem | undefined&gt; get(options?: CookieStoreGetOptions): Promise&lt;CookieListItem | undefined&gt; getAll(name: string): Promise&lt;CookieList&gt; getAll(options?: CookieStoreGetOptions): Promise&lt;CookieList&gt; set(name: string, value: string): Promise&lt;undefined&gt; set(options: CookieInit): Promise&lt;undefined&gt; delete(name: string): Promise&lt;undefined&gt; delete(options: CookieStoreDeleteOptions): Promise&lt;undefined&gt; onchange: ((this: CookieStore, ev: CookieChangeEvent) =&gt; any) | null}interface CookieStoreGetOptions { name: string url: string}enum CookieSameSite { &quot;strict&quot;, &quot;lax&quot;, &quot;none&quot;}interface CookieInit { name: string value: string expires?: DOMHighResTimeStamp | null domain?: string | null path?: string sameSite?: CookieSameSite partitioned?: boolean}interface CookieStoreDeleteOptions { name: string domain?: string | null path?: string partitione?: boolean}interface CookieListItem { name: string value: string domain?: string path: string expires?: DOMHighResTimeStamp secure: boolean sameSite: CookieSameSite partitioned: boolean}type CookieList = Array&lt;CookieListItem&gt;interface CookieStoreManager { subscribe(subscriptions: Array&lt;CookieStoreGetOptions&gt;): Promise&lt;undefined&gt; getSubscriptions(): Promise&lt;Array&lt;CookieStoreGetOptions&gt;&gt; unsubscribe(subscriptions: Array&lt;CookieStoreGetOptions&gt;): Promise&lt;undefined&gt;}interface ServiceWorkerRegistration { readonly cookies: CookieStoreManager}interface CookieChangeEvent extends Event { constructor(type: string, eventInitDict?: CookieChangeEventInit) readonly changed: ReadonlyArray&lt;CookieListItem&gt; readonly deleted: ReadonlyArray&lt;CookieListItem&gt;}interface CookieChangeEventInit extends EventInit { changed: CookieList deleted: CookieList}interface ExtendableCookieChangeEvent extends ExtendableEvent { constructor(type: string, eventInitDict?: ExtendableCookieChangeEventInit) readonly changed: ReadonlyArray&lt;CookieListItem&gt; readonly deleted: ReadonlyArray&lt;CookieListItem&gt;}interface ExtendableCookieChangeEventInit extends ExtendableEventInit { changed: CookieList deleted: CookieList}interface Window { readonly cookieStore: CookieStore}interface ServiceWorkerGlobalScope { readonly cookieStore: CookieStore oncookiechange: ((this: ServiceWorkerGlobalScope, ev: ExtendableCookieChangeEvent) =&gt; any) | null} 链接 https://developer.mozilla.org/en-US/docs/Web/API/Cookie_Store_API https://wicg.github.io/cookie-store/","link":"/2023/11/09/Cookie-Store-API/"},{"title":"Broadcast Channel API","text":"Broadcast Channel API 允许在同源的浏览上下文中交换数据 创建广播频道通过直接调用 BroadcastChannel() 构造函数来创建一个广播频道 需要传递一个字符串参数，代表广播频道的名称 若该名称的广播频道已经创建，则会复用并加入已有的广播频道 1const bc = new BroadcastChannel('bc') 传递的广播频道名称可以经由 BroadcastChannel 实例的 name 只读属性读取 发送消息通过调用 BroadcastChannel 实例的 postMessage() 方法来向广播频道发送消息 1bc.postMessage('message') 发送的消息会经由结构化克隆算法处理，因此任意可由结构化克隆算法处理的类型的数据均可发送 订阅消息通过监听 BroadcastChannel 实例的 message 事件监听成功接收的消息 123bc.addEventListener('message', (e) =&gt; { console.log(e.data)}) 通过监听 BroadcastChannel 实例的 messageerror 事件监听接收失败的消息 123bc.addEventListener('messageerror', (e) =&gt; { console.log(e.data)}) 关闭广播频道通过调用 BroadcastChannel 实例的 close() 方法来断开与广播频道的连接 1bc.close() 广播频道在没有任一浏览上下文连接至其时被回收 示例 收到的信息为： 发送 const name = 'broadcast-channel'; const span = document.querySelector('#broadcast-channel span'); const input = document.querySelector('#broadcast-channel input'); const button = document.querySelector('#broadcast-channel button'); const broadcast = new BroadcastChannel(name); broadcast.addEventListener('message', (e) => { span.innerText = '接收到信息为：' + e.data; }); button.addEventListener('click', () => { broadcast.postMessage(input.value); }); 类型123456789101112interface BroadcastChannel extends EventTarget { readonly name: string onmessage: ((this: BroadcastChannel, ev: MessageEvent) =&gt; any) | null onmessageerror: ((this: BroadcastChannel, ev: MessageEvent) =&gt; any) | null close(): void postMessage(message: any): void}declare var BroadcastChannel: { prototype: BroadcastChannel new(name: string): BroadcastChannel} 链接 https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API https://html.spec.whatwg.org/multipage/web-messaging.html#broadcasting-to-other-browsing-contexts","link":"/2023/11/02/Broadcast-Channel-API/"},{"title":"DeviceOrientation Event","text":"DeviceOrientation Event 允许监测设备的物理朝向及物理加速度 物理加速度Window 接口的 devicemotion 事件在设备的物理加速度（及旋转速率）变化时定期触发，返回一个 DeviceMotionEvent 事件 123window.addEventListener('devicemotion', (e) =&gt; { //}) DeviceMotionEvent 接口的 acceleration 属性返回一个 DeviceMotionEventAcceleration 实例，表示设备的加速度（包含 x y z 三个参数） DeviceMotionEvent 接口的 accelerationIncludingGravity 属性返回一个 DeviceMotionEventAcceleration 实例，表示受重力影响下设备的加速度（包含 x y z 三个参数） DeviceMotionEvent 接口的 rotationRate 属性返回一个 DeviceMotionEventRotationRate 实例，表示设备的旋转角速度（包含 alpha beta gamma 三个参数） DeviceMotionEvent 接口的 interval 属性返回一个 number，表示设备更新数据的间隔 物理朝向Window 接口的 deviceorientation 事件在设备的物理朝向变化时定期触发，返回一个 DeviceOrientationEvent 事件 Window 接口的 deviceorientationabsolute 事件在设备的绝对物理朝向变化时触发，返回一个 DeviceOrientationEvent 事件 1234567window.addEventListener('deviceorientation', (e) =&gt; { //})window.addEventListener('deviceorientationabsolute', (e) =&gt; { //}) DeviceOrientationEvent 接口的 absolute 属性返回一个 boolean，表明当前是否提供绝对方向数据（地球坐标系），或设备任意坐标系 DeviceOrientationEvent 接口的 alpha 属性返回一个范围在 0 至 360 之间的 number，表明设备绕 z 轴旋转的角度 DeviceOrientationEvent 接口的 beta 属性返回一个范围在 -180 至 180 之间的 number，表明设备绕 x 轴旋转的角度 DeviceOrientationEvent 接口的 gamma 属性返回一个范围在 -90 至 90 之间的 number，表明设备绕 y 轴旋转的角度 类型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071interface Window { ondeviceorientation: ((this: Window, ev: DeviceOrientationEvent) =&gt; any) | null ondeviceorientationabsolute: ((this: Window, ev: DeviceOrientationEvent) =&gt; any) | null ondevicemotion: ((this: Window, ev: DeviceMotionEvent) =&gt; any) | null}interface DeviceOrientationEvent extends Event { readonly alpha: number | null readonly beta: number | null readonly gamma: number | null readonly absolute: boolean}declare var DeviceOrientationEvent: { new (type: string, eventInitDict?: DeviceOrientationEventInit): DeviceOrientationEvent prototype: DeviceOrientationEvent requestPermission(): Promise&lt;PermissionState&gt;}interface DeviceOrientationEventInit extends EventInit { alpha?: number | null beta?: number | null gamma?: number | null absolute?: boolean}interface DeviceMotionEventAcceleration { readonly x: number | null readonly y: number | null readonly z: number | null}interface DeviceMotionEventRotationRate { readonly alpha: number | null readonly beta: number | null readonly gamma: number | null}interface DeviceMotionEvent extends Event { readonly acceleration: DeviceMotionEventAcceleration | null readonly accelerationIncludingGravity: DeviceMotionEventAcceleration | null readonly rotationRate: DeviceMotionEventRotationRate | null readonly interval: number}declare var DeviceMotionEvent: { new (type: string, eventInitDict?: DeviceMotionEventInit): DeviceMotionEvent prototype: DeviceMotionEvent requestPermission(): Promise&lt;PermissionState&gt;}interface DeviceMotionEventAccelerationInit { x?: number | null y?: number | null z?: number | null}interface DeviceMotionEventRotationRateInit { alpha?: number | null beta?: number | null gamma?: number | null}interface DeviceMotionEventInit extends EventInit { acceleration?: DeviceMotionEventAccelerationInit accelerationIncludingGravity?: DeviceMotionEventAccelerationInit rotationRate?: DeviceMotionEventRotationRateInit interval?: number} 链接 https://developer.mozilla.org/en-US/docs/Web/API/Device_orientation_events https://w3c.github.io/deviceorientation/","link":"/2023/11/13/DeviceOrientation-Event/"},{"title":"Document Picture-in-Picture API","text":"Document Picture-in-Picture API 是对原有 Picture-in-Picture API 的扩展，允许任意 DOM 元素进入画中画模式 任意时刻，每个顶层浏览上下文只能存在一个画中画窗口（多次调用会复用之前的画中画窗口） 该 API 必须在严格上下文模式下调用 Window 接口暴露的 documentPictureInPicture 只读属性提供的 DocumentPictureInPicture 接口实例来使用该 API 打开画中画窗口DocumentPictureInPicture 接口的 requestWindow() 方法用于打开一个画中画窗口 方法传入一个可选的配置项，其 width 选项和 height 选项代表画中画窗口的宽度和高度 方法返回一个 Promise 的 Window，代表当前文档对应的画中画窗口 方法可能抛出 NotSupportedError，若该 API 不被支持（如因为用户的设置） 方法可能抛出 NotAllowedError，若未因为用户交互调用，或未在顶层浏览上下文在调用，或在画中画窗口中调用 方法可能抛出 RangeError，若参数 width 和 height 仅指定其一或另一为 0 1234const pipwindow = await window.documentPictureInPicture.requestWindow({ width: 800, height: 600,}) DocumentPictureInPicture 接口的 enter 事件在打开画中画窗口时触发，返回一个 DocumentPictureInPictureEvent 事件 画中画窗口DocumentPictureInPicture 接口的 window 只读属性返回 Window 或 null，反映当前文档对应的画中画窗口，若不存在返回 null DocumentPictureInPicture 接口的 requestWindow() 方法打开的画中画窗口与 Window 接口的 open() 方法打开的同源的窗口类似 但存在以下一些区别： 画中画窗口始终浮动在其他窗口顶部 画中画窗口的生命周期一定不会比打开其的窗口的生命周期晚结束 画中画窗口无法被导航 画中画窗口的位置无法被网站设置 关闭画中画窗口可能因为用户点击关闭按钮而关闭，或是调用 Window 接口的 close() 方法编程式关闭 在画中画窗口关闭时，类似与普通页面一样，可以通过监听 pagehide 事件其发生的时机 类型1234567891011121314151617181920212223interface Window { readonly documentPictureInPicture: DocumentPictureInPicture}interface DocumentPictureInPicture extends EventTarget { requestWindow(options?: DocumentPictureInPictureOptions): Promise&lt;Window&gt; readonly window: Window | null onenter}interface DocumentPictureInPictureOptions { width: number height: number}interface DocumentPictureInPictureEvent extends Event { constructor(type: string, eventInitDict: DocumentPictureInPictureEventInit) readonly window: Window}interface DocumentPictureInPictureEventInit extends EventInit { window: Window} 链接 https://developer.mozilla.org/en-US/docs/Web/API/Document_Picture-in-Picture_API https://wicg.github.io/document-picture-in-picture/","link":"/2023/10/31/Document-Picture-in-Picture-API/"},{"title":"EyeDropper API","text":"EyeDropper API 提供了 eyedropper 工具，允许用户选择屏幕上的某个特定位置的颜色 该 API 仅在严格上下文环境下允许使用 使用EyeDropper() 构造函数用于创建一个 eyedropper 工具 调用 EyeDropper 接口的 open() 方法以选择颜色 方法接受一个可选的配置项，其唯一可选属性 signal 是一个 AbortSignal，可用于编程式退出选择过程 方法返回一个 Promise 的对象，其唯一属性 sRGBHex 代表一个相应的十六进制的颜色字符串 方法可能抛出 NotAllowedError，若方法不是因为用户交互触发的 方法可能抛出 InvalidStateError，若当前已存在其他打开的 EyeDropper 方法可能抛出 AbortError，若用户退出选择颜色或因调用 AbortSignal.abort() 方法退出 方法可能抛出 OperationError，若因为除用户主动退出之外的原因导致获取颜色信息失败 12345678910111213try { const eyeDropper = new EyeDropper() const controller = new AbortController() const { sRGBHex } = await eyeDropper.open({ signal: controller.signal, }) console.log(sRGBHex)} catch (err) { console.error(err)} 示例 选择的颜色为： 选择颜色 const span = document.querySelector('#eyedropper span'); const div = document.querySelector('#eyedropper div'); const button = document.querySelector('#eyedropper button'); const eyedropper = new window.EyeDropper(); button.addEventListener('click', async () => { const controller = new AbortController(); setTimeout(() => { controller.abort(); }, 2500); const { sRGBHex } = await eyedropper.open({ signal: controller.signal, }); div.style.backgroundColor = sRGBHex; span.innerText = '选择的颜色为：' + sRGBHex; }); 类型123456789101112interface ColorSelectionResult { sRGBHex: string}interface ColorSelectionOptions { signal: AbortSignal}interface EyeDropper { constructor() open(options: ColorSelectionOptions): Promise&lt;ColorSelectionResult&gt;} 链接 https://developer.mozilla.org/en-US/docs/Web/API/EyeDropper_API https://wicg.github.io/eyedropper-api/","link":"/2023/10/27/EyeDropper-API/"},{"title":"File System API","text":"File System API 与扩展的 File System Access API 提供了管理设备本地文件系统的功能，包括读取、修改和管理文件的功能 FileSystemHandle 接口作为文件句柄或目录句柄的通用接口 FileSystemFileHandle 接口作为文件句柄的接口 FileSystemDirectoryHandle 接口作为目录句柄的接口 FileSystemSyncAccessHandle 接口作为同步访问句柄的接口 FileSystemWritableFileStream 接口作为读写本地文件流的接口 Window 接口上的 showOpenFilePicker()、showSaveFilePicker()、showDirectoryPicker() 方法及 DataTransferItem 接口的 getAsFileSystemHandle() 方法用于获取文件句柄或目录句柄 StorageManager 接口上的 getDirectory() 方法用于获取 OPFS 的根目录句柄 通常而言，File System API 需要用户明确的许可，但 OPFS —— Origin Private File System 机制除外。 通常 File System API 的大多数操作是异步的，支持同步的 FileSystemSyncAccessHandle 接口仅在 Web Worker 内可用针对 OPFS 使用。 初始化获取用户选择资源的文件句柄使用 Window 接口的 showOpenFilePicker() 方法选取单个或多个文件，返回对应的文件句柄 方法传入一组可选的配置项 excludeAcceptAllOption 可选选项指定选择器是否启用筛选文件类型的选项，默认值是 false id 选项用于和当前目录配对，会自动记忆与之相关的目录，后续选择时若指定相同的 id 可以自动打开与之前选择相同的目录，接收一个字符串 startIn 选项指定初始打开目录，接收一个 FileSystemHandle 或预设的目录 &quot;desktop&quot; &quot;documents&quot; &quot;downloads&quot; &quot;music&quot; &quot;pictures&quot; 或 &quot;videos&quot; multiple 可选选项指定是否允许多选，默认值是 false types 选项指定允许选择的文件类型，传递一个数组，数组各项支持 accept 选项，指定文件类型的 MIME 类型和 description 可选选项，指定文件类型的描述 返回一个 Promise 的 FileSystemFileHandle 数组 方法在用户未选择目录或用户代理拒绝目录访问时抛出 AbortError 异常 方法要求在调用需基于发生用户交互 获取用户新增资源的文件句柄使用 Window 接口的 showSaveFilePicker() 方法新增文件（可以是已有文件或新文件），返回对应的文件句柄 方法传入一组可选的配置项 excludeAcceptAllOption 可选选项同上 id 选项同上 startIn 选项同上 suggestedName 可选选项指定建议的新增文件名称 types 选项同上 返回一个 Promise 的 FileSystemFileHandle 方法在用户未选择目录或用户代理拒绝目录访问时抛出 AbortError 异常 方法要求在调用需基于发生用户交互 获取用户选择资源的目录句柄使用 Window 接口的 showDirectoryPicker() 选取目录，返回对应的目录句柄 方法传入一组可选的配置项 id 选项同上 mode 可选选项用于指定权限模式，接收字符串枚举 &quot;read&quot; 或 &quot;readwrite&quot;，默认值为 &quot;read&quot; startIn 选项同上 返回一个 Promise 的 FileSystemDirectoryHandle 方法在用户未选择目录或用户代理拒绝目录访问时抛出 AbortError 异常 方法要求在调用需基于发生用户交互 获取拖动资源的文件句柄或目录句柄使用 DataTransferItem 接口的 getAsFileSystemHandle() 方法获取拖动资源的文件句柄或目录句柄 返回一个 Promise 的 FileSystemFileHandle 或 FileSystemDirectoryHandle 获取 OPFS 的根目录句柄使用 StorageManager 接口的 getDirectory() 方法获取 OPFS 的根目录句柄 返回一个 Promise 的 FileSystemDirectoryHandle 对象 并在用户代理无法使用请求的文件目录建立本地 OPFS 索引时抛出 SecurityError 异常 文件及目录操作通过 FileSystemHandle 接口进行文件目录相关的操作，该接口是 FileSystemFileHandle 接口与 FileSystemDirectoryHandle 接口的父接口 句柄类型FileSystemHandle 接口的 kind 属性返回一个字符串枚举值，代表句柄的类型 当当前句柄为 FileSystemFileHandle 时，返回 'file' 当当前句柄为 FileSystemDirectoryHandle 时，返回 'directory' 句柄名称FileSystemHandle 接口的 name 属性返回一个字符串，代表句柄对应的文件或目录的名称 句柄比较FileSystemHandle 接口的 isSameEntry() 方法判断当前句柄与传入的句柄是否指向同一个文件或目录 方法接收一个 FileSystemHandle 方法返回一个 Promise 的 boolean 权限操作FileSystemHandle 接口的 queryPermission() 方法用于枚举当前句柄的指定权限 FileSystemHandle 接口的 requestPermission() 方法用于请求当前句柄的指定权限 方法均支持传入一组可选的描述符，唯一 mode 参数可以为 'read' 或 'readwrite' 之一，默认为 'read' 方法均返回一个 Promise 的 PermissionStatus 接口实例 文件操作通过 FileSystemFileHandle 接口进行文件相关的操作，该接口继承自 FileSystemHandle 接口 获取文件FileSystemFileHandle 接口的 getFile() 方法可以用于读取文件相关信息及用于网络传输 返回一个 Promise 的 File 对象 抛出一个 NotAllowedError 若未授予访问权限 获取同步访问句柄FileSystemFileHandle 接口的 createSyncAccessHandle() 方法可以用于同步读写文件内容，但仅允许在专属 Worker 内部使用，且目前仅适用于 OPFS 机制 返回一个 Promise 的 FileSystemSyncAccessHandle 对象 抛出一个 NotAllowedError 若未授予访问权限 抛出一个 NoModificationAllowedError 若无法建立文件锁 抛出一个 InvalidStateError 若句柄无法表示 OPFS 中的文件 获取可写文件流FileSystemFileHandle 接口的 createWritable() 方法可以用于修改文件内容 可以传入一组可选的配置项，唯一选项 keepExistingData 指定 返回一个 Promise 的 FileSystemWritableFileStream 对象 抛出一个 NotAllowedError 若未授予访问权限 目录操作通过 FileSystemDirectoryHandle 接口进行目录相关的操作，该接口继承自 FileSystemHandle 接口 目录遍历FileSystemDirectoryHandle 接口支持异步遍历，包含 [@@asyncIterator]() 以及 entries()、keys()、values() 等方法 获取路径FileSystemDirectoryHandle 接口的 resolve() 方法用于获取当前句柄到指定句柄的相对路径 需要传入一个 FileSystemHandle，代表目标句柄 返回一个 Promise 的字符串数组或 null 获取子目录FileSystemDirectoryHandle 接口的 getDirectoryHandle() 方法用于获取当前目录下的指定名称的子目录的句柄 需要传入一个字符串参数，代表目录的名称，与 FileSystemHandle.name 相符 可以传入一组配置项，唯一参数 create 为一个布尔值，指定目录不存在情况下是否创建目录，默认值为 false 返回一个 Promise 的 FileSystemDirectoryHandle 对象 抛出一个 TypeError 若 name 参数不是字符串或为非法的文件系统名称 抛出一个 TypeMismatchError 若匹配到的为文件而非目录 抛出一个 NotFoundError 若未找到目录且 create 选项设定为 false 抛出一个 NotAllowedError 若未授予访问权限 获取子文件FileSystemDirectoryHandle 接口的 getFileHandle() 方法用于获取当前目录下的指定名称的子文件的句柄 需要传入一个字符串参数，代表目录的名称，与 FileSystemHandle.name 相符 可以传入一组配置项，唯一参数 create 为一个布尔值，指定目录不存在情况下是否创建目录，默认值为 false 返回一个 Promise 的 FileSystemFileHandle 对象 抛出一个 TypeError 若 name 参数不是字符串或为非法的文件系统名称 抛出一个 TypeMismatchError 若匹配到的为目录而非文件 抛出一个 NotFoundError 若未找到文件且 create 选项设定为 false 抛出一个 NotAllowedError 若未授予访问权限 删除子目录或子文件FileSystemDirectoryHandle 接口的 removeEntry() 方法用于删除当前目录下的指定名称的子目录或子文件的句柄 需要传入一个字符串参数，代表目录的名称，与 FileSystemHandle.name 相符 可以传入一组配置项，唯一参数 recursive 为一个布尔值，指定是否递归删除，默认值为 false 返回一个 Promise 的 undefined 抛出一个 TypeError 若 name 参数不是字符串或为非法的文件系统名称 抛出一个 InvalidModificationError 若目标为目录，并且包含子文件或子目录，并且 recursive 设置为 false 抛出一个 NotFoundError 若未找到文件或目录 抛出一个 NotAllowedError 若未授予访问权限 文件读取文件读取通过 FileSystemFileHandle 接口的 getFile() 方法获取到对应的 File 实例实现 文件修改文件修改通过 FileSystemFileHandle 接口的 createWritable() 方法获取到对应的 FileSystemWritableFileStream 实例实现 FileSystemWritableFileStream 接口继承自 WritableStream 接口 FileSystemWritableFileStream 接口的更改不会立即反映到实际的文件上，仅在关闭流之后才会同步其产生的更改；原因是对流的更改，至少会存储到一个临时文件中，仅在流关闭之后，才会将更改同步到实际的文件中 移动指针使用 FileSystemWritableFileStream 接口的 seek() 方法移动文件指针的位置 需要传入一个正整数 position 参数，代表文件指针的位置 返回一个 Promise 抛出一个 NotAllowedError 若未授予访问权限 抛出一个 TypeError 若 position 参数不是正整数或未传递 文件写入使用 FileSystemWritableFileStream 接口的 write() 方法用于向文件中写入内容 可以传入一个 data 参数，代表需要写入文件的内容，可以是 ArrayBuffer TypedArray DataView Blob 或 string 亦可以传入一组配置项： type 选项传入一组字符串枚举，指定操作的模式，可以是 &quot;write&quot; &quot;seek&quot; 或 &quot;truncate&quot; data 选项，代表需要写入文件的内容，可以是 ArrayBuffer TypedArray DataView Blob 或 string，在 &quot;write&quot; 模式下是必须的 position 选项，代表需要移动的文件指针的目标位置，是一个正整数，在 &quot;seek&quot; 模式下是必须的；同样可以在 &quot;write&quot; 模式下使用，此时代表写入内容的目标位置 size 选项，代表需要文件流的大小，是一个正整数，在 &quot;truncate&quot; 模式下是必须的 返回一个 Promise 抛出一个 NotAllowedError 若未授予访问权限 抛出一个 TypeError 若传入参数非法 抛出一个 InvalidStateError 若 position 选项的值超出文件大小 文件尺寸修改使用 FileSystemWritableFileStream 接口的 truncate() 方法改变文件的尺寸；方法可能会改变文件指针的位置 需要传入一个正整数 size 参数，代表目标的文件尺寸；若参数超出原有尺寸，则扩大当前文件并使用空内容填充扩大的部分，反之会裁剪当前文件 返回一个 Promise 抛出一个 NotAllowedError 若未授予访问权限 抛出一个 TypeError 若 size 参数不是正整数或未传递 文件同步读写文件同步读写通过 FileSystemFileHandle 接口的 createSyncAccessHandle() 方法获取到对应的 FileSystemSyncAccessHandle 实例实现 FileSystemSyncAccessHandle 实例仅支持在专属 Worker 中使用，且目前仅适用于 OPFS 机制 因为其无需进行权限检查，其相对而言具有更好的性能 创建 FileSystemSyncAccessHandle 实例会创建与之对应的文件锁，阻止对该文件创建其他的 FileSystemSyncAccessHandle 实例或 FileSystemWritableFileStream 实例，直到 FileSystemSyncAccessHandle 实例被销毁 读FileSystemSyncAccessHandle 接口的 read() 方法读取文件内容 方法传入一个 buffer 参数，可以是 ArrayBuffer SharedArrayBuffer TypedArray 或 DataView，代表用于存储读取文件内容的缓存区 方法支持传入一个可选的配置项：其 at 参数指定开始读取文件内容的起始位置 方法返回一个正整数，代表读取的文件内容的字节数 方法在若对应的句柄已关闭的情况下，抛出一个 InvalidStateError 写FileSystemSyncAccessHandle 接口的 write() 方法向文件写入内容 方法传入一个 buffer 参数，可以是 ArrayBuffer SharedArrayBuffer TypedArray 或 DataView，代表将用于写入的文件内容 方法可以传入一个可选的配置项：其 at 参数指定开始写入文件内容的起始位置 方法返回一个正整数，代表写入的文件内容的字节数 方法在若对应的句柄已关闭的情况下，抛出一个 InvalidStateError 读取尺寸FileSystemSyncAccessHandle 接口的 getSize() 方法返回文件的尺寸 方法返回一个正整数，代表文件内容的字节数 方法在若对应的句柄已关闭的情况下，抛出一个 InvalidStateError 更改尺寸FileSystemSyncAccessHandle 接口的 truncate() 方法用于更改文件的尺寸 方法传入一个 newSize 参数，需要是一个正整数，代表将更改的文件的目标大小 方法在若对应的句柄已关闭的情况下，抛出一个 InvalidStateError 方法在若对应的句柄已关闭的情况下，抛出一个 InvalidStateError 刷新缓冲区FileSystemSyncAccessHandle 接口的 flush() 方法用于将缓冲的更改同步至存储，通常只在特定时间段需要将缓冲的更改同步至存储时使用，否则可以让底层自行处理 关闭句柄FileSystemSyncAccessHandle 接口的 close() 方法用于关闭当前句柄，释放文件锁 类型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495interface Window { showOpenFilePicker: (options?: OpenFilePickerOptions) =&gt; Promise&lt;FileSystemFileHandle[]&gt; showSaveFilePicker: (options?: SaveFilePickerOptions) =&gt; Promise&lt;FileSystemFileHandle&gt; showDirectoryPicker: (options?: DirectoryPickerOptions) =&gt; Promise&lt;FileSystemDirectoryHandle&gt;}interface FilePickerAcceptType { description?: string accept: Record&lt;string, string | string[]&gt;}interface FilePickerOptions { excludeAcceptAllOption?: boolean id?: string types?: FilePickerAcceptType[] startIn?: StartInDirectory}interface OpenFilePickerOptions extends FilePickerOptions { multiple?: boolean}interface SaveFilePickerOptions extends FilePickerOptions { suggestedName?: string}interface DirectoryPickerOptions { id?: string startIn?: StartInDirectory mode?: FileSystemPermissionMode}type WellKnownDirectory = 'desktop' | 'documents' | 'downloads' | 'music' | 'pictures' | 'videos'type StartInDirectory = WellKnownDirectory | FileSystemHandletype FileSystemPermissionMode = 'read' | 'readwrite'interface FileSystemHandle { readonly kind: FileSystemHandleKind readonly name: string isSameEntry(other: FileSystemHandle): Promise&lt;boolean&gt;}interface FileSystemFileHandle extends FileSystemHandle { readonly kind: 'file' createSyncAccessHandle(): Promise&lt;FileSystemSyncAccessHandle&gt; createWritable(options?: FileSystemCreateWritableOptions): Promise&lt;FileSystemWritableFileStream&gt; getFile(): Promise&lt;File&gt;}interface FileSystemDirectoryHandle extends FileSystemHandle { readonly kind: 'directory' getDirectoryHandle(name: string, options?: FileSystemGetDirectoryOptions): Promise&lt;FileSystemDirectoryHandle&gt; getFileHandle(name: string, options?: FileSystemGetFileOptions): Promise&lt;FileSystemFileHandle&gt; removeEntry(name: string, options?: FileSystemRemoveOptions): Promise&lt;void&gt; resolve(possibleDescendant: FileSystemHandle): Promise&lt;string[] | null&gt;}interface FileSystemWritableFileStream extends WritableStream { seek(position: number): Promise&lt;void&gt; truncate(size: number): Promise&lt;void&gt; write(data: FileSystemWriteChunkType): Promise&lt;void&gt;}interface FileSystemSyncAccessHandle { close(): void; flush(): void; getSize(): number; read(buffer: AllowSharedBufferSource, options?: FileSystemReadWriteOptions): number; truncate(newSize: number): void; write(buffer: AllowSharedBufferSource, options?: FileSystemReadWriteOptions): number;}interface FileSystemCreateWritableOptions { keepExistingData?: boolean}interface FileSystemGetDirectoryOptions { create?: boolean}interface FileSystemGetFileOptions { create?: boolean}interface FileSystemReadWriteOptions { at?: number}interface FileSystemRemoveOptions { recursive?: boolean}type FileSystemWriteChunkType = BufferSource | Blob | string | WriteParams 链接 https://developer.mozilla.org/en-US/docs/Web/API/File_System_API https://fs.spec.whatwg.org/ https://wicg.github.io/file-system-access/","link":"/2023/10/05/File-System-API/"},{"title":"Fullscreen API","text":"Fullscreen API 允许某个特定的元素管理全屏模式 启用全屏模式通过调用 Element 接口上的 requestFullscreen() 方法以启用全屏模式 方法传入一个可选的配置项，其唯一 navigationUI 可选参数控制是否展示 navigation UI，值为 &quot;auto&quot; &quot;show&quot; &quot;hide&quot; 之一，默认值为 &quot;auto&quot; 方法返回一个 Promise 方法可能抛出 TypeError 异常，如当前文档并非处于活跃状态、当前元素未处于文档中、当前元素不允许使用全屏模式、当前元素是一个激活的 popover 元素、当前元素是 &lt;dialog&gt; 元素、当前元素不是 HTML SVG MathML 元素等等 1element.requestFullscreen() 停止全屏模式通过调用 Document 接口上的 exitFullscreen() 方法以停止全屏模式 方法返回一个 Promise 1document.exitFullscreen() 全屏模式信息Document 接口上的 fullscreenEnabled 属性反映了全屏模式是否可用，返回 boolean 值 Document 接口或 ShadowRoot 接口上的 fullscreenElement 属性反映了当前处于全屏模式的元素，返回 Element 值或 null 值 Document 接口或 Element 接口上的 fullscreenchange 事件在文档或元素的全屏状态改变时触发，返回一个 Event 事件 Document 接口或 Element 接口上的 fullscreenerror 事件在文档或元素的全屏状态改变失败时触发，返回一个 Event 事件 通常，监听 Web 程序内的全屏状态改变，通过监听 Document 接口上的即可，文档内元素的相应事件会冒泡至文档 权限策略该 API 调用受到 fullscreen 权限策略的控制，可以通过 Permissions-Policy 响应头指定，或通过 &lt;iframe&gt; 标签的 allow 属性指定 默认为 self，即允许在当前上下文或内嵌的其他同源上下文中使用 类型1234567891011121314151617181920212223interface Document { readonly fullscreenElement: Element | null readonly fullscreenEnabled: boolean exitFullscreen(): Promise&lt;void&gt; onfullscreenchange: ((this: Document, ev: Event) =&gt; any) | null onfullscreenerror: ((this: Document, ev: Event) =&gt; any) | null}interface ShadowRoot { readonly fullscreenElement: Element | null}interface Element { requestFullscreen(options?: FullscreenOptions): Promise&lt;void&gt; onfullscreenchange: ((this: Element, ev: Event) =&gt; any) | null onfullscreenerror: ((this: Element, ev: Event) =&gt; any) | null}interface FullscreenOptions { navigationUI?: FullscreenNavigationUI}type FullscreenNavigationUI = 'auto' | 'hide' | 'show' 链接 https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API https://fullscreen.spec.whatwg.org/","link":"/2023/10/25/Fullscreen-API/"},{"title":"Geolocation API","text":"Geolocation API 提供了访问用户地理位置的方法 通过 navigator.geolocation 暴露的 Geolocation 接口实例访问 使用 API 需要向用户请求授权并获得允许，并且仅在 Secure Context 环境下启用 获取地理位置使用 Geolocation 接口的 getCurrentPosition() 方法获取地理位置 方法需要传入一个在获取地理位置成功时调用的回调函数，该回调函数会被传递一个 GeolocationPosition 参数 方法可以传入一个在获取地理位置失败时调用的回调函数，该回调函数会被传递一个 GeolocationPositionError 参数 方法同样可以传入一个可选的配置项： maximumAge 可选选项接收一个正数值，指定使用缓存的地理位置的允许的最长的期限，默认为 0 timeout 可选选项接收一个正数值，指定获取地理位置等待的超时时间，默认为 Infinity enableHighAccuracy 可选选项接收一个布尔值，指定是否尝试获取最精确的可能值，默认值 false 权限策略该 API 调用受到 geolocation 权限策略的控制，可以通过 Permissions-Policy 响应头指定，或通过 &lt;iframe&gt; 标签的 allow 属性指定 默认值是 *，即允许任意源的浏览上下文使用该 API 权限 API该 API 调用需要获得用户 geolocation 权限的允许，可以调用 Permission.query() 方法检查用户是否已授予了该权限 12345678910111213navigator.geolocation.getCurrentPosition( (position) =&gt; { // todo something with the position data }, (error) =&gt; { // todo something when getting position failed }, { maximumAge: 0, timeout: Infinity, enableHighAccuracy: false, }) 监听地理位置使用 Geolocation 接口的 watchPosition() 方法注册监听地理位置的更新 方法的参数类似于 getCurrentPosition() 方法 方法返回一个数字，代表注册回调的 ID，可用于 clearWatch() 方法取消监听 使用 Geolocation 接口的 clearWatch() 方法取消注册监听地理位置的更新 地理位置信息GeolocationPosition 接口用于表示一组地址位置信息记录 其 coords 只读属性代表一个 GeolocationCoordinates 实例，表示地址位置信息的具体内容 而 timestamp 只读属性返回一个时间戳，代表获取地址位置信息的时间点 GeolocationCoordinates 接口用于表示一个地址位置信息详情 latitude 只读属性代表纬度 longitude 只读属性代表经度 accuracy 只读属性代表经纬度精度 altitude 只读属性代表海平面高度，设备不支持时返回 null altitudeAccuracy 只读属性代表海平面高度精度，设备不支持时返回 null heading 只读属性代表设备方向，设备不支持时返回 null speed 只读属性代表设备移动速度，设备不支持时返回 null 异常处理GeolocationPositionError 接口表示获取地理位置失败的异常 code 只读属性代表错误状态码，可能为常量枚举 PERMISSION_DENIED、POSITION_UNAVAILABLE 或 TIMEOUT 之一，常量枚举可以通过 GeolocationPositionError 本身或其实例访问 message 只读属性代表错误信息，通常是用于调试目的而非直接向用户展示 权限策略该 API 调用受到 geolocation 权限策略的控制，可以通过 Permissions-Policy 响应头指定，或通过 &lt;iframe&gt; 标签的 allow 属性指定 默认为 self，即允许在当前上下文或内嵌的其他同源上下文中使用 权限 API该 API 调用需要用户授予 geolocation 权限，可以调用 Permission.query() 方法检查用户是否已授予了该权限 类型12345678910111213141516171819202122232425262728293031323334353637383940414243444546interface Navigator { readonly geolocation: Geolocation}interface Geolocation { clearWatch(watchId: number): void getCurrentPosition(successCallback: PositionCallback, errorCallback?: PositionErrorCallback | null, options?: PositionOptions): void watchPosition(successCallback: PositionCallback, errorCallback?: PositionErrorCallback | null, options?: PositionOptions): number}interface PositionCallback { (position: GeolocationPosition): void}interface PositionErrorCallback { (positionError: GeolocationPositionError): void}interface PositionOptions { enableHighAccuracy?: boolean maximumAge?: number timeout?: number}interface GeolocationPosition { readonly coords: GeolocationCoordinates readonly timestamp: EpochTimeStamp}interface GeolocationPositionError { readonly code: number readonly message: string readonly PERMISSION_DENIED: 1 readonly POSITION_UNAVAILABLE: 2 readonly TIMEOUT: 3}interface GeolocationCoordinates { readonly accuracy: number readonly altitude: number | null readonly altitudeAccuracy: number | null readonly heading: number | null readonly latitude: number readonly longitude: number readonly speed: number | null} 链接 https://developer.mozilla.org/en-US/docs/Web/API/Geolocation_API https://w3c.github.io/geolocation-api/","link":"/2023/10/15/Geolocation-API/"},{"title":"Get Installed Related Apps API","text":"Get Installed Related Apps API 允许网页应用检测与之相关的应用是否已在本地设备下载 支持检测的应用包括通用 Window 应用 Android 应用或 PWA 应用 使用 API调用 Navigator 接口上的 getInstalledRelatedApps() 方法以使用该 API 方法返回一个 Promise 的相关应用信息数组 id 项代表应用的 ID，具体格式受不同操作系统而有所不同 url 项代表与应用相关的 URL version 项代表与应用相关的版本 platform 项代表应用的操作系统类型，可能是 chrome_web_store play chromeos_play webapp windows f-droid amazon 之一 方法抛出 InvalidStateError 错误，若未在顶层浏览器上下文中调用 12345678const apps = await navigator.getInstalledRelatedApps()for (const app of apps) { console.log(app.id) console.log(app.url) console.log(app.version) console.log(app.platform)} 方法必须在顶层文档上下文中调用，且要求必须处于严格上下文环境中 背景要求当前网页应用需要在 manifest 文件中指定 related_applications 字段 本地应用需要与网页应用存在某种形式的联系，如： Android 应用通过 Digital Asset Links system 实现 Window 应用通过 URI Handlers 实现 PWA 应用通过其 manifest 文件中定义的 related_applications 字段或 /.well-known/assetlinks.json 文件定义 类型12345678910interface Navigator { getInstalledRelatedApps(): Promise&lt;RelatedApplication[]&gt;}interface RelatedApplication { platform: string url?: string id?: string version?: string} 链接 https://wicg.github.io/get-installed-related-apps/spec/","link":"/2023/10/30/Get-Installed-Related-Apps-API/"},{"title":"Keyboard Lock API","text":"Keyboard Lock API 允许控制键盘的输入形式，捕获键盘的输入从而进行自定义的处理（特别是针对一些特殊按键） 通过 navigator.keyboard 暴露的 Keyboard 接口实例使用 该 API 的使用要求有用户交互的发生 启用键盘锁定使用 Keyboard 接口的 lock() 方法启用键盘锁定 方法可以传递一个可选的 keyCodes 字符串数组参数，代表要锁定的键值码；不传递则代表锁定所有的按键 方法返回一个 Promise 方法可能抛出 AbortError，若在该方法完成前又重新调用了该方法 方法可能抛出 InvalidAccessError，若任一 keyCodes 中的项非法 方法可能抛出 InvalidStateError，若方法未在活跃浏览器上下文中调用 12navigator.keyboard.lock()navigator.keyboard.lock(['KeyW', 'KeyA', 'KeyS', 'KeyD']) 若调用多次调用 lock() 方法且中途未调用 unlock() 方法，则只有最后一次指定的 keyCodes 有效 停止键盘锁定使用 Keyboard 接口的 unlock() 方法停止键盘锁定 1navigator.keyboard.unlock() 类型12345678interface Keyboard extends EventTarget { lock(keyCodes?: string[]): Promise&lt;void&gt; unlock(): void}interface Navigator { readonly keyboard: Keyboard} 链接 https://developer.mozilla.org/en-US/docs/Web/API/Keyboard_API https://wicg.github.io/keyboard-lock/","link":"/2023/10/24/Keyboard-Lock-API/"},{"title":"KeyboardEvent Sequence","text":"KeyboardEvent 事件链路Keyboard 的相关操作会触发相应 DOM 元素以及全局 window 对象上的一些事件处理回调方法，并产生相应的事件链路，包括 keydown、keypress、keyup 等键盘事件，beforeinput、input 等输入事件以及 compositionstart、compositionupdate、compositionend 等组合输入事件 事件触发链路keydown 按下键盘按键【KeyboardEvent】 keypress 按下产生字符值按键（需为字母键、数字键和标点符号键而非修饰键）【KeyboardEvent】 compositionstart 开始组合输入（需为组合输入模式）【CompositionEvent】 beforeinput 即将产生编辑效果（仅在可输入元素时触发）【InputEvent】 compositionupdate 更新组合输入内容（需为组合输入模式）【CompositionEvent】 input 即将产生编辑效果（仅在可输入元素时触发）【InputEvent】 若持续按下键盘按键，则按自1至4的顺序循环触发事件直至松开键盘按键【同时事件的repeat属性标记为true】 compositionend 结束组合输入（需为组合输入模式）【CompositionEvent】 keyup 松开键盘按键【KeyboardEvent】 示例 正常按下按键 1 keydown keypress beforeinput input keyup 连续按下按键 1 keydown keypress beforeinput input keydown keypress beforeinput input …… keyup 中文模式下，按下 w 键，利用鼠标选中 我 keydown compositionstart beforeinput compositionupdate input keyup keyup beforeinput compositionupdate input compositionend 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;textarea id=&quot;el&quot;&gt;&lt;/textarea&gt; &lt;script&gt; const el = document.getElementById('el') el.addEventListener('keydown', () =&gt; { console.log('keydown') }) el.addEventListener('keypress', () =&gt; { console.log('keypress') }) el.addEventListener('beforeinput', () =&gt; { console.log('beforeinput') }) el.addEventListener('input', () =&gt; { console.log('input') }) el.addEventListener('keyup', () =&gt; { console.log('keyup') }) el.addEventListener('compositionstart', () =&gt; { console.log('compositionstart') }) el.addEventListener('compositionupdate', () =&gt; { console.log('compositionupdate') }) el.addEventListener('compositionend', () =&gt; { console.log('compositionend') }) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","link":"/2023/08/22/KeyboardEvent%20Sequence/"},{"title":"Keyboard Map API","text":"Keyboard Map API 允许获取键盘按键码至键盘按键名的映射 通过 navigator.keyboard 暴露的 Keyboard 接口实例使用 获取键盘映射Keyboard 接口的 getLayoutMap() 方法提供了获取键盘映射的方法 方法返回一个 Promise 的 KeyboardLayoutMap 实例 1234navigator.keyboard.getLayoutMap().then((layoutMap) =&gt; { const code = 'KeyW' const key = layoutMap.get(code)}) KeyboardLayoutMap 接口反映了一组键值对对象，键名为键盘按键码，键值为键盘按键名；它是一个只读的类 map 对象 键盘映射更改Keyboard 接口的 layoutchange 事件在键盘映射改变时触发 该事件尚未得到主流浏览器的支持 权限策略该 API 调用受到 keyboard-map 权限策略的控制，可以通过 Permissions-Policy 响应头指定，或通过 &lt;iframe&gt; 标签的 allow 属性指定 默认为 self，即允许在当前上下文或内嵌的其他同源上下文中使用 类型12345678910111213141516171819interface Keyboard extends EventTarget { lock(keyCodes?: string[]): Promise&lt;void&gt; unlock(): void}interface Navigator { readonly keyboard: Keyboard}interface KeyboardLayoutMap { forEach(callbackfn: (value: string, key: string, map: Map&lt;string, string&gt;) =&gt; void, thisArg?: any): void get(key: string): string | undefined has(key: string): boolean readonly size: number entries(): IterableIterator&lt;[string, string]&gt; keys(): IterableIterator&lt;string&gt; values(): IterableIterator&lt;string&gt; [Symbol.iterator](): IterableIterator&lt;[string, string]&gt;} 链接 https://developer.mozilla.org/en-US/docs/Web/API/Keyboard_API https://wicg.github.io/keyboard-map/","link":"/2023/10/28/Keyboard-Map-API/"},{"title":"Local Font Access API","text":"Local Font Access API 向开发者提供了获取用户本地安装的字体的信息的方式，包括字体名称、字体样式及字体族等等 获取本地字体调用 window.queryLocalFonts() 方法来获取本地安装的字体 方法允许传入一组可选的配置项，其 postscriptNames 参数允许传入一组字符串数组，代表希望筛选的 postscriptName 名称 方法会返回 Promise 的 FontData 数组，表示本地安装的字体的列表 方法可能抛出 NotAllowedError 异常，表示用户拒绝授予开发者 'local-fonts' 权限 方法可能抛出 SecurityError 异常，表示该 API 受 Permissions Policy 的限制无法被调用或调用该方法并非缘于用户交互行为 123window.queryLocalFonts().then((fonts) =&gt; { // to do something}) 处理本地字体字体信息使用 FontData 接口表示 FontData 接口的 family 属性表示字体的字体族，可以用于 CSS 的 font-family 属性或者 @font-face 规则中的 local() 函数等； FontData 接口的 fullName 属性表示字体的全名，通常是一个用户可辨识的名称，可以用于向用户展示； FontData 接口的 postscriptName 属性表示字体的 PostScript 名称，可以用于唯一地辨识字体； FontData 接口的 style 属性表示字体的样式，可以用于 CSS 的 font-style 属性； 12345678910async function logFonts() { const fonts = await window.queryLocalFonts() for (const data of fonts) { console.log(data.postscriptName) console.log(data.fullName) console.log(data.family) console.log(data.style) }} FontData 接口的 blob() 方法以 Blob 形式返回字体的源数据； 1234567891011121314151617181920async function getFontFormat(font) { const data = await fontData.blob() const version = await data.slice(0, 4).text() let format: 'unknown' | 'truetype' | 'cff' = 'unknown' switch (format) { case &quot;\\x00\\x01\\x00\\x00&quot;: case &quot;true&quot;: case &quot;typ1&quot;: format = &quot;truetype&quot; break case &quot;OTTO&quot;: format = &quot;cff&quot; break } return format} 权限策略该 API 调用受到 local-fonts 权限策略的控制，可以通过 Permissions-Policy 响应头指定，或通过 &lt;iframe&gt; 标签的 allow 属性指定 默认为 self，即允许在当前上下文或内嵌的其他同源上下文中使用 权限 API该 API 调用需要用户授予 local-fonts 权限，可以调用 Permission.query() 方法检查用户是否已授予了该权限 类型123456789101112131415interface Window { queryLocalFonts: (options?: QueryOptions) =&gt; Promise&lt;FontData[]&gt;}interface QueryOptions { postscriptNames?: string[]}interface FontData { readonly family: string readonly fullName: string readonly postscriptName: string readonly style: string blob: () =&gt; Promise&lt;Blob&gt;} 链接 https://developer.mozilla.org/en-US/docs/Web/API/Local_Font_Access_API https://wicg.github.io/local-font-access/","link":"/2023/09/20/Local-Font-Access-API/"},{"title":"NestJS","text":"Nest.js初始化 Nest.js pnpm dlx @nestjs/cli new &lt;project name&gt; 生成resource资源 nest generate resource 生成module文件 nest generate module &lt;module name&gt; 生成service文件 nest generate service &lt;module name&gt; 生成filter文件 nest generate filter prisma-client-exception Prisma初始化 Prisma prisma init 生成 migration 与 初始化数据库 prisma migrate dev --name &lt;migrate name&gt; 执行种子方法 prisma db seed","link":"/2023/06/17/NestJS/"},{"title":"Notifications API","text":"创建通知ServiceWorkerRegistration 接口的 showNotification() 方法用于在对应的 Service Worker 上创建一条（系统）通知，该通知的相关操作会在对应的 Service Worker 全局上下文上触发相应的事件。 该方法接受一个字符串作为通知的标题，并接受一组配置项作为通知的选项，相关参数类似 Notification() 构造函数的选项；返回一个无参的 Promise。 浏览器环境中可以利用 navigator.serviceWorker.ready 等属性或方法获取到 ServiceWorkerRegistration 实例以创建通知。 12345678910111213141516window.navigator.serviceWorker.ready.then((registration) =&gt; { registration.showNotification('Hello', { body: 'this is a notification', icon: '&lt;url&gt;', actions: [ { title: 'Yes', action: 'Yes', }, { title: 'No', action: 'No', }, ], })}) Service Worker 环境可以利用 self.registration 属性获取到当前 Service Worker 对应的 ServiceWorkerRegistration 实例以创建通知。 1234567891011121314self.registration.showNotification('Hello', { body: 'this is a notification', icon: '&lt;url&gt;', actions: [ { title: 'Yes', action: 'Yes', }, { title: 'No', action: 'No', }, ],}) 如果未使用 Service Worker，可以在浏览器环境中直接使用 Notification() 构造函数来创建通知 1const notificaion = new Notification('notification') 需要注意的是，ServiceWorker 环境内无法调用 Notification() 构造函数来创建通知。 请求通知权限需要注意的是，创建一条 Notification 需要用户授予通知权限，可以使用 Notification.permission 属性检测用户是否授予了通知权限，并使用 Notification.requestPermission() 静态方法向用户请求通知权限。 123456789if (Notification.permission === 'granted') { // just go to create the notification} else if (Notification.permission !== 'denied') { Notification.requestPermission().then((result) =&gt; { if (result === 'granted') { // then go to create the notification } })} 获取通知ServiceWorkerRegistration 接口的 getNotifications() 方法用于获取在对应的 Service Worker 上创建的（系统）通知。 该方法支持传入一组筛选项，其仅支持 tag 参数，以筛选返回结果的通知；该方法返回一个 Promise 的 Notification 列表 可以使用该方法获取到通知再进行修改。 1234567window.navigator.serviceWorker.ready.then((registration) =&gt; { registration.getNotifications({ tag: 'tag', }).then((notifications) =&gt; { // use notifications to do something })}) 12345self.registration.getNotifications({ tag: 'tag',}).then((notifications) =&gt; { //}) 通知处理当与当前 Service Worker 对应的通知被点击时，在 Service Worker 全局触发 notificationclick 事件。 1234self.addEventListener('notificationclick', (e) =&gt; { // 返回一个 NotificationEvent 事件对象 console.log('Notification click', e)}) 当与当前 Service Worker 对应的通知被关闭时，在 Service Worker 全局触发 notificationclose 事件。 1234self.addEventListener('notificationclose', (e) =&gt; { // 返回一个 NotificationEvent 事件对象 console.log('Notification close', e)}) NotificationEvent 接口继承自 ExtendableEvent 接口 notification 属性代表触发事件的 Notification 实例 action 顺序代表触发事件的 action 的 ID 权限 API该 API 调用需要用户授予 notifications 权限，可以调用 Permission.query() 方法或读取 Notification.permission 属性检查用户是否已授予了该权限 示例 https://github.com/skyclouds2001/Frontend-Learning/blob/main/next-learning/notification.html https://github.com/skyclouds2001/Frontend-Learning/blob/main/next-learning/notification.js 类型123456789101112131415161718192021222324252627282930313233343536373839404142434445interface NotificationAction { action: string; icon?: string; title: string;}interface NotificationOptions { actions?: NotificationAction[]; badge?: string; body?: string; data?: any; dir?: NotificationDirection; icon?: string; image?: string; lang?: string; renotify?: boolean; requireInteraction?: boolean; silent?: boolean | null; tag?: string; timestamp?: EpochTimeStamp; vibrate?: VibratePattern;}interface NotificationEvent extends ExtendableEvent { readonly action: string; readonly notification: Notification;}interface Notification extends EventTarget { constructor(title: string, options?: NotificationOptions); static readonly permission: NotificationPermission; readonly body: string; readonly data: any; readonly dir: NotificationDirection; readonly icon: string; readonly lang: string; onclick: ((this: Notification, ev: Event) =&gt; any) | null; onclose: ((this: Notification, ev: Event) =&gt; any) | null; onerror: ((this: Notification, ev: Event) =&gt; any) | null; onshow: ((this: Notification, ev: Event) =&gt; any) | null; readonly silent: boolean | null; readonly tag: string; readonly title: string; close(): void;} 链接 https://developer.mozilla.org/en-US/docs/Web/API/Notifications_API https://notifications.spec.whatwg.org/","link":"/2023/09/10/Notifications-API/"},{"title":"Network Information API","text":"Network Information API 允许获取网络信息和监听网络信息更改，以及 Save Data API 提供了侦测用户流量使用倾向的方法 通过 navigator.connection 暴露 NetworkInformation 实例使用 获取网络信息NetworkInformation 接口的 type 属性表示当前的网络连接的类型 NetworkInformation 接口的 effectiveType 属性表示当前的网络连接的状态 NetworkInformation 接口的 downlink 属性表示当前的 downlink 速度 NetworkInformation 接口的 downlinkMax 属性表示当前最大的 downlink 速度 NetworkInformation 接口的 rtt 属性表示当前的 RTT 参数 NetworkInformation 接口的 saveData 属性表示当前的用户是否倾向于节省流量使用 123456const type = navigator.connection.typeconst effectiveType = navigator.connection.effectiveTypeconst downlink = navigator.connection.downlinkconst downlinkMax = navigator.connection.downlinkMaxconst rtt = navigator.connection.rttconst saveData = navigator.connection.saveData 监听网络信息NetworkInformation 接口的 change 事件在网络信息更新时触发 1navigator.connection.addEventListener('change', () =&gt; { /* to do something */ }) 类型12345678910111213141516171819202122232425interface Navigator { readonly connection: NetworkInformation}interface WorkerNavigator { readonly connection: NetworkInformation}interface NetworkInformation extends EventTarget { readonly type: ConnectionType readonly effectiveType: EffectiveConnectionType readonly downlinkMax: number readonly downlink: number readonly rtt: number readonly saveData: boolean onchange: ((this: NetworkInformation, ev: Event) =&gt; any) | null}interface NetworkInformationEventMap { change: Event}type ConnectionType = 'bluetooth' | 'cellular' | 'ethernet' | 'none' | 'wifi' | 'wimax' | 'other' | 'unknown'type EffectiveConnectionType = 'slow-2g' | '2g' | '3g' | '4g' 链接 https://developer.mozilla.org/en-US/docs/Web/API/Network_Information_API https://wicg.github.io/netinfo/","link":"/2023/10/26/Network-Information-API/"},{"title":"PWA","text":"PWA 即 Progressive Web App ———— 渐进式网络应用 PWA 技术允许用户像 Native 应用一样使用 Web 应用，支持多平台和多设备访问，并且支持在线或离线访问 PWA 技术的核心是 ServiceWorker 技术，并基于 ServiceWorker 技术支持离线访问 PWA 特点 可通过 URL 访问并被搜索引擎抓取 可以安装到本地（A2HS） 可以使用 URL 分享 可以在离线状态访问 适配老版浏览器访问，并支持在新浏览器中使用更多新特性 支持在有新内容时更新 能适配各种尺寸屏幕 仅通过 HTTPS 提供服务 PWA 创建 页面通过 link 标签引入 manifest 文件 文件后缀名可以是 json 或者 webapp、webmanifest 1&lt;link rel=&quot;manifest&quot; href=&quot;manifest.json&quot; /&gt; 该文件是一个 JSON 的语法，必须指定的项为 name、icons（对于 Chromium 系浏览器 start_url、display 或 display_override 也是需要指定的） 12345678910{ &quot;name&quot;: &quot;My PWA&quot;, &quot;icons&quot;: [ { &quot;src&quot;: &quot;icons/512.png&quot;, &quot;type&quot;: &quot;image/png&quot;, &quot;sizes&quot;: &quot;512x512&quot; } ]} name 指定应用的名称，接受一个字符串 icons 指定应用的图标，接受一个数组，数组各项可以指定 src、sizes、type 项，分别代表图标的 URL、尺寸及 MIME 类型 manifest.json 文件的详细配置可以参考相关的文档 页面中注册 ServiceWorker，且 ServiceWorker 中监听了 fetch 事件 页面须启用 Secure Context，即使用 HTTPS 协议或者为本地资源 PWA 下载PWA 下载可以通过浏览器访问对应的网页实现 通常浏览器检测到网页支持下载为 PWA 时，会显示一个默认的“下载为 PWA”的按钮，也可以自定义“下载为 PWA”的按钮 通过监听全局的 beforeinstallprompt 事件获取到 BeforeInstallPromptEvent 事件实例并存储，通常该事件在页面加载时即触发；在必要时刻调用 BeforeInstallPromptEvent.prompt() 方法以使用户确认下载 PWA 应用；下载完成后会在全局触发 appinstalled 事件 PWA 下载亦可以通过应用商店等场景下载 PWA 原理PWA 实质是仅将应用行为上类似于原生应用，如在桌面显示图标，在应用列表显示，支持卸载等；并不会将应用程序的资源文件主动下载至本地，具体策略由开发者通过 IndexedDB、ServiceWorker、Cache Storage 等开发实施 示例 https://github.com/skyclouds2001/Frontend-Learning/blob/main/next-learning/PWA-eg","link":"/2023/09/30/PWA/"},{"title":"Picture-in-Picture API","text":"Picture-in-Picture API 允许某个特定的视频元素管理画中画模式 启用画中画模式通过调用 HTMLVideoElement 接口上的 requestPictureInPicture() 方法以启用画中画模式 方法返回一个 Promise 的 PictureInPictureWindow 方法可能抛出 SecurityError 异常，如当前特性被 Permission Policy 拒绝 1element.requestPictureInPicture() 停止画中画模式通过调用 Document 接口上的 exitPictureInPicture() 方法以停止画中画模式 方法返回一个 Promise 1document.exitPictureInPicture() 画中画模式信息HTMLVideoElement 接口上的 disablePictureInPicture 属性反映了当前视频元素的画中画模式是否可用，返回 boolean 值 Document 接口上的 pictureInPictureEnabled 只读属性反映了当前文档的画中画模式是否可用，返回 boolean 值 Document 接口或 ShadowRoot 接口上的 pictureInPictureElement 只读属性反映了当前处于画中画模式的元素，返回 Element 值或 null 值 HTMLVideoElement 接口上的 enterpictureinpicture 事件在当前元素成功启用画中画模式时触发，返回一个 PictureInPictureEvent 事件 HTMLVideoElement 接口上的 leavepictureinpicture 事件在当前元素成功停止画中画模式时触发，返回一个 PictureInPictureEvent 事件 PictureInPictureEvent 事件继承自 Event 事件，其唯一额外 pictureInPictureWindow 只读属性代表当前事件相关的 PictureInPictureWindow 实例 PictureInPictureWindow 接口反映了当前的画中画模式窗口，其 width 只读属性和 height 只读属性反映了窗口的宽高，其 resize 事件在窗口尺寸改变时触发并返回一个 PictureInPictureEvent 事件 权限策略该 API 调用受到 picture-in-picture 权限策略的控制，可以通过 Permissions-Policy 响应头指定，或通过 &lt;iframe&gt; 标签的 allow 属性指定 默认值是 *，即允许任意源的浏览上下文使用该 API 类型1234567891011121314151617181920212223242526interface Document { readonly pictureInPictureElement: Element | null readonly pictureInPictureEnabled: boolean exitPictureInPicture(): Promise&lt;void&gt;}interface ShadowRoot { readonly pictureInPictureElement: Element | null}interface HTMLVideoElement { disablePictureInPicture: boolean requestPictureInPicture(): Promise&lt;PictureInPictureWindow&gt; onenterpictureinpicture: ((this: HTMLVideoElement, ev: PictureInPictureEvent) =&gt; any) | null onleavepictureinpicture: ((this: HTMLVideoElement, ev: PictureInPictureEvent) =&gt; any) | null}interface PictureInPictureEvent extends Event { readonly pictureInPictureWindow: PictureInPictureWindow}interface PictureInPictureWindow extends EventTarget { readonly width: number readonly height: number onresize: ((this: PictureInPictureWindow, ev: PictureInPictureEvent) =&gt; any) | null} 链接 https://developer.mozilla.org/en-US/docs/Web/API/Picture-in-Picture_API https://w3c.github.io/picture-in-picture/","link":"/2023/10/25/Picture-in-Picture-API/"},{"title":"Permissions API","text":"Permissions API 提供了编程式地检测当前浏览上下文 API 权限 可以用于确定对应的 API 是否已授予权限或被拒绝授予权限，或等待授权权限 同时 API 还会考虑其他因素，如若该 API 对 Secure Context 的要求、Permissions-Policy 的限制等待 该 API 通过 Permissions 接口提供相关功能，并通过 Navigator.permissions 和 WorkerNavigator.permissions 对外暴露 Permissions 实例 检测权限调用 Permissions 接口的 query() 方法检测给定 API 的权限状态 方法传入一个 permissionDescriptor 的配置项，其唯一参数 name 反映与给定 API 相关的名称 方法返回一个 Promise 的 PermissionStatus，代表与给定 API 相关的权限状态 12345const status = await navigator.permissions.query({ name: 'geolocation',})console.log(status.state) // 'granted' 'denied' 'prompt' PermissionStatus 的 state 属性返回一个 string，代表权限的状态，为 'granted' 'denied' 'prompt' 之一 PermissionStatus 的 name 属性返回一个 string，代表权限的名称，与 query() 方法传入的 name 参数一致 PermissionStatus 的 change 事件在权限的状态改变时触发，返回一个 Event 权限名称 Background Synchronization API - background-sync (should always be granted) Clipboard API - clipboard-read, clipboard-write Geolocation API - geolocation Local Font Access API Media Capture and Streams API - microphone, camera Notifications API - notifications Payment Handler API - payment-handler Push API - push Sensor APIs - accelerometer, gyroscope, magnetometer, ambient-light-sensor Storage Access API - storage-access Storage API - persistent-storage Web Audio Output Devices API - speaker-selection Web MIDI API - midi Window Management API - window-management 不同浏览器支持的权限名称亦不同 Firefox 参见 https://searchfox.org/mozilla-central/source/dom/webidl/Permissions.webidl#10 Chromium 参见 https://chromium.googlesource.com/chromium/src/+/refs/heads/main/third_party/blink/renderer/modules/permissions/permission_descriptor.idl#6 Webkit 参见 https://github.com/WebKit/WebKit/blob/main/Source/WebCore/Modules/permissions/PermissionName.idl#L28 类型12345678910111213141516171819202122232425262728interface Navigator { readonly permissions: Permissions}partial interface WorkerNavigator { readonly permissions: Permissions}interface Permissions { query(permissionDesc: PermissionDescriptor): Promise&lt;PermissionStatus&gt;}interface PermissionDescriptor { name: string}interface PermissionStatus extends EventTarget { readonly state: PermissionState readonly name: string onchange: ((this: PermissionStatus, ev: Event) =&gt; any) | null}enum PermissionState { &quot;granted&quot;, &quot;denied&quot;, &quot;prompt&quot;,} 链接 https://developer.mozilla.org/en-US/docs/Web/API/Permissions_API https://w3c.github.io/permissions/","link":"/2023/11/05/Permissions-API/"},{"title":"Pointer Lock API","text":"Pointer Lock API 允许控制鼠标的输入形式，将鼠标的移动从光标位置移动转换为自定义的形式（同时隐藏光标） 指针锁定与鼠标捕获比较类似，但其是持久的，即不会自动释放鼠标；并且其不受浏览器边界的限制；最大特点是，其会隐藏光标 该 API 要求必须在产生用户交互后使用，否则会执行失败 启用指针锁定通过调用对应 Element 接口上的 requestPointerLock() 方法以启用指针锁定 方法默认无参数，但多数浏览器支持传入一组配置项，唯一参数 unadjustedMovement 指定是否启用操作系统级别的鼠标位置适配 方法默认无返回值，但多数浏览器实现为返回 Promise 1el.requestPointerLock() 停止指针锁定通过调用 Document 接口上的 exitPointerLock() 方法以停止指针锁定 1document.exitPointerLock() 指针锁定信息Document 接口或 ShadowRoot 接口的 pointerLockElement 属性返回当前启用指针锁定的元素，若不存在则返回 null Document 接口的 pointerlockchange 事件在指针锁定状态改变时触发，返回一个 Event 事件 Document 接口的 pointerlockerror 事件在指针锁定状态改变失败时触发，返回一个 Event 事件’ MouseEvent 接口的 movementX 属性与 movementY 属性仅在 mousemove 事件中可用，反映了前后两个 mousemove 事件的鼠标移动的坐标 沙箱策略该 API 在 &lt;iframe&gt; 标签中的调用受到 allow-pointer-lock 沙箱策略的控制，需要将 sandbox 的属性指定为允许 类型123456789101112131415161718interface Document { exitPointerLock(): void onpointerlockchange: ((this: Document, ev: Event) =&gt; any) | null onpointerlockerror: ((this: Document, ev: Event) =&gt; any) | null}interface DocumentOrShadowRoot { readonly pointerLockElement: Element | null}interface Element { requestPointerLock(): void}interface MouseEvent { readonly movementX: number readonly movementY: number} 链接 https://developer.mozilla.org/en-US/docs/Web/API/Pointer_Lock_API https://w3c.github.io/pointerlock/","link":"/2023/10/24/Pointer-Lock-API/"},{"title":"Prioritized Task Scheduling API","text":"Prioritized Task Scheduling API 提供了标准化的任务的优先级排序的方式 通过该 API 能够设定和改变任务优先级，延迟将任务添加至调度程序，终止任务或监听任务优先级改变事件 该 API 定义的任务优先级分类是比较粗糙的，开发者可以根据需要自定义更加细化的任务优先级分类 该 API 通过 scheduler 全局属性暴露 Scheduler 实例使用 创建任务调用 Scheduler 接口的 postTask() 方法以创建任务 方法传入一个回调函数，代表该任务的内容 方法亦传入一个可选的配置项： 其 priority 选项指定任务的优先级，接收一个字符串，值为 user-blocking user-visible background，默认值为 user-visible 其 signal 选项提供任务的控制器，可以为一个 TaskSignal 或 AbortSignal，用于终止任务或调整任务优先级 其 delay 选项指定任务添加至任务队列的延迟时间，默认为 0 方法的返回值是一个 Promise，其具体值取决于回调函数的返回值或抛出的异常 123456789scheduler.postTask(() =&gt; 'a task', { priority: 'user-visible',}) .then((result) =&gt; { console.log('execute success with:', result) }) .catch((error) =&gt; { console.error('execute fail with:', error) }) 任务优先级 user-blocking 优先级最高，表明该任务可能阻止用户与网页交互 user-visible 优先级一般，表面该任务会让用户察觉但不致阻止用户与网页交互 background 优先级最低，表面该用户不会对用户产生影响 任务的执行顺序优先按任务优先级执行，其次按照定义顺序执行 延迟任务在任务创建时向 delay 选项传入一个正整数 123scheduler.postTask(() =&gt; 'a task', { delay: 1000,}) 终止任务在任务创建时向 signal 选项传入一个 TaskSignal 或 AbortSignal 参数 在必要时候调用 AbortController 或 TaskController 的 abort() 方法以终止任务 1234567const controllor = new AbortController()scheduler.postTask(() =&gt; 'a task', { signal: controllor.signal,})controllor.abort() 更改任务优先级在任务创建时向 signal 选项传入一个 TaskSignal 参数 在必要时候调用 TaskController 的 setPriority() 方法以重新设置任务的优先级 1234567const controller = new TaskController()scheduler.postTask(() =&gt; 'a task', { signal: controllor.signal,})controller.setPriority(&quot;background&quot;) 调用 TaskController() 构造函数创建一个 TaskController 实例 构造函数接收一个可选的配置项，其参数 priority 指定初始的任务优先级，默认值为 &quot;user-visible&quot; TaskController 接口的 signal 属性返回一个 TaskSignal 实例，反映与当前 TaskController 相对的 TaskSignal 实例 使用 TaskController 接口的 setPriority() 方法更改当前任务的优先级 方法接收一个字符串，代表任务新的优先级 此外，TaskSignal 实例的 priority 只读属性反映 signal 对应的任务的优先级 TaskSignal 实例的 prioritychange 事件在 signal 对应的任务的优先级改变时触发，返回一个 TaskPriorityChangeEvent 事件，其 previousPriority 参数指定改变前的任务的优先级 1234controller.signal.addEventListener(&quot;prioritychange&quot;, (e) =&gt; { console.log('previous', e.previousPriority) console.log('current', controller.signal.priority /* 或 e.target.priority */)}) 输入检测Scheduling 接口提供了管理计划任务的方法，通过 navigator.scheduling 属性暴露 Scheduling 接口的 isInputPending() 方法判断当前事件队列中是否有输入事件，该方法可以用于判断用户是否在与网页交互 方法接收一个可选的配置项，其参数 includeContinuous 代表是否需考虑持续性触发的事件 方法返回一个 boolean 123const flag = navigator.scheduling.isInputPending({ includeContinuous: false,}) 类型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455type TaskPriority = &quot;user-blocking&quot; | &quot;user-visible&quot; | &quot;background&quot;interface SchedulerPostTaskOptions { signal?: AbortSignal priority?: TaskPriority delay?: number}type SchedulerPostTaskCallback = Functioninterface Scheduler { postTask(callback: SchedulerPostTaskCallback, options?: SchedulerPostTaskOptions): Promise&lt;any&gt;}interface TaskPriorityChangeEvent extends Event { constructor(type: string, priorityChangeEventInitDict: TaskPriorityChangeEventInit) readonly previousPriority: TaskPriority}interface TaskPriorityChangeEventInit extends EventInit { previousPriority: TaskPriority}interface TaskControllerInit { priority: TaskPriority}interface TaskController extends AbortController { constructor(init: TaskControllerInit) setPriority(priority: TaskPriority): void}interface TaskSignal extends AbortSignal { readonly priority: TaskPriority onprioritychange: ((this: TaskSignal, ev: TaskPriorityChangeEvent) =&gt; any) | null}interface WindowOrWorkerGlobalScope { readonly scheduler: Scheduler}interface Navigator { readonly scheduling: Scheduling}interface Scheduling { isInputPending(isInputPendingOptions?: IsInputPendingOptions): boolean}interface IsInputPendingOptions { includeContinuous: boolean} 链接 https://developer.mozilla.org/en-US/docs/Web/API/Prioritized_Task_Scheduling_API https://wicg.github.io/scheduling-apis/ https://wicg.github.io/is-input-pending/","link":"/2023/11/08/Prioritized-Task-Scheduling-API/"},{"title":"Push API","text":"Push API 让网络应用从用户代理接收来自服务器发送的消息，无论网络应用是否运行或者在线 网页或者浏览器不在线的时候，推送消息无法被推送到客户端浏览器，此时推送消息就会被 FCM 服务器保存起来，等到网页或者浏览器上线的时候，FCM 服务器才会推送消息到网页或者浏览器 生成服务器公秘钥对可以使用 web-push 库来生成服务器公秘钥对。 12345const webpush = require('web-push');const vapidKeys = webpush.generateVAPIDKeys();const { publicKey, privateKey } = vapidKeys 其中私钥放在服务器保存，公钥用于注册推送订阅。 创建消息推送服务可以利用 ServiceWorkerRegistration 接口的 pushManager 属性获取到当前 ServiceWorker 对应的 PushManager 接口实例。 PushManager 接口的 subscribe() 方法用于订阅一个消息推送服务。 其接收一组可选的配置项，userVisibleOnly 可选参数指定返回的推送是否只用于创建对用户可见的通知（不指定 true 会在一些浏览器中报错），applicationServerKey 可选参数指定服务的公钥（某些浏览器中是必须的参数）。 返回一个 Promise 的 PushSubscription 接口实例，代表当前推送消息。 在当前 ServiceWorker 没有创建消息推送服务时，新的消息推送会被创建。 123456789window.navigator.serviceWorker.ready.then((registration) =&gt; { // 订阅消息推送 registration.pushManager.subscribe({ userVisibleOnly: true, applicationServerKey: '', }).then((subscription) =&gt; { console.log(subscription) })}) 123456self.registration.pushManager.subscribe({ userVisibleOnly: true, applicationServerKey: '',}).then((subscription) =&gt; { console.log(subscription)}) 获取推送消息服务PushManager 接口的 getSubscription() 方法用于获取已经订阅的消息推送服务。 返回一个 Promise 的 PushSubscription 接口实例，代表当前已订阅的消息推送服务，否则返回一个 Promise 的 null。 12345678window.navigator.serviceWorker.ready.then((registration) =&gt; { // 获取已订阅的消息推送 registration.pushManager.getSubscription().then((subscription) =&gt; { if (subscription != null) { console.log(subscription) } })}) 12345self.registration.pushManager.getSubscription().then((subscription) =&gt; { if (subscription != null) { console.log(subscription) }}) PushSubscription 接口代表了订阅的消息推送。 endpoint 属性代表与消息推送联系的 endpoint。 expirationTime 属性代表订阅的消息推送的到期时间。 options 属性代表创建消息推送时的选项。 getKey() 方法返回一个 ArrayBuffer，代表客户端公钥的密钥，可以将其发送到服务器用于加密推送消息数据。支持传入一个代表用于生成客户端密钥的加密方法的参数，可以是 p256dh 或 auth。 toJSON() 方法标准化地转换消息推送的信息，目前仅包含 endpoint 参数。 unsubscribe() 方法取消消息推送的订阅，返回一个 Promise 的布尔值，代表是否成功取消了消息订阅。 发送推送消息可以使用 web-push 在服务端来发送推送消息。 123456789101112131415161718192021222324252627282930313233343536373839import express from 'express'import webpush from 'web-push'const vapidKeys = { &quot;publicKey&quot;: &quot;BHXrxJPYpQSwGMwcN-HprCaU_Po9POIUvqWFLFq9UUNHP5SNJKxk_Io59y8_twMTOuB5SbpbcPBwHFo2kBUj7vQ&quot;, // 之前生成的 publicKey &quot;privateKey&quot;: &quot;Yhd4XF08Efh8HNF_8RDJ9VL6pF-Gos-3KOmgyMEUSf8&quot; // 之前生成的 privateKey}// 在 google cloud platform 中创建的项目 IDwebpush.setGCMAPIKey('&lt;Your GCM API Key Here&gt;')// 服务器运营者的联系邮箱webpush.setVapidDetails( 'mailto:example@yourdomain.org', vapidKeys.publicKey, vapidKeys.privateKey)const app = express()app.get('/push', (req, res) =&gt; { // 这里的 pushSubscription 就是上面注册成功后返回的 subscription 对象 const pushSubscription = { &quot;endpoint&quot;: &quot;https://fcm.googleapis.com/fcm/send/cSAH1Q7Fa6s:APA91bEgYeKNXMSO1rcGAOPzt3L9fMhyjL-zSPV5JfiKwgqtbx_Q4de_8plEY_QViLnhfe6-0fUgdo7Z3Gqpml3zIBSfO6IISDYdF9kzL2h_dbZ_FE_YKbKOG70gMG_A74xwK1vsocCv&quot;, // 推送订阅网址 &quot;keys&quot;: { &quot;p256dh&quot;: &quot;BAqZaMLZn_rtYeR7WsBLqBWG7uMiOGRyCx2uhOqm0ZaJwDdQac-ubAyRRdLXJVZDOrNe-B3mCTy3g0vHCkeyYyo&quot;, // 用户公钥 &quot;auth&quot;: &quot;fxDt8RtB92KHpQM7HetBUw&quot; // 用户身份验证秘密 } } webpush.sendNotification(pushSubscription, 'Hello world') .then(result =&gt; { res.send(result); })})app.listen(1701, () =&gt; { console.log('Server start success at http://localhost:1701');}) 若使用 firebase 架构可使用 firebase 来实现消息推送。 监听消息推送ServiceWorkerGlobalScope 接口的 push 事件在每次收到一条推送消息时触发。 返回一个 PushEvent 事件。 12345self.addEventListener('push', (e) =&gt; { console.log(e) self.registration.showNotification(e.data?.json().title ?? 'New Notification')}) PushEvent 接口继承自 ExtendableEvent 接口。 其 data 属性代表该推送消息的内容，是一个 PushMessageData 实例。 PushMessageData 接口包括多种处理推送的消息的方法，类似于 fetch API 中的方法，但允许被调用多次。其 arrayBuffer() 方法、blob() 方法、json() 方法、text() 方法分别将结果转换成 ArrayBuffer、Blob、JSON 解析结果、字符串。推送的消息能够自动被加解密，无需做额外的处理。 消息推送权限PushManager 接口的 permissionState() 方法用于获取当前的请求消息推送权限。 参数同 subscribe 方法的参数。 返回一个 Promise 的 'prompt'、'denied'、'granted' 的字符串枚举。 12345678910111213self.registration.pushManager.permissionState({ userVisibleOnly: true, applicationServerKey: '',}).then((state) =&gt; { switch(state) { case &quot;denied&quot;: break case &quot;granted&quot;: break case &quot;prompt&quot;: break }}) 其他PushManager 接口的 supportedContentEncodings 静态属性返回一组消息推送支持的加密方式。 ServiceWorkerGlobalScope 接口的 pushsubscriptionchange 事件在更新订阅的消息推送时触发（可能原因包括消息推送服务刷新、消息推送服务失效等）。 权限 API该 API 调用需要用户授予 push 权限，可以调用 Permission.query() 方法或 PushManager.permissionState() 检查用户是否已授予了该权限 示例 https://github.com/skyclouds2001/Frontend-Learning/blob/main/next-learning/push.html https://github.com/skyclouds2001/Frontend-Learning/blob/main/next-learning/push.js 类型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152type PushEncryptionKeyName = &quot;auth&quot; | &quot;p256dh&quot;;interface PushSubscriptionJSON { endpoint?: string; expirationTime?: EpochTimeStamp | null; keys?: Record&lt;string, string&gt;;}interface PushSubscriptionOptionsInit { applicationServerKey?: BufferSource | string | null; userVisibleOnly?: boolean;}interface PushEvent extends ExtendableEvent { readonly data: PushMessageData | null;}interface PushManager { getSubscription(): Promise&lt;PushSubscription | null&gt;; permissionState(options?: PushSubscriptionOptionsInit): Promise&lt;PermissionState&gt;; subscribe(options?: PushSubscriptionOptionsInit): Promise&lt;PushSubscription&gt;;}interface PushMessageData { arrayBuffer(): ArrayBuffer; blob(): Blob; json(): any; text(): string;}interface PushSubscription { readonly endpoint: string; readonly expirationTime: EpochTimeStamp | null; readonly options: PushSubscriptionOptions; getKey(name: PushEncryptionKeyName): ArrayBuffer | null; toJSON(): PushSubscriptionJSON; unsubscribe(): Promise&lt;boolean&gt;;}interface PushSubscriptionOptions { readonly applicationServerKey: ArrayBuffer | null; readonly userVisibleOnly: boolean;}interface ServiceWorkerRegistration extends EventTarget { readonly pushManager: PushManager;}interface ServiceWorkerGlobalScope extends WorkerGlobalScope { onpush: ((this: ServiceWorkerGlobalScope, ev: PushEvent) =&gt; any) | null; onpushsubscriptionchange: ((this: ServiceWorkerGlobalScope, ev: Event) =&gt; any) | null;} 链接 https://developer.mozilla.org/en-US/docs/Web/API/Push_API https://w3c.github.io/push-api/","link":"/2023/09/10/Push-API/"},{"title":"Pyodide","text":"Pyodide 是一个在浏览器环境中运行的 Python 解释器，利用了 CPython 技术和 WebAssembly 技术，从而可以在浏览器中运行 Python 软件包；并且 Pyodide 保证了 Python 与 JavaScript 的兼容，允许 Python 使用浏览器的 API 基本使用使用 CDN 形式向项目中引入 Pyodide 软件包 1&lt;script defer src=&quot;https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js&quot;&gt;&lt;/script&gt; 然后调用已注入到全局的 loadPyodide() 方法获取到 Pyodide 实例 1const pyodide = await loadPyodide() 调用 Pyodide 实例的 runPython() 方法以执行 Python 代码 该方法传入的字符串，代表需要执行的 Python 代码 该方法的返回值，执行 Python 代码的输出 1pyodide.runPython(`print('Hello world!')`) 调用 print() 方法的效果相当于调用 console.log() 方法 123456pyodide.runPython('1 + 2')pyodide.runPython('2 ** 10')pyodide.runPython(`import syssys.version`) 同样可以在 Pyodide 中使用内置软件包，也可以导入外部软件包 Pyodide 实例的 runPythonAsync() 方法用于异步执行 Python 代码 1await pyodide.runPythonAsync('1 * 1') JS 获取 Python 作用域Python 全局作用域通过 pyodide.globals 对象暴露 调用其 get() 方法以获取 Python 全局作用域的变量 1234567pyodide.runPython('x = 1')pyodide.runPython(`y = 'xes'`)pyodide.runPython('z = [2, 4]')pyodide.globals.get('x')pyodide.globals.get('y')pyodide.globals.get('z').toJs() Python 中复杂类型变量，如列表等，可以通过调用 toJs() 来转换为一个 JS 对象 调用其 set() 方法以设置 Python 全局作用域的变量 1234567pyodide.globals.set('xx', 'xxxxx')pyodide.globals.set('alert', alert)pyodide.globals.set('square', x =&gt; x ** 2)pyodide.runPython('print(xx)')pyodide.runPython(`alert('xxxx')`)pyodide.runPython('print(square(20))') 可以设置普通变量、对象、函数，以及 JS 或 DOM 内置函数等等 Python 获取 JS 作用域在 Python 中导入 JS 包以使用 JS 的全局变量 123import jsjs.confirm('message') 使用类似与调用 window 变量 Worker 环境使用使用 importScripts() 方法导入 CDN 脚本，随后通过暴露在全局的 loadPyodide() 方法使用 1self.importScripts(&quot;https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js&quot;) 特别的，若在 ServiceWorker 中使用，需要导入 XMLHttpRequest 的 shim 包，因为该类在 ServiceWorker 中无法使用但 Pyodide 依赖于该包，如 12importScripts(&quot;./node_modules/xhr-shim/src/index.js&quot;)self.XMLHttpRequest = self.XMLHttpRequestShim 模块 Worker 环境下需要改变导入方式为 ESM 1234import &quot;./node_modules/xhr-shim/src/index.js&quot;self.XMLHttpRequest = self.XMLHttpRequestShimimport &quot;./pyodide.asm.js&quot;import { loadPyodide } from &quot;./pyodide.mjs&quot; 文件系统Pyodide 基于 Emscripten File System API 实现了自定义的文件系统 在 Python 环境中直接调用相关文件操作方法；通过 pyodide.FS 对象向浏览器环境暴露对文件系统的操作 1234567with open(&quot;/hello.txt&quot;, &quot;r&quot;) as fh: data = fh.read()print(data)with open(&quot;/hello.txt&quot;, &quot;r&quot;) as fh: data = fh.read()print(data) 123const file = pyodide.FS.readFile(&quot;/hello.txt&quot;, { encoding: &quot;utf8&quot; })pyodide.FS.writeFile(&quot;/hello.txt&quot;, data, { encoding: &quot;utf8&quot; }) 需要注意的是，Pyodide 默认使用的是 MEMFS，可以通过调用其 mount 方法绑定至其他的文件系统 1pyodide.FS.mount(pyodide.FS.filesystems.NODEFS, { root: &quot;.&quot; }, &quot;/mnt&quot;) 或者可以使用原生 File System API 绑定至 Origin Private File System 或 Native File System 12345const root = await navigator.storage.getDirectory()const nativefs = await pyodide.mountNativeFS(&quot;/mnt&quot;, root)await nativefs.syncfs()","link":"/2023/11/01/Pyodide/"},{"title":"Screen Orientation API","text":"Screen Orientation API 允许获取屏幕朝向信息和监听屏幕朝向信息变化 该 API 通过 ScreenOrientation 接口提供服务，并通过 window.screen.orientation 暴露该接口的实例 获取屏幕朝向信息ScreenOrientation 接口的 type 只读属性返回一个字符串，表示当前屏幕朝向的类型，值为 portrait-primary portrait-secondary landscape-primary landscape-secondary 之一 ScreenOrientation 接口的 angel 只读属性返回一个数字，表示当前屏幕朝向的角度 监听屏幕朝向信息变化ScreenOrientation 接口的 change 事件在当前屏幕朝向变化时触发，返回一个 Event 锁定屏幕朝向信息变化ScreenOrientation 接口的 lock() 方法锁定系统默认的屏幕朝向变化 方法传入一个字符串参数，代表锁定的类型，值可以为 any landscape landscape-primary landscape-secondary natural portrait portrait-primary portrait-secondary 之一 方法返回一个 Promise 1await window.screen.orientation.lock('any') ScreenOrientation 接口的 unlock() 方法解除锁定系统默认的屏幕朝向变化 1window.screen.orientation.unlock() 沙箱策略该 API 在 &lt;iframe&gt; 标签中的调用受到 allow-orientation-lock 沙箱策略的控制，需要将 sandbox 的属性指定为允许 类型123456789101112131415interface Screen { readonly orientation: ScreenOrientation}interface ScreenOrientation extends EventTarget { readonly angle: number readonly type: OrientationType onchange: ((this: ScreenOrientation, ev: Event) =&gt; any) | null lock(orientation: OrientationLockType): Promise&lt;void&gt; unlock(): void}type OrientationLockType = &quot;any&quot; | &quot;landscape&quot; | &quot;landscape-primary&quot; | &quot;landscape-secondary&quot; | &quot;natural&quot; | &quot;portrait&quot; | &quot;portrait-primary&quot; | &quot;portrait-secondary&quot;type OrientationType = &quot;landscape-primary&quot; | &quot;landscape-secondary&quot; | &quot;portrait-primary&quot; | &quot;portrait-secondary&quot; 链接 https://developer.mozilla.org/en-US/docs/Web/API/Screen_Orientation_API https://w3c.github.io/screen-orientation/","link":"/2023/11/07/Screen-Orientation-API/"},{"title":"Screen Wake Lock API","text":"Screen Wake Lock API 允许控制设备的屏幕变暗、休眠或锁定的策略 通过 navigator.wakeLock 暴露的 WakeLock 接口实例使用 启用屏幕管理策略通过 WakeLock 接口的 request() 方法来请求启用屏幕管理策略 方法传入一个可选的 type 字符串参数，唯一允许值为 'screen' 方法返回一个 Promise 的 WakeLockSentinel 实例 方法可能抛出一个 NotAllowedError 异常，例如被 Permissions Policy 拒绝、当前网页未处于活跃状态、当前网页处于隐藏状态或用户代理无法获取到系统的屏幕管理策略 1const sentinel = await navigator.wakeLock.request() 释放屏幕管理策略通过 WakeLockSentinel 接口的 release() 方法来手动关闭屏幕管理策略 方法返回一个 Promise 1sentinel.release() 同时，操作系统可能会在网页失去焦点或隐藏时自动关闭屏幕管理策略 屏幕管理策略信息WakeLockSentinel 接口的 released 属性返回一个 boolean，表示当前 WakeLockSentinel 是否已被释放 WakeLockSentinel 接口的 type 属性返回一个 string，表示当前 WakeLockSentinel 的类型 WakeLockSentinel 接口的 release 事件，在 WakeLockSentinel 被释放时触发，返回一个 Event 事件 权限策略该 API 调用受到 screen-wake-lock 权限策略的控制，可以通过 Permissions-Policy 响应头指定，或通过 &lt;iframe&gt; 标签的 allow 属性指定 默认为 self，即允许在当前上下文或内嵌的其他同源上下文中使用 类型123456789101112interface WakeLock { request(type?: WakeLockType): Promise&lt;WakeLockSentinel&gt;}interface WakeLockSentinel extends EventTarget { onrelease: ((this: WakeLockSentinel, ev: Event) =&gt; any) | null readonly released: boolean readonly type: WakeLockType release(): Promise&lt;void&gt;}type WakeLockType = 'screen' 链接 https://developer.mozilla.org/en-US/docs/Web/API/Screen_Wake_Lock_API https://w3c.github.io/screen-wake-lock/","link":"/2023/10/24/Screen-Wake-Lock-API/"},{"title":"ServiceWorker I","text":"ServiceWorker 概念ServiceWorker 本质上充当位于 Web 应用程序、浏览器和网络（如果可用）之间的代理服务器，可以用于创建有效的离线体验、拦截网络请求并根据网络是否可用采取适当的操作，以及更新服务器上的资产，此外还可以用于实现推送通知和后台同步等功能。 ServiceWorker 是针对源和路径注册的事件驱动 Worker。它采用 JavaScript 文件的形式，可以控制与之关联的网页/站点，拦截和修改导航和资源请求，并以非常精细的方式缓存资源，从而可以以完全控制应用程序的行为（最明显的一种是网络不可用时的回退方案）。 ServiceWorker 在 Worker 上下文中运行：因此它没有 DOM 访问权限，并且在与为应用程序提供支持的主 JavaScript 不同的线程上运行，因此它是非阻塞的。并且，它被设计为完全异步；因此，同步 XMLHttpRequest 和 Web Storage 等 API 无法在 ServiceWorker 内部使用。 ServiceWorker 无法动态导入 JavaScript 模块，如果在 ServiceWorker 全局范围内调用 import() 进行动态导入，则会抛出异常，仅允许使用 import 语句进行静态导入。同时创建时需指定 ServiceWorker 为模块 Worker。 出于安全原因，ServiceWorker 只能在安全上下文中运行（可以通过全局变量 isSecureContext 来判断是否处于安全上下文）。 ServiceWorker 生命周期ServiceWorker 生命周期依次是安装、激活和运行： 成功注册后，ServiceWorker 将会在空闲时终止，以节省内存和处理器电量。活动的 ServiceWorker 会自动重新启动以响应事件。 安装阶段，在 ServiceWorker 脚本下载成功之后，浏览器开始安装 ServiceWorker（在 ServiceWorkerGlobalScope 上触发 install 事件，返回一个 ExtendableEvent 事件） 激活阶段，在安装完成之后，浏览器开始激活 ServiceWorker 的阶段（在 ServiceWorkerGlobalScope 上触发 activate 事件，返回一个 ExtendableEvent 事件） 运行阶段，在激活完成之后，ServiceWorker开始运行的阶段 ExtendableEvent 事件的 waitUntil 方法，可以用于表示事件调度程序工作正在进行中并延迟生命周期的完成直至传递的 Promise 被解决。 在 install 事件中，waitUntil 方法用于初始化 ServiceWorker，用于将 ServiceWorker 保持在安装阶段，直到任务完成；若 Promise 被拒绝，则安装被视为失败，并且正在安装的 ServiceWorker 将被丢弃。 在 activate 事件中，waitUntil 方法用来缓冲功能事件，从而可以更新数据库架构并删除过时的缓存，保证正式运行时使用的是最新的架构。 ServiceWorker 基本使用浏览器端 通过访问window.navigator.serviceWorker 属性获取 ServiceWorkerContainer 接口实例，包含各种管理 ServiceWorker 的方法，如注册、取消注册、更新以及读取状态。 注册ServiceWorker 的注册通过调用 ServiceWorkerContainer 接口的 register() 方法实现。 方法接收一个参数，代表 ServiceWorker 脚本的 URL。 方法亦可接收一个配置项参数： 可选的 scope 参数定义 ServiceWorker 的注册范围，值默认设置为 ServiceWorker 脚本所在的目录。 可选的 type 参数指定要创建的 ServiceWorker 的类型，值可以是 'classic' 或 'module'。'classic' 代表 Worker 内部使用标准脚本模式；'module' 代表 Worker 内部使用模块脚本模式。 可选的 updateViaCache 参数指示在更新期间如何将 HTTP 缓存用于 ServiceWorker 脚本资源，值可以是 'all' 或 'imports' 或 'none'。'all' 代表 ServiceWorker 脚本资源和其导入的脚本资源均使用 HTTP 缓存，'imports' 代表仅 ServiceWorker 脚本资源不使用 HTTP 缓存，其导入的脚本资源使用 HTTP 缓存，'none' 代表 ServiceWorker 脚本资源和其导入的脚本资源均不使用 HTTP 缓存。 返回一个 ServiceWorkerRegistration 接口实例，代表注册的 ServiceWorker 对象。 12345678window.navigator.serviceWorker.register( './service-worker.js', { scope: '/', type: 'module', updateViaCache: 'all', }) 关于 scope 参数的举例 页面 / 与 ServiceWorker 脚本路径 /sw.js 允许控制 / 以下的页面 页面 /product 与 ServiceWorker 脚本路径 /product/sw.js 与 scope ./ 允许控制 /product 以下的页面 页面 / 与 ServiceWorker 脚本路径 /sw.js 与 scope /product/允许控制 /product 以下的页面 更新ServiceWorker 的更新通过调用与 ServiceWorker 对应的 ServiceWorkerRegistration 接口的 update() 方法实现。 返回一个 Promise 的 ServiceWorkerRegistration。 12345navigator.serviceWorker.ready.then((registration) =&gt; { registration.addEventListener('updatefound', () =&gt; { registration.update() })}) 卸载ServiceWorker 的卸载通过调用对应的 ServiceWorkerRegistration 接口实例的 unregister() 方法实现。 返回一个 Promise 的布尔值，表示是否卸载成功。 12345navigator.serviceWorker.ready.then((registration) =&gt; { window.addEventListener('beforeunload', () =&gt; { registration.unregister() })}) ServiceWorker 补充当用户首次访问 ServiceWorker 控制的站点/页面时，ServiceWorker 会立即下载。 之后，它会在导航到范围内的页面或在 ServiceWorker 上触发了一个事件且未在过去 24 小时内下载的情况下更新。 当发现下载的文件是新的时，就会尝试安装 - 要么与现有的 ServiceWorker 不同（按字节比较），要么与此页面/站点遇到的第一个 ServiceWorker 不同。 如果这是首次使 ServiceWorker 可用，则会尝试安装，然后在成功安装后将其激活。 但如果存在可用的现有 ServiceWorker，则新版本会在后台安装，但尚未激活 - 此时它称为等待中的 Worker。仅当不再加载任何仍在使用旧 ServiceWorker 的页面时，它才会被激活。一旦没有更多页面需要加载，新的 ServiceWorker 就会激活（成为活动 ServiceWorker）。不过可以手动提前终止当前 ServiceWorker 并启用新的 ServiceWorker。 示例 https://github.com/skyclouds2001/Frontend-Learning/blob/main/next-learning/service-worker.html https://github.com/skyclouds2001/Frontend-Learning/blob/main/next-learning/service-worker.js 链接 https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API https://w3c.github.io/ServiceWorker/","link":"/2023/08/26/ServiceWorker-I/"},{"title":"ServiceWorker II","text":"ServiceWorker 全局上下文ServiceWorkerGlobalScope 接口代表 ServiceWorker 的全局上下文，在 ServiceWorker 内通过 self 全局变量或者 globalThis 全局变量访问（该接口继承自 WorkerGlobalScope）。 ServiceWorkerGlobalScope以下代表在 ServiceWorkerGlobalScope 接口本身的属性、方法和事件： ServiceWorkerGlobalScope 接口的 clients 属性代表一个 Clients 实例，可用于获取 Client （可执行上下文）实例。 ServiceWorkerGlobalScope 接口的 registration 属性代表一个 ServiceWorkerRegistration 实例，即当前 ServiceWorker 注册的引用。 ServiceWorkerGlobalScope 接口的 serviceWorker 属性代表一个 ServiceWorker 实例，即当前 ServiceWorker 实例的引用。 ServiceWorkerGlobalScope 接口的 skipWaiting 方法强制当前 ServiceWorker 从等待状态变成激活状态，返回一个该 ServiceWorker 激活后完成的 Promise。其在 install 事件的回调中调用才具有实际意义。 WorkerGlobalScope以下代表继承自 WorkerGlobalScope 接口的属性、方法和事件： WorkerGlobalScope 接口的 location 属性代表一个 WorkerLocation 实例，是 Location 的字集。 WorkerGlobalScope 接口的 navigator 属性代表一个 WorkerNavigator 实例，是 Navigator 的字集。 WorkerGlobalScope 接口的 self 属性代表 WorkerGlobalScope 接口本身。 WorkerGlobalScope 接口的 importScripts 方法同步导入一组脚本文件并执行，接受一组参数，代表脚本文件的 URL，其可以为绝对路径或相对路径（相对文档路径）。 WorkerGlobalScope 接口的 error 事件在 ServiceWorker 内发生脚本错误时触发，返回一个 Event 实例。 WorkerGlobalScope 接口的 languagechange 事件在用户的首选语言更改时触发，返回一个 Event 实例。 WorkerGlobalScope 接口的 online 事件在浏览器获得网络访问权限并且 navigator.onLine 值切换到 true 时触发，返回一个 Event 实例。 WorkerGlobalScope 接口的 offline 事件在浏览器获得网络访问权限并且 navigator.onLine 值切换到 false 时触发，返回一个 Event 实例。 WorkerGlobalScope 接口的 rejectionhandled 事件在 ServiceWorker 内处理的 Promise 拒绝事件时触发，返回一个 Event 实例。 WorkerGlobalScope 接口的 unhandledrejection 事件在 ServiceWorker 内未处理的 Promise 拒绝事件时触发，返回一个 Event 实例。 以下代表暴露在全局的属性、方法和事件： 12345678self.fontsself.cachesself.crossOriginIsolatedself.cryptoself.indexedDBself.isSecureContextself.originself.performance 1234567891011self.atob()self.btoa()self.clearInterval()self.clearTimeout()self.createImageBitmap()self.fetch()self.queueMicrotask()self.reportError()self.setInterval()self.setTimeout()self.structuredClone() 示例 https://github.com/skyclouds2001/Frontend-Learning/blob/main/next-learning/service-worker.html https://github.com/skyclouds2001/Frontend-Learning/blob/main/next-learning/service-worker.js 类型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051interface ServiceWorkerGlobalScope extends WorkerGlobalScope { readonly clients: Clients; readonly registration: ServiceWorkerRegistration; readonly serviceWorker: ServiceWorker; onactivate: ((this: ServiceWorkerGlobalScope, ev: ExtendableEvent) =&gt; any) | null; onfetch: ((this: ServiceWorkerGlobalScope, ev: FetchEvent) =&gt; any) | null; oninstall: ((this: ServiceWorkerGlobalScope, ev: ExtendableEvent) =&gt; any) | null; onmessage: ((this: ServiceWorkerGlobalScope, ev: ExtendableMessageEvent) =&gt; any) | null; onmessageerror: ((this: ServiceWorkerGlobalScope, ev: MessageEvent) =&gt; any) | null; onnotificationclick: ((this: ServiceWorkerGlobalScope, ev: NotificationEvent) =&gt; any) | null; onnotificationclose: ((this: ServiceWorkerGlobalScope, ev: NotificationEvent) =&gt; any) | null; onpush: ((this: ServiceWorkerGlobalScope, ev: PushEvent) =&gt; any) | null; onpushsubscriptionchange: ((this: ServiceWorkerGlobalScope, ev: Event) =&gt; any) | null; skipWaiting(): Promise&lt;void&gt;;}interface WorkerGlobalScope extends EventTarget, FontFaceSource, WindowOrWorkerGlobalScope { readonly location: WorkerLocation; readonly navigator: WorkerNavigator; readonly self: WorkerGlobalScope &amp; typeof globalThis; onerror: ((this: WorkerGlobalScope, ev: ErrorEvent) =&gt; any) | null; onlanguagechange: ((this: WorkerGlobalScope, ev: Event) =&gt; any) | null; onoffline: ((this: WorkerGlobalScope, ev: Event) =&gt; any) | null; ononline: ((this: WorkerGlobalScope, ev: Event) =&gt; any) | null; onrejectionhandled: ((this: WorkerGlobalScope, ev: PromiseRejectionEvent) =&gt; any) | null; onunhandledrejection: ((this: WorkerGlobalScope, ev: PromiseRejectionEvent) =&gt; any) | null; importScripts(...urls: (string | URL)[]): void;}interface WindowOrWorkerGlobalScope { readonly caches: CacheStorage; readonly crossOriginIsolated: boolean; readonly crypto: Crypto; readonly fonts: FontFaceSet; readonly indexedDB: IDBFactory; readonly isSecureContext: boolean; readonly origin: string; readonly performance: Performance; atob(data: string): string; btoa(data: string): string; clearInterval(id: number | undefined): void; clearTimeout(id: number | undefined): void; createImageBitmap(image: ImageBitmapSource, options?: ImageBitmapOptions): Promise&lt;ImageBitmap&gt;; createImageBitmap(image: ImageBitmapSource, sx: number, sy: number, sw: number, sh: number, options?: ImageBitmapOptions): Promise&lt;ImageBitmap&gt;; fetch(input: RequestInfo | URL, init?: RequestInit): Promise&lt;Response&gt;; queueMicrotask(callback: VoidFunction): void; reportError(e: any): void; setInterval(handler: TimerHandler, timeout?: number, ...arguments: any[]): number; setTimeout(handler: TimerHandler, timeout?: number, ...arguments: any[]): number; structuredClone&lt;T = any&gt;(value: T, options?: StructuredSerializeOptions): T;} 链接 https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API https://w3c.github.io/ServiceWorker/","link":"/2023/09/20/ServiceWorker-II/"},{"title":"ServiceWorker III","text":"ServiceWorker 中 Client 与 Worker在 Worker 中获取 Client在 ServiceWorker 中，会对应着多个 Client 实例，代表着受 ServiceWorker 控制的上下文，可以是网页、Worker 乃至 SharedWorker 等，而 Client 实例的访问与控制通过 Clients 实例实现，通过 clients 属性获取 同时，在 ServiceWorker 中，通过 registration 属性暴露 ServiceWorkerRegistration 实例，即当前 ServiceWorker 注册；通过 serviceWorker 属性暴露 ServiceWorker 实例，即当前 ServiceWorker 实例 Clients在 ServiceWorker 中，Clients 接口提供对 Client 接口的访问 Clients 接口的 get() 方法根据给定的 id 获取对应的 Client 实例 接收一个字符串，代表 Client 的 id 返回一个 Promise 的 Client（或 undefined） Clients 接口的 matchAll() 方法获取所有匹配的 Client 实例 接收一组可选的配置项 配置项的 type 参数指定需匹配的 Client 类型，允许的值为 &quot;window&quot;, &quot;worker&quot;, &quot;sharedworker&quot; 和 &quot;all&quot;，默认为 &quot;window&quot; 配置项的 includeUncontrolled 参数指定是否返回未受控制的 Client，默认为 false 返回一个 Promise 的 Client 数组 Clients 接口的 claim() 方法将所有匹配的 Client 实例置于当前 ServiceWorker 的控制之下 返回一个 Promise Clients 接口的 openWindow() 方法创建新的顶层上下文并加载给定的 URL 要求该 URL 需与 ServiceWorker 同源，并且要求调用前一段时间用户需发生交互行为 Firefox 中要求该方法必须在通知点击回调方法中调用 返回一个 Promise 的 WindowClient 实例或 null Client在 ServiceWorker 中，Client 接口表示受 ServiceWorker 控制的执行上下文 其中 WindowClient 接口继承自 Client 接口，表示受 ServiceWorker 控制的 Window 执行上下文 受 ServiceWorker 控制的各执行上下文可以是 Worker、Shared Worker 以及 Window Client 接口的 id 属性返回一个字符串，代表对应的执行上下文的 ID Client 接口的 type 属性返回一个字符串枚举，可能为 &quot;window&quot;、&quot;worker&quot;、&quot;sharedworker&quot; 之一，代表对应的执行上下文的类型 Client 接口的 url 属性返回一个字符串，代表对应的执行上下文的 URL Client 接口的 frameType 属性返回一个字符串枚举，可能为 &quot;auxiliary&quot;、&quot;top-level&quot;、&quot;nested&quot;、&quot;none&quot; 之一，代表对应的执行上下文的类型 WindowClient 接口的 focused 属性返回一个布尔值，代表对应的 Window 执行上下文是否处于聚焦状态 WindowClient 接口的 visibilityState 属性返回一个字符串枚举，可能的值为 &quot;hidden&quot;、&quot;visible&quot;、&quot;prerender&quot;，代表对应的 Window 执行上下文的可见性类型 WindowClient 接口的 focus() 方法控制对应的执行上下文聚焦 返回一个 Promise 的 WindowClient 实例 WindowClient 接口的 navigate() 方法控制对应的执行上下文加载指定 URL 方法接收一个字符串或 URL 实例，代表 URL 若 ServiceWorker 执行上下文与 URL 同源，返回 Promise 的 WindowClient；否则返回 Promise 的 null 在 Client 中获取 Worker在 Client 端中，通过 ready 属性暴露控制当前页面的 ServiceWorkerRegistration 实例，通过 controller 属性暴露控制当前页面的 ServiceWorker 实例 ServiceWorkerContainer在 ServiceWorker 中，ServiceWorkerContainer 接口包含 ServiceWorker 的相关状态与相关控制方法，用于实现对 ServiceWorker 的管理 ServiceWorkerContainer 接口的 ready 属性返回一个 Promise 的 ServiceWorkerRegistration，表示控制当前页面的 ServiceWorker 的注册；该属性与 ServiceWorkerGlobalScope 接口的 registration 属性类似 ServiceWorkerContainer 接口的 controller 属性返回一个 ServiceWorker 或 null，表示是否存在控制当前页面的 ServiceWorker 的实例；该属性与 ServiceWorkerGlobalScope 接口的 serviceWorker 属性类似 ServiceWorkerContainer 接口的 getRegistration() 方法根据给定的 URL （默认使用当前 Client 的 URL）返回与之匹配的 ServiceWorkerRegistration 对象 方法可以接受一个参数 方法返回一个 Promise 的 ServiceWorkerRegistration 或者 undefined，根据是否存在对应的注册对象 ServiceWorkerContainer 接口的 getRegistrations() 方法获取所有与当前 Client 相关的 ServiceWorkerRegistration 对象 返回一个 ServiceWorkerRegistration 的数组 ServiceWorkerContainer 接口的 startMessages() 方法强制当前上下文提前开始接收发送自 ServiceWorker 的消息 ServiceWorkerContainer 接口的 controllerchange 事件在控制当前 Client 的 ServiceWorker 变化时触发，返回一个 Event 事件 ServiceWorkerRegistration在 ServiceWorker 中，ServiceWorkerRegistration 接口表示 ServiceWorker 的注册对象 ServiceWorkerRegistration 接口的 active 属性返回一个 ServiceWorker 或者 null，代表最新注册的 state 属性为 activating 或 activated 的 ServiceWorker ServiceWorkerRegistration 接口的 installing 属性返回一个 ServiceWorker 或者 null，代表最新注册的 state 属性为 installing 的 ServiceWorker ServiceWorkerRegistration 接口的 waiting 属性返回一个 ServiceWorker 或者 null，代表最新注册的 state 属性为 installed 的 ServiceWorker 通常而言，active 属性、installing 属性、waiting 属性三个中最多只有一个是非 null 值。 ServiceWorkerRegistration 接口的 scope 属性返回一个字符串，代表 ServiceWorker 的注册域 ServiceWorkerRegistration 接口的 updateViaCache 属性返回一个字符串枚举，可能的值为 'all'、'imports'、'none'，指定 HTTP 缓存的脚本如何应用于 ServiceWorker 以上两个属性的值在注册 ServiceWorker 时指定 ServiceWorkerRegistration 接口的 updatefound 事件在新的 ServiceWorker 开始下载时触发，返回一个 Event 事件 ServiceWorker在 ServiceWorker 中，ServiceWorker 接口表示 ServiceWorker 对象 ServiceWorker 接口的 scriptURL 属性返回一个字符串，表示 ServiceWorker 的注册脚本 URL ServiceWorker 接口的 state 属性返回一个字符串枚举，可能的值包括 &quot;parsed&quot;、&quot;installing&quot;、&quot;installed&quot;、&quot;activating&quot;、&quot;activated&quot;、&quot;redundant&quot;，表示 ServiceWorker 的状态 &quot;parsed&quot; ServiceWorker 在下载完成并且验证可运行后的初始值 &quot;installing&quot; ServiceWorker 在安装中 &quot;installed&quot; ServiceWorker 安装完成 &quot;activating&quot; ServiceWorker 在激活中 &quot;activated&quot; ServiceWorker 激活完成 &quot;redundant&quot; ServiceWorker 被替代或安装失败 ServiceWorker 接口的 statechange 事件在 ServiceWorker 的状态更新时触发，返回一个 Event 事件 示例 https://github.com/skyclouds2001/Frontend-Learning/blob/main/next-learning/service-worker.html https://github.com/skyclouds2001/Frontend-Learning/blob/main/next-learning/service-worker.js 类型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657interface Client { readonly frameType: FrameType; readonly id: string; readonly type: ClientTypes; readonly url: string; postMessage(message: any, transfer: Transferable[]): void; postMessage(message: any, options?: StructuredSerializeOptions): void;}interface Clients { claim(): Promise&lt;void&gt;; get(id: string): Promise&lt;Client | undefined&gt;; matchAll&lt;T extends ClientQueryOptions&gt;(options?: T): Promise&lt;ReadonlyArray&lt;T[&quot;type&quot;] extends &quot;window&quot; ? WindowClient : Client&gt;&gt;; openWindow(url: string | URL): Promise&lt;WindowClient | null&gt;;}interface WindowClient extends Client { readonly focused: boolean; readonly visibilityState: DocumentVisibilityState; focus(): Promise&lt;WindowClient&gt;; navigate(url: string | URL): Promise&lt;WindowClient | null&gt;;}interface ServiceWorker extends EventTarget, AbstractWorker { readonly scriptURL: string; readonly state: ServiceWorkerState; postMessage(message: any, transfer: Transferable[]): void; postMessage(message: any, options?: StructuredSerializeOptions): void; onstatechange: ((this: ServiceWorker, ev: Event) =&gt; any) | null;}interface ServiceWorkerContainer extends EventTarget { readonly controller: ServiceWorker | null; readonly ready: Promise&lt;ServiceWorkerRegistration&gt;; getRegistration(clientURL?: string | URL): Promise&lt;ServiceWorkerRegistration | undefined&gt;; getRegistrations(): Promise&lt;ReadonlyArray&lt;ServiceWorkerRegistration&gt;&gt;; register(scriptURL: string | URL, options?: RegistrationOptions): Promise&lt;ServiceWorkerRegistration&gt;; startMessages(): void; oncontrollerchange: ((this: ServiceWorkerContainer, ev: Event) =&gt; any) | null; onmessage: ((this: ServiceWorkerContainer, ev: MessageEvent) =&gt; any) | null; onmessageerror: ((this: ServiceWorkerContainer, ev: MessageEvent) =&gt; any) | null;}interface ServiceWorkerRegistration extends EventTarget { readonly active: ServiceWorker | null; readonly installing: ServiceWorker | null; readonly navigationPreload: NavigationPreloadManager; readonly pushManager: PushManager; readonly scope: string; readonly updateViaCache: ServiceWorkerUpdateViaCache; readonly waiting: ServiceWorker | null; getNotifications(filter?: GetNotificationOptions): Promise&lt;Notification[]&gt;; showNotification(title: string, options?: NotificationOptions): Promise&lt;void&gt;; unregister(): Promise&lt;boolean&gt;; update(): Promise&lt;void&gt;; onupdatefound: ((this: ServiceWorkerRegistration, ev: Event) =&gt; any) | null;} 链接 https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API https://w3c.github.io/ServiceWorker/","link":"/2023/09/16/ServiceWorker-III/"},{"title":"ServiceWorker IV","text":"Service Worker 消息传递Client 向 Worker 发送消息 Client 端发送消息 通过调用 ServiceWorker 实例上的 postMessage() 方法实现从 Client 端向对应的 ServiceWorker 发送消息。 123456789101112131415window.navigator.serviceWorker.controller?.postMessage('message from client')window.navigator.serviceWorker.ready.then((registration) =&gt; { registration.active?.postMessage('message from client')})window.navigator.serviceWorker.getRegistration().then((registration) =&gt; { registration?.active?.postMessage('message from client')})window.navigator.serviceWorker.getRegistrations().then((registrations) =&gt; { registrations.forEach((registration) =&gt; { registration?.active?.postMessage('message from client') })}) Worker 端接收消息 通过监听 ServiceWorkerGlobalScope 环境的 message 事件接收消息。 1234567self.addEventListener('message', (e) =&gt; { console.log('message', e)})self.addEventListener('messageerror', (e) =&gt; { console.log('messageerror', e)}) Worker 向 Client 发送消息 Worker 端发送消息 通过调用 Client 实例上的 postMessage() 方法实现从 ServiceWorker 向对应的 Client 发送消息。 123456789self.clients.get('&lt;id&gt;').then((client) =&gt; { client.postMessage('message from client')})self.clients.matchAll().then((clients) =&gt; { clients.forEach((client) =&gt; { client.postMessage('message from client') })}) Client 端接收消息 通过监听 ServiceWorkerContainer 的 message 事件接收消息。 1234567window.navigator.serviceWorker.addEventListener('message', (e) =&gt; { console.log('message', e)})window.navigator.serviceWorker.addEventListener('messageerror', (e) =&gt; { console.log('messageerror', e)}) Service Worker 请求代理当主应用程序线程发出网络请求时，会在 Service Worker 的全局范围内触发 fetch 事件。 ServiceWorkerGlobalScope 接口的 fetch 事件返回一个 FetchEvent 事件（继承自 ExtendableEvent），在主应用程序线程发生网络请求时触发。 请求类型包括来自主线程的显式调用，还包括浏览器在页面导航后发出的加载页面和子资源（例如 JavaScript、CSS 和图像等）的隐式网络请求，甚至包括来自浏览器安装的插件产生的网络请求。可以通过 request 属性获取到请求的信息，调用 respondWith() 方法返回自定义的响应数据。 12345678910111213self.addEventListener('fetch', (e) =&gt; { if (e.request.url.includes('/success')) { e.respondWith(Response.json({ data: 'data', })) } if (e.request.url.includes('/error')) { e.respondWith(Response.error()) } if (e.request.url.includes('/redirect')) { e.respondWith(Response.redirect('/override/success')) }}) FetchEvent 事件的 request 属性返回一个 Request 实例，代表触发事件处理程序的请求对象。 FetchEvent 事件的 respondWith() 方法阻止浏览器的默认请求处理机制，并允许使用自定义的响应替代，其接收一个 Response 实例或者 Promise 的 Response 实例。 respondWith() 方法对于给定的请求只能调用该方法一次。如果 fetch 添加了多个事件监听器，它们将按照注册的顺序被调用，直到其中一个事件监听器调用该方法。 respondWith() 方法必须同步调用，不能在异步方法中调用该方法。 若 respondWith() 未在处理程序中调用，则用户代理会自动发出原始网络请求。 FetchEvent 事件的 clientId 属性返回触发 fetch 事件的 Client 的 id，可以使用 Clients.get() 方法获取到对应的 Client 实例。 FetchEvent 事件的 replacesClientId 属性返回若因页面导航而触发 fetch 事件的前一个 Client 的 id，否则返回一个空字符串。 FetchEvent 事件的 resultingClientId 属性返回若因页面导航而触发 fetch 事件的后一个 Client 的 id，否则返回一个空字符串。 FetchEvent 事件的 handled 属性返回 Promise 实例，表明 fetch 事件已被处理，并在消费请求后完成。 FetchEvent 事件的 preloadResponse 属性返回若导航预加载情况下的 Promise 的 Response，否则返回 Promise 的 undefined。 示例 https://github.com/skyclouds2001/Frontend-Learning/blob/main/next-learning/message.html https://github.com/skyclouds2001/Frontend-Learning/blob/main/next-learning/message.js 链接 https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API https://w3c.github.io/ServiceWorker/","link":"/2023/08/31/ServiceWorker-IV/"},{"title":"ServiceWorker V","text":"ServiceWorker 的缓存策略是基于 CacheStorage 实现的。 CacheStorageCacheStorage 提供了可由 ServiceWorker 或其他类型的 Worker 或 window 范围访问的所有命名缓存的主目录，同时负责维护字符串名称到相应 Cache 实例的映射。 可以通过 self.caches 访问全局的 CacheStorage 实例。 CacheStorage 接口的 open() 方法根据指定的 cacheName 获取对应的 Cache 实例，返回一个 Promise&lt;Cache&gt;，表示对应的 Cache 实例。若对应的 Cache 实例不存在，则会创建新的 Cache 实例。 123456const STORE_NAME = 'key'self.caches.open(STORE_NAME).then((cache) =&gt; { // 返回一个 Cache 实例 console.log('worker | cache', cache)}) CacheStorage 接口的 has() 方法根据指定的 cacheName 检测是否存在对应的 Cache 实例，返回一个 Promise&lt;boolean&gt;，表示是否存在对应的 Cache 实例。 123456const STORE_NAME = 'key'self.caches.has(STORE_NAME).then((has) =&gt; { // 返回一个 boolean console.log('worker | has cache', has)}) CacheStorage 接口的 delete() 方法根据指定的 cacheName 移除对应的 Cache 实例，返回一个 Promise&lt;boolean&gt;，表示是否存在对应的 Cache 实例并且已完成删除操作。 123456const STORE_NAME = 'key'self.caches.delete(STORE_NAME).then((deleted) =&gt; { // 返回一个 boolean console.log('worker | has deleted cache', deleted)}) CacheStorage 接口的 keys() 方法获取所有 Cache 实例的索引的列表，返回一个 Promise&lt;string[]&gt;。 1234self.caches.keys().then((keys) =&gt; { // 返回一个 string[] console.log('worker | all caches keys', keys)}) CacheStorage 接口的 match() 方法根据给定的 Request 实例或 URL 实例或 URL 字符串确定存储中是否存在对应的 Response，若存在则返回一个 Promise&lt;Response&gt; ，反之则返回一个 Promise&lt;undefined&gt;。该方法支持传入一组配置项，cacheName 参数指定搜索目标 Cache 实例的索引，ignoreSearch 参数指定是否考虑 URL 中的查询字符串，ignoreMethod 参数指定是否匹配请求方法，ignoreVary 指定是否匹配 Vary 头。 12345678910111213141516171819self.caches.match( '/cache', { ignoreSearch: false, ignoreMethod: false, ignoreVary: false, }).then((data) =&gt; { // 返回一个 Response | undefined if (data) { console.log('worker | have resource', data) } else { console.log('worker | not have resource', data) }})self.caches.match(new URL('/cache'))self.caches.match(new Request('/cache')) Cache Cache 接口的 put() 方法将键/值对存储到当前 Cache 实例中，键可以是一个代表 URL 的字符串、一个 URL 实例或一个 Request 实例，值是一个 Response 实例。该方法会覆盖与之匹配的键/值对。 12345self.caches.open('key').then((cache) =&gt; { cache.put('/cache', new Response('cache')) cache.put(new URL('/cache'), new Response('cache')) cache.put(new Request('/cache'), new Response('cache'))}) Cache 接口的 add() 方法根据给定的 URL 获取响应并存储到当前 Cache 实例中，参数可以是一个代表 URL 的字符串、一个 URL 实例或一个 Request 实例。该方法会覆盖与之匹配的键/值对。 Cache 接口的 addAll() 方法根据给定的 URL 列表获取响应并存储到当前 Cache 实例中，列表项可以是一个代表 URL 的字符串或一个 Request 实例。该方法会覆盖与之匹配的键/值对。 1234567self.caches.open('key').then((cache) =&gt; { cache.add('/cache') cache.add(new URL('/cache')) cache.add(new Request('/cache')) cache.addAll(['/cache', new Request('/cache')])}) 该方法可以视为 put() 方法的简化用法。 add() 方法和 addAll() 方法会忽略非 200 状态码的响应，若仍需要存储响应，应当采用 put() 方法。 put() 方法、add() 方法和 addAll() 方法的 URL 参数必须是 HTTP 或 HTTPS，否则会抛出 TypeError 错误。 Cache 接口的 match() 方法根据给定的 URL 在当前 Cache 实例中检索首个关联的响应，参数可以是一个代表 URL 的字符串、一个 URL 实例或一个 Request 实例，此外还支持传入一组可选的配置项，若存在则返回一个 Promise&lt;Response&gt; ，反之则返回一个 Promise&lt;undefined&gt;。 Cache 接口的 matchAll() 方法根据给定的 URL 在当前 Cache 实例中检索所有关联的响应，参数可以是一个代表 URL 的字符串、一个 URL 实例或一个 Request 实例，此外还支持传入一组可选的配置项，返回一个 Promise&lt;Response[]&gt;。 12345678910111213141516171819202122232425262728293031323334self.caches.open('key').then((cache) =&gt; { cache.match( '/cache', { ignoreSearch: false, ignoreMethod: false, ignoreVary: false, }).then((response) =&gt; { console.log('worker | cache match', response) }) cache.match(new URL('/cache')).then((response) =&gt; { console.log('worker | cache match', response) }) cache.match(new Request('/cache')).then((response) =&gt; { console.log('worker | cache match', response) }) cache.matchAll( '/cache', { ignoreSearch: false, ignoreMethod: false, ignoreVary: false, } ).then((responses) =&gt; { console.log('worker | caches match', responses) }) cache.matchAll(new URL('/cache')).then((responses) =&gt; { console.log('worker | caches match', responses) }) cache.matchAll(new Request('/cache')).then((responses) =&gt; { console.log('worker | caches match', responses) })}) Cache 接口的 delete() 方法从当前 Cache 实例中移除对应的响应。参数可以是一个代表 URL 的字符串、一个 URL 实例或一个 Request 实例，此外还支持传入一组可选的配置项。返回一个 Promise&lt;boolean&gt;，表示是否存在对应的响应并且已完成删除操作。 1234567891011self.caches.open('key').then((cache) =&gt; { cache.delete('/cache').then((success) =&gt; { console.log('worker | cache delete', success) }) cache.delete(new URL('/cache')).then((success) =&gt; { console.log('worker | cache delete', success) }) cache.delete(new Request('/cache')).then((success) =&gt; { console.log('worker | cache delete', success) })}) Cache 接口的 keys() 方法获取当前 Cache 实例的响应索引的列表，参数可以是一个代表 URL 的字符串、一个 URL 实例或一个 Request 实例，同时支持传入一组配置项，返回一个 Promise&lt;string[]&gt;。 12345self.caches.open('key').then((cache) =&gt; { cache.keys().then((keys) =&gt; { console.log('worker | all keys in cache', keys) })}) keys() 方法的返回值按照插入的顺序返回。 缓存机制ServiceWorker 的缓存策略是基于 ServiceWorker 环境全局 fetch 事件的，可以在 fetch 事件中监听请求，然后对请求进行拦截，最后返回自定义的响应 拦截请求并从缓存检索响应，若响应存在则直接返回缓存的响应，反之则发起请求获取响应，缓存获取到的响应再返回响应。 12345678910111213141516171819202122232425self.addEventListener('fetch', (e) =&gt; { e.respondWith( self.caches .match(e.request, { cacheName: 'v2', }) .then((response) =&gt; { if (response != null) { return response } else { return fetch(e.request.clone()) .then((response) =&gt; { const res = response.clone() self.caches.open('v2').then((cache) =&gt; { cache.put(e.request, res) }) return response }) .catch(() =&gt; caches.match('/404')) } }) )}) 在 install 阶段预先获取资源并进行缓存。 1234567891011121314self.addEventListener('install', (e) =&gt; { e.waitUntil( self.caches .open('v2') .then((cache) =&gt; cache.addAll([ '/', '/index.html', '/style.css', '/main.js', ]) ) )}) 在 activate 阶段移除失效的 Cache 实例或失效的资源。 123456789101112131415self.addEventListener('activate', (e) =&gt; { const CACHES_NEED_MOVE = ['v1'] e.waitUntil( self.caches.keys().then((keys) =&gt; Promise.all( keys.map((key) =&gt; { if (CACHES_NEED_MOVE.includes(key)) { return self.caches.delete(key) } }) ) ) )}) 示例 https://github.com/skyclouds2001/Frontend-Learning/blob/main/next-learning/cache-storage.html https://github.com/skyclouds2001/Frontend-Learning/blob/main/next-learning/cache-storage.js https://github.com/skyclouds2001/Frontend-Learning/blob/main/next-learning/fetch-cache.html https://github.com/skyclouds2001/Frontend-Learning/blob/main/next-learning/fetch-cache.js 类型1234567891011121314151617181920212223interface Cache { add(request: RequestInfo | URL): Promise&lt;void&gt;; addAll(requests: RequestInfo[]): Promise&lt;void&gt;; delete(request: RequestInfo | URL, options?: CacheQueryOptions): Promise&lt;boolean&gt;; keys(request?: RequestInfo | URL, options?: CacheQueryOptions): Promise&lt;ReadonlyArray&lt;Request&gt;&gt;; match(request: RequestInfo | URL, options?: CacheQueryOptions): Promise&lt;Response | undefined&gt;; matchAll(request?: RequestInfo | URL, options?: CacheQueryOptions): Promise&lt;ReadonlyArray&lt;Response&gt;&gt;; put(request: RequestInfo | URL, response: Response): Promise&lt;void&gt;;}interface CacheStorage { delete(cacheName: string): Promise&lt;boolean&gt;; has(cacheName: string): Promise&lt;boolean&gt;; keys(): Promise&lt;string[]&gt;; match(request: RequestInfo | URL, options?: MultiCacheQueryOptions): Promise&lt;Response | undefined&gt;; open(cacheName: string): Promise&lt;Cache&gt;;}interface WindowOrWorkerGlobalScope { readonly caches: CacheStorage;}declare var caches: CacheStorage; 链接 https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API https://w3c.github.io/ServiceWorker/","link":"/2023/08/31/ServiceWorker-V/"},{"title":"SharedWorker","text":"SharedWorker 是 HTML 标准定义的 Web API 的一部分，是一种特殊的 Worker，支持在多个上下文（例如 window、iframe 甚至 Worker）之间共享 同时，SharedWorker 的全局上下文 SharedWorkerGlobalScope 也与 Worker 不同 创建 SharedWorker和 Worker 一样，通过调用 SharedWorker() 构造函数来创建 1const worker = new SharedWorker('./worker.js') SharedWorker() 构造函数支持传入一组可选的配置项，与 Worker() 构造函数相同SharedWorker() 构造函数也支持直接传入一个字符串，同配置项的 name 参数；特别的，SharedWorker() 中的 name 参数作为唯一的一个标识符，在创建新的与之前的拥有相同 URL 的 SharedWorker 时有一定作用 SharedWorker 通过脚本文件 URL 和 name 参数确定是否为同一个 SharedWorker SharedWorker 消息传递与 Worker 不同，Client 端通过创建的 SharedWorker 实例上的 port 属性暴露的 MessagePort 接口实例，调用其上的 postMessage() 方法实现发送消息 Client 端通过监听 SharedWorker 实例上的 message 事件实现接收到消息 123456789worker.port.start()worker.port.postMessage('message from client')worker.port.close()worker.port.addEventListener('message', (e) =&gt; { console.log('receive message in client: ', e.data)}) SharedWorker 环境下接收消息，需要监听 connect 事件，从而获取到新的对应的 MessagePort 实例；监听 MessagePort 实例的 message 事件接收消息 SharedWorker 环境下接收消息，同样需要通过调用 MessagePort 实例的 postMessage() 方法实现发送消息 12345678910111213self.addEventListener('connect', (e) =&gt; { const port = e.ports.at(0) port.addEventListener('message', (e) =&gt; { console.log('receive message in worker: ', e.data) }) port.start() port.postMessage('message from worker') port.close()}) 通常，在 connect 事件回调函数内，会把接收到的 port 存储下来，以便之后使用 1234567891011121314151617const ports = []self.addEventListener('connect', (e) =&gt; { const port = e.ports.at(0) port.addEventListener('message', handleReceiveMessage) port.start() ports.push(port)})function sendMessage() { for (const port of ports) { port.postMessage('message from worker') }} 卸载 SharedWorker仅支持在 SharedWorker 环境内调用 close() 方法，来卸载当前 Worker 1self.close() SharedWorker 生命周期SharedWorker 生命周期与 Client 端的生命周期独立，当任一页面创建 SharedWorker 时其生命周期开始，在没有页面使用 SharedWorker 时其生命周期结束 SharedWorker 全局环境SharedWorker 全局环境通过 SharedWorkerGlobalScope 表示，该接口继承自 WorkerGlobalScope，它与 Worker 全局环境差别不大 示例 https://github.com/skyclouds2001/Frontend-Learning/blob/main/next-learning/shared-worker.html https://github.com/skyclouds2001/Frontend-Learning/blob/main/next-learning/shared-worker.js 类型123456789101112131415161718interface SharedWorker extends EventTarget, AbstractWorker { constructor(scriptURL: string | URL, options?: string | WorkerOptions); readonly port: MessagePort;}interface SharedWorkerGlobalScope extends WorkerGlobalScope { readonly name: string; close(): void; onconnect: ((this: SharedWorkerGlobalScope, ev: MessageEvent) =&gt; any) | null;}interface WorkerOptions { credentials?: RequestCredentials name?: string type?: WorkerType}type WorkerType = 'classic' | 'module' 链接 https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API https://html.spec.whatwg.org/multipage/workers.html","link":"/2023/09/22/SharedWorker/"},{"title":"ServiceWorker VI","text":"ServiceWorker 导航预加载导航预加载通过 NavigationPreloadManager 接口提供，并通过 ServiceWorkerRegistration.navigationPreload 属性暴露 对于使用 ServiceWorker 的页面，网页的网络请求会向 ServiceWorker 发送 fetch 事件直至返回响应，若此时 ServiceWorker 未启动，网页的网络请求会等待 ServiceWorker 激活后再进行处理；导航预加载允许网页的获取资源请求在 ServiceWorker 激活前提前开始下载，以避免阻碍页面的显示 启用导航预加载NavigationPreloadManager 接口的 enable() 方法用于启用资源预加载管理 停用导航预加载NavigationPreloadManager 接口的 disable() 方法用于停用资源预加载管理 管理导航预加载NavigationPreloadManager 接口的 setHeaderValue() 方法用于设置导航预加载中发送的请求的请求头 Service-Worker-Navigation-Preload 的值 NavigationPreloadManager 接口的 getState() 方法用于获取导航预加载的状态 基本使用启用导航预加载 12345self.addEventListener('activate', (e) =&gt; { e.waitUntil( self.registration.navigationPreload.enable() )}) 12345678910111213141516171819self.addEventListener('fetch', (e) =&gt; { e.responseWith( (async () =&gt; { const cache = await self.caches.match(e.request) if (cache != null) { return cache } const preload = await e.preloadResponse if (preload != null) { return preload } return fetch(e.request) }) )}) 链接 https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API https://w3c.github.io/ServiceWorker/","link":"/2023/09/28/ServiceWorker-VI/"},{"title":"Storage API","text":"Storage API 提供了多个存储 API 的共享的管理方法，允许获取存储的信息并控制存储的清除策略 通常管理的存储包括包括 IndexedDB 、 Cache Storage 、 ServiceWorker 脚本 、 Origin Private File System 该 API 通过 StorageManager 接口提供相关方法，并通过 navigator.storage 对开发者暴露 获取存储信息StorageManager 接口的 estimate() 方法用于获取用户代理存储的信息 方法返回一个 Promise 的对象，其 usage 属性返回一个数字，代表当前网页使用的存储的大小；quota 属性返回一个数字，代表当前用户代理能为网页提供的存储的大小 1234const storage = await navigator.storage.estimate()console.log('usage', storage.usage)console.log('quota', storage.quota) 设置存储清除策略默认存储策略为 &quot;best-effort&quot;，即用户代理会尽可能地保存存储数据，但若需要清除时不会告知用户 而存储策略 &quot;persistent&quot;，即用户代理会尽可能地保存存储数据，优先清除存储策略设置为 &quot;best-effort&quot; 的存储，但若需要清除时会主动告知用户 StorageManager 接口的 persisted() 方法检测是否已将存储策略更改为 &quot;persistent&quot;，返回一个 Promise 的 boolean StorageManager 接口的 persist() 方法用于将存储策略更改为 &quot;persistent&quot;，返回一个 Promise 的 boolean 1234567const result = await navigator.storage.persist()if (result) { console.log('persisted')} else { console.log('not persisted')} 权限 API该 API 调用需要用户 persistent-storage 授予权限，可以调用 Permission.query() 方法检查用户是否已授予了该权限 类型12345678910111213141516171819interface NavigatorStorage { readonly storage: StorageManager}interface Navigator extends NavigatorStorage {}interface WorkerNavigator extends NavigatorStorage {}interface StorageManager { persisted(): Promise&lt;boolean&gt; persist(): Promise&lt;boolean&gt; estimate(): Promise&lt;StorageEstimate&gt;}interface StorageEstimate { usage: number quota: number} 链接 https://developer.mozilla.org/en-US/docs/Web/API/Storage_API https://storage.spec.whatwg.org/","link":"/2023/11/06/Storage-API/"},{"title":"Storage Access API","text":"Storage Access API 允许第三方上下文中跨站内容（如嵌入 &lt;iframe&gt; 标签中）获取对未分区 cookie （即以传统方式存储的 cookie，仅允许在第一方上下文（直接加载在浏览器选项卡中）中访问）的访问权限 通常出于隐私性考虑，默认用户代理会阻止第三方上下文中跨站内容对未分区 cookie 的访问，但一些场景下，开发者期望启用第三方内容对未分区 cookie 访问的功能 请求文档访问第三方 Cookie 权限Document 接口的 requestStorageAccess() 方法用于请求文档访问第三方 Cookie 权限 方法返回一个 Promise 方法可能抛出 InvalidStateError 异常，若当前文档尚未进入 active 状态 方法可能抛出 NotAllowedError 异常，若当前文档未处于安全上下文状态，或受权限策略阻止，或当前文档或其顶层文档的 origin 为空，或受 &lt;iframe&gt; 标签沙箱策略的限制，或请求权限被拒绝（如之前已被拒绝，或当前未处于用户激活状态且未授予权限） 12345document.requestStorageAccess().then(() =&gt; { console.log('granted')}).catch(() =&gt; { console.log('denied')}) 检测文档访问第三方 Cookie 权限Document 接口的 hasStorageAccess() 方法用于检测文档访问第三方 Cookie 权限 方法返回一个 Promise 的 boolean，表示是否已允许文档访问第三方 Cookie 方法可能抛出 InvalidStateError 异常，若当前文档尚未进入 active 状态 1234567document.hasStorageAccess().then((sym) =&gt; { if (sym) { console.log('has access') } else { console.log('not has access') }}) 沙箱策略该 API 在 &lt;iframe&gt; 标签中的调用受到 allow-storage-access-by-user-activation 沙箱策略的控制，需要将 sandbox 的属性指定为允许 （同时为使用该 API，也需要指定 allow-scripts 与 allow-same-origin 沙箱策略） 权限策略该 API 调用受到 storage-access 权限策略的控制，可以通过 Permissions-Policy 响应头指定，或通过 &lt;iframe&gt; 标签的 allow 属性指定 默认值是 *，即允许任意源的浏览上下文使用该 API 权限 API该 API 调用需要用户授予 storage-access 权限，可以调用 Permission.query() 方法检查用户是否已授予了该权限 类型1234interface Document { hasStorageAccess(): Promise&lt;boolean&gt; requestStorageAccess(): Promise&lt;undefined&gt;} 链接 https://developer.mozilla.org/en-US/docs/Web/API/Storage_Access_API https://privacycg.github.io/storage-access/","link":"/2023/11/06/Storage-Access-API/"},{"title":"User-Agent Client Hints API","text":"User-Agent Client Hints API 扩展了 HTTP Client Hints 以提供允许 JavaScript API 读取浏览器和操作系统信息的方式 该 API 通过 NavigatorUAData 接口提供相关功能，并通过 navigator.userAgentData 暴露 读取基本信息NavigatorUAData 接口的 brands 属性返回一个 object array，代表浏览器信息，各项包含 brand 属性和 version 属性，均为字符串，分别代表浏览器的名称和版本 NavigatorUAData 接口的 mobile 属性返回一个 boolean，代表当前设备是否为移动端设备 NavigatorUAData 接口的 platform 属性返回一个 string，代表当前设备的操作系统名称 NavigatorUAData 接口的 toJSON() 方法返回一个 JSON 对象，表示可序列化的浏览器的信息 读取细节信息NavigatorUAData 接口的 getHighEntropyValues() 方法获取浏览器的详细信息 方法传入一个 string array 参数，值允许为 architecture bitness formFactor fullVersionList model platformVersion uaFullVersion wow64 之一 方法返回一个 Promise 的 object，根据参数不同，值可能包含 architecture bitness brands formFactor fullVersionList mobile model platform platformVersion uaFullVersion wow64 等项 方法可能抛出 NotAllowedError，若用户代理认为任一参数不应当被返回 类型123456789101112131415161718192021222324252627282930313233343536373839interface NavigatorUABrandVersion { brand: string version: string}interface UADataValues { architecture: string bitness: string brands: NavigatorUABrandVersion[] formFactor: string[] fullVersionList: NavigatorUABrandVersion[] model: string mobile: boolean platform: string platformVersion: string /** @deprecated */ uaFullVersion: string wow64: boolean}interface UALowEntropyJSON { brands: NavigatorUABrandVersion[] mobile: boolean platform: string}interface NavigatorUAData { readonly brands: ReadonlyArray&lt;&gt; readonly mobile: boolean readonly platform: string getHighEntropyValues(hints: string[]): Promise&lt;UADataValues&gt; toJSON(): UALowEntropyJSON}interface NavigatorUA { readonly userAgentData: NavigatorUAData}interface Navigator extends NavigatorUA {}interface WorkerNavigator extends NavigatorUA {} 链接 https://developer.mozilla.org/en-US/docs/Web/API/User-Agent_Client_Hints_API https://wicg.github.io/ua-client-hints/","link":"/2023/11/09/User-Agent-Client-Hints-API/"},{"title":"Vibration API","text":"Vibration API 允许调用设备的振动功能 若设备不支持振动，调用该方法不会具有任何效果 振动Navigator 接口的 vibrate() 方法负责执行振动 方法传入一个数值或一个数值数组，代表振动的模式 方法返回一个 boolean，表示是否因为方法参数的合法性导致能否进行振动 1234navigator.vibrate(200)navigator.vibrate([200])navigator.vibrate([200, 100, 200])navigator.vibrate(0) 若传入一个数值或仅有一个数值的数组，代表执行给定时间的一次振动 若传入一个数值数组，按照振动时间、暂停时间的循环执行振动 振动模式数组有一个用户代理定义的最大长度，传入超出此长度限制的数组会被截取至规定的长度 若传入参数前已有振动运行，会停止已有的振动并执行新的振动模式 若传入 0 或空数组或全 0 的数组，代表停止振动 需要注意的是，该方法要求在页面可见或存在用户交互的情况下调用，否则不具备效果 类型12345interface Navigator { vibrate(pattern: VibratePattern): boolean}type VibratePattern = number | number[] 链接 https://developer.mozilla.org/en-US/docs/Web/API/Vibration_API https://w3c.github.io/vibration/","link":"/2023/10/30/Vibration-API/"},{"title":"VirtualKeyboard API","text":"VirtualKeyboard API 允许控制设备的虚拟键盘的几何信息和展示及隐藏（特别是针对平板、智能手机等无法提供机械键盘的设备） 通过 navigator.virtualKeyboard 暴露的 VirtualKeyboard 接口实例使用 虚拟键盘展示隐藏VirtualKeyboard 接口的 show() 方法展示虚拟键盘 VirtualKeyboard 接口的 hide() 方法隐藏虚拟键盘 VirtualKeyboard 接口的 geometrychange 事件在虚拟键盘的可见性变化或浏览器窗口重定位时触发，返回一个 Event 事件，通常使用该事件来监听具体虚拟键盘的可见性的时机 1234567navigator.virtualKeyboard.show()navigator.virtualKeyboard.hide()navigator.virtualKeyboard.addEventListener('geometrychange', (e) =&gt; { //}) 需要在因为用户交互产生的行为中调用 需要当前聚焦元素的 virtualkeyboardpolicy 属性指定为 manual 或 inputmode 指定为除 none 之外的其他值 其中 show() 方法额外需要当前聚焦的元素为表单元素或者当前聚焦元素需要指定 contenteditable 属性为 true 虚拟键盘几何位置信息VirtualKeyboard 接口的 boundingRect 只读属性给出虚拟键盘的几何位置信息，返回一个 DOMRect，默认值均设置为 0 1navigator.virtualKeyboard.boundingRect 同时 CSS 环境变量 keyboard-inset-top keyboard-inset-right keyboard-inset-bottom keyboard-inset-left keyboard-inset-width keyboard-inset-height 可以通过 env() CSS 函数使用 123456env(keyboard-inset-top)env(keyboard-inset-right)env(keyboard-inset-bottom)env(keyboard-inset-left)env(keyboard-inset-width)env(keyboard-inset-height) 管理虚拟键盘几何位置VirtualKeyboard 接口的 overlaysContent 属性用于指定虚拟键盘的几何位置策略，返回一个 boolean，默认 false 1navigator.virtualKeyboard.overlaysContent 将该值设定为 true 以阻止浏览器默认的虚拟键盘调度策略，从而允许利用相关的 API 属性方法和 CSS 环境变量自定义地调整网页的布局 指定元素的虚拟键盘策略全局 virtualkeyboardpolicy 属性用于指定特定元素的虚拟键盘策略，默认为空字符串 指定为空字符串或 auto 表示使用默认的虚拟键盘策略 指定为 manual 表示阻止使用默认的虚拟键盘策略 接口123456789101112131415interface ElementContentEditable { virtualKeyboardPolicy: '' | 'auto' | 'manual'}interface VirtualKeyboard extends EventTarget { show(): void hide(): void readonly boundingRect: DOMRect overlaysContent: boolean ongeometrychange: ((this: VirtualKeyboard, ev: Event) =&gt; any) | null}interface Navigator { readonly virtualKeyboard: VirtualKeyboard} 链接 https://developer.mozilla.org/en-US/docs/Web/API/VirtualKeyboard_API https://w3c.github.io/virtual-keyboard/","link":"/2023/10/29/VirtualKeyboard-API/"},{"title":"Web Background Synchronization API","text":"消息同步 API 用于同步创建任务，直至用户获取到稳定的网络连接时才开始按序执行。 消息同步 API 可以有很多应用场景： 离线数据同步 数据备份 数据恢复 数据同步 消息同步服务通过 SyncManager 接口提供，并基于 ServiceWorkerRegistration 接口的 sync 属性向开发者暴露。 注册消息同步SyncManager 接口的 register() 方法用于注册一个消息同步事件，网络连接变为正常状态后在对应的 ServiceWorker 中触发 sync 事件。 方法接受一个字符串，代表消息同步事件的标识符，该标识符将会传递给 SyncEvent 的 tag 属性。 方法返回一个 Promise 的 undefined。 在网页中： 123456789const TAG = 'sync'window.navigator.serviceWorker.ready.then((registration) =&gt; { return registration.sync.getTags().then((tags) =&gt; { if (!tags.includes(TAG)) { return registration.sync.register(TAG) } })}) 在 ServiceWorker 中： 123const TAG = 'sync'self.registration.sync.register(TAG) 监听消息同步ServiceWorkerGlobalScope 接口上的 sync 事件在 Page 或 Worker 调用 SyncManager 接口上的方法注册一个同步事件并且自注册后起网络连接处于正常状态时触发。返回一个 SyncEvent 事件。 若当前网络连接处于非正常状态，注册同步事件后，sync 事件不会马上触发，直至网络连接变为正常状态，才会触发 sync 事件。 换言之，触发 sync 事件时，网络连接一定处于正常状态。 123456789101112131415161718const TAG = 'sync'self.addEventListener('sync', (e) =&gt; { if (e.lastChance &amp;&amp; e.tag === TAG) { e.waitUntil(sync()) }})function sync() { // sync data in the background // for example - fetch new data and re-cache new data self.fetch('/sync').then(data =&gt; { self.caches.open('v1').then(cache =&gt; { cache.add('/sync', data) }) })} 其他SyncManager 接口的 getTags() 方法用于获取用户定义的同步事件标识符，返回一个 Promise 的字符串数组。 可以利用该方法判断是否已注册相关的同步事件。 SyncEvent 事件继承自 ExtendableEvent 事件，其 tag 属性给出定义的同步事件标识符，其 lastChance 属性标识当前同步事件后是否有新的同步事件。 权限 API该 API 调用需要用户授予 background-sync 权限，可以调用 Permission.query() 方法检查用户是否已授予了该权限 示例 https://github.com/skyclouds2001/Frontend-Learning/blob/main/next-learning/sync.html https://github.com/skyclouds2001/Frontend-Learning/blob/main/next-learning/sync.js 类型1234567891011121314151617interface SyncEvent extends ExtendableEvent { readonly tag: string; readonly lastChance: boolean;}interface SyncManager { getTags(): Promise&lt;ReadonlyArray&lt;string&gt;&gt;; register(tag: string): Promise&lt;void&gt;;}interface ServiceWorkerGlobalScope extends WorkerGlobalScope { onsync: ((this: ServiceWorkerGlobalScope, ev: SyncEvent) =&gt; any) | null;}interface ServiceWorkerRegistration extends EventTarget { readonly sync: SyncManager;} 链接 https://developer.mozilla.org/en-US/docs/Web/API/Background_Synchronization_API https://wicg.github.io/background-sync/spec/","link":"/2023/09/12/Web-Background-Synchronization-API/"},{"title":"Web API","text":"Web API在编写 Web 项目时，有许多 Web API 可供调用来实现各种各样的功能 Beacon APIBeacon API 可用于异步地向服务器发送 HTTP POST 网络请求 Beacon API Cookie APICookie API 允许用于保存小数据 Cookie API Web Storage APIWeb Storage API 允许用于保存键值对形式的数据 Web Storage API Cookie Store APICookie Store API 提供了异步地管理 Cookie 的方式，同时允许在 ServiceWorker 中使用 Cookie Store API Storage APIStorage API 提供了多个存储 API 的共享的管理方法，允许获取存储的信息并控制存储的清除策略 Storage API Storage Access APIStorage Access API 允许第三方上下文中跨站内容（如嵌入 &lt;iframe&gt; 标签中）获取对未分区 cookie （即以传统方式存储的 cookie，仅允许在第一方上下文（直接加载在浏览器选项卡中）中访问）的访问权限 Storage Access API Prioritized Task Scheduling APIPrioritized Task Scheduling API 提供了标准化的任务的优先级排序的方式 Prioritized Task Scheduling API Permissions APIPermissions API 提供了编程式地检测当前浏览上下文 API 权限 Permissions API Broadcast Channel APIBroadcast Channel API 允许在同源的浏览上下文中交换数据 Broadcast Channel API Fullscreen APIFullscreen API 允许某个特定的元素管理全屏模式 Fullscreen API Picture-in-Picture APIPicture-in-Picture API 允许某个特定的视频元素管理画中画模式 Picture-in-Picture API Document Picture-in-Picture APIDocument Picture-in-Picture API 是对原有 Picture-in-Picture API 的扩展，允许任意 DOM 元素进入画中画模式 Document Picture-in-Picture API EyeDropper APIEyeDropper API 提供了 eyedropper 工具，允许用户选择屏幕上的某个特定位置的颜色 EyeDropper API Clipboard APIClipboard API 允许异步地读写剪切板 Clipboard API Web Share APIWeb Share API 允许分享文字、链接、文件或其他内容到用户指定的分享目标 Web Share API Contact Picker APIContact Picker API 允许用户从通讯录选择记录并与网页应用分享 Contact Picker API DeviceOrientation EventDeviceOrientation Event 允许监测设备的物理朝向及物理加速度 DeviceOrientation Event Pointer Lock APIPointer Lock API 允许控制鼠标的输入形式，将鼠标的移动从光标位置移动转换为自定义的形式（同时隐藏光标） Pointer Lock API Keyboard Lock APIKeyboard Lock API 允许控制键盘的输入形式，捕获键盘的输入从而进行自定义的处理（特别是针对一些特殊按键） Keyboard Lock API Keyboard Map APIKeyboard Map API 允许获取键盘按键码至键盘按键名的映射 Keyboard Map API VirtualKeyboard APIVirtualKeyboard API 允许控制设备的虚拟键盘的几何信息和展示及隐藏 VirtualKeyboard API Geolocation APIGeolocation API 允许访问设备的地理位置 Geolocation API Network Information APINetwork Information API 允许获取网络信息和监听网络信息更改 Network Information API Battery Status APIBattery Status API 允许访问设备的电池状态 Battery Status API Local Font Access APILocal Font Access API 允许访问设备本地安装的字体数据 Local Font Access API User-Agent Client Hints APIUser-Agent Client Hints API 扩展了 HTTP Client Hints 以提供允许 JavaScript API 读取浏览器和操作系统信息的方式 User-Agent Client Hints API Get Installed Related Apps APIGet Installed Related Apps API 允许网页应用检测与之相关的应用是否已在本地设备下载 Get Installed Related Apps API Screen Wake Lock APIScreen Wake Lock API 允许管理设备的屏幕变暗或休眠策略 Screen Wake Lock API Screen Orientation APIScreen Orientation API 允许获取屏幕朝向信息和监听屏幕朝向信息变化 Screen Orientation API Vibration APIVibration API 允许调用设备的振动功能 Vibration API File System APIFile System API 以及 File System Access API 允许访问设备文件系统上的文件-允许读取、写入和文件管理功能，或利用 OPFS 机制存储类文件的数据 File System API Window Management APIWindow Management API 允许获取连接到设备的显示器的详细信息，并将窗口放置在指定的屏幕上 Window Management API Web Worker APIWeb Worker API 允许在与 Web 应用程序的主执行线程分开的后台线程中运行脚本操作，避免阻碍主执行线程的进行 Worker SharedWorker Service Worker APIService Worker API 用于充当用户代理与网络之间的代理服务器，可以拦截请求与实现离线体验，同时与其他 API 结合实现良好的使用体验 ServiceWorker I ServiceWorker II ServiceWorker III ServiceWorker IV ServiceWorker V ServiceWorker VI Notifications APINotifications API 允许网页控制向用户显示系统通知 Notifications API Push APIPush API 让网络应用从用户代理接收来自服务器发送的消息，无论网络应用是否运行或者在线 Push API Background Fetch APIBackground Fetch API 允许管理后台下载大文件的方法 Background Fetch API Web Background Synchronization APIWeb Background Synchronization API 允许推迟任务的执行直至网络连接 Web Background Synchronization API Web Periodic Background Synchronization APIWeb Periodic Background Synchronization API 允许在网络连接下周期性执行任务 Web Periodic Background Synchronization API Content Index APIContent Index API 允许网站或 PWA 应用向浏览器注册其离线启用的内容 Content Index API Badging APIBadging API 允许用户代理在网站或 PWA 应用上设置徽章 Badging API Window Controls Overlay APIWindow Controls Overlay API 允许 PWA 应用能够隐藏默认窗口标题栏并在应用程序窗口区域显示自定义的内容 Window Controls Overlay API","link":"/2022/12/14/Web-API/"},{"title":"Web Periodic Background Synchronization API","text":"后台周期同步 API 提供了一种注册在网络状态允许下周期性执行任务的方法，这些任务被称为周期后台同步请求。 API 用途包括在设备连接到网络时获取最新内容，或允许对应用程序进行后台更新。 调用 API 时需设置最小时间间隔，但是用户代理通常还会考虑网络连接情况或者之前网站的用户参与程度来决定触发任务的周期。 后台获取 API 通过 PeriodicSyncManager 接口提供，并基于 ServiceWorkerRegistration 接口的 periodicSync 属性向开发者暴露。 注册周期后台同步任务PeriodicSyncManager 接口的 register() 方法用于注册周期后台同步任务。 方法接收一个字符串，作为周期后台同步任务的唯一标识符；可接收一组可选的配置项，其唯一属性为 minInterval，指定周期后台同步任务的执行周期。 返回一个 Promise。 1234567const TAG = 'tag'window.navigator.serviceWorker.ready.then((registration) =&gt; { registration.periodicSync.register(TAG, { minInterval: 24 * 60 * 60 * 1000, })}) 查看周期后台同步任务PeriodicSyncManager 接口的 getTags() 方法用于获取周期后台同步任务。 返回一个 Promise 的字符串数组，代表当前已注册的周期后台同步任务的标识符列表。 123456789const TAG = 'tag'window.navigator.serviceWorker.ready.then((registration) =&gt; { registration.periodicSync.getTags().then((tags) =&gt; { if (tags.includes(TAG)) { // do something } })}) 卸载周期后台同步任务PeriodicSyncManager 接口的 unregister() 方法用于卸载周期后台同步任务。 方法接收一个字符串，代表周期后台同步任务的唯一标识符。 返回一个 Promise。 12345const TAG = 'tag'window.navigator.serviceWorker.ready.then((registration) =&gt; { registration.periodicSync.unregister(TAG)}) 执行周期后台同步任务ServiceWorkerGlobalScope 接口的 periodicsync 事件在触发周期后台同步任务时触发。返回一个 PeriodicSyncEvent 事件。 事件触发周期大于或等于在注册时设置的最小执行周期。 1234567const TAG = 'tag'self.addEventListener('periodicsync', (e) =&gt; { if (e.tag === TAG) { // do something }}) PeriodicSyncEvent 事件继承自 ExtendableEvent 事件。其 tag 属性返回事件对应的周期后台同步任务的唯一标识符。 权限 API该 API 调用需要用户授予 periodic-background-sync 权限，可以调用 Permission.query() 方法检查用户是否已授予了该权限 示例 https://github.com/skyclouds2001/Frontend-Learning/blob/main/next-learning/periodic-sync.html https://github.com/skyclouds2001/Frontend-Learning/blob/main/next-learning/periodic-sync.js 类型123456789101112131415161718192021interface PeriodicSyncEvent extends ExtendableEvent { readonly tag: string;}interface BackgroundSyncOptions { minInterval: number;}interface PeriodicSyncManager { getTags(): Promise&lt;ReadonlyArray&lt;string&gt;&gt;; register(tag: string, options?: BackgroundSyncOptions): Promise&lt;void&gt;; unregister(tag: string): Promise&lt;void&gt;;}interface ServiceWorkerGlobalScope extends WorkerGlobalScope { onperiodicsync: ((this: ServiceWorkerGlobalScope, ev: PeriodicSyncEvent) =&gt; any) | null;}interface ServiceWorkerRegistration extends EventTarget { readonly periodicSync: PeriodicSyncManager;} 链接 https://developer.mozilla.org/en-US/docs/Web/API/Web_Periodic_Background_Synchronization_API https://wicg.github.io/periodic-background-sync/","link":"/2023/09/14/Web-Periodic-Background-Synchronization-API/"},{"title":"Web Share API","text":"Web Share API 允许分享文字、链接、文件或其他内容到用户指定的分享目标 分享操作使用 Navigator 接口上的 share() 方法分享内容 方法允许传递一组可选的分享内容，包括 title 字段；text 字段；url 字段；files 字段 方法返回一个 Promise 方法可能抛出 InvalidStateError 异常，若当前文档未处于活跃状态；或当前存在其他分享操作 方法可能抛出 NotAllowedError 异常，若当前未被授予 web-share 权限；或分享操作未因用户交互行为调用；或分享的文件因为隐私问题被拒绝 方法可能抛出 TypeError 异常，若校验分享数据失败 title text url files 四个字段均为空 仅存在 files 字段且其为空数组 用户代理实现不支持分享文件 用户代理确信任一分享的文件存在恶意行为 存在 url 字段且解析 URL 失败 存在 url 字段且其协议不是可分享的协议类型，如 http https 等；或为不可分享的协议类型，如 file、ws、wss、javascript 或本地协议等 方法可能抛出 AbortError 异常，若用户代理无法获取到可用的分享目标；或用户退出选取分享目标过程 方法可能抛出 DataError 异常，若尝试启动分享目标失败；或传递分享数据失败 检测分享使用 Navigator 接口上的 canShare() 方法检测内容能否被成功分享，传递的参数同 share() 方法，返回一个 boolean 通常在调用 share() 方法之前先行调用该方法以检测能否成功分享 若调用 share() 方法会成功，则 canShare() 方法一定返回 true；反之返回 false 权限策略该 API 调用受到 web-share 权限策略的控制，可以通过 Permissions-Policy 响应头指定，或通过 &lt;iframe&gt; 标签的 allow 属性指定 默认为 self，即允许在当前上下文或内嵌的其他同源上下文中使用 类型1234567891011interface Navigator { share(data?: ShareData): Promise&lt;undefined&gt; canShare(data?: ShareData): boolean}interface ShareData { files?: File[] title?: string text?: string url?: string} 链接 https://developer.mozilla.org/en-US/docs/Web/API/Web_Share_API https://w3c.github.io/web-share/","link":"/2023/10/30/Web-Share-API/"},{"title":"Web Storage API","text":"Web Storage API 可用于保存键值对形式的数据，包括 localStorage 和 sessionStorage 两种，键值对均要求为字符串（非字符串类型数据会隐式转换为字符串） sessionStorage 会话存储的数据仅在当前会话中有效，若关闭标签页或浏览器则会失效 localStorage 本地存储的数据长期有效 Web Storage API 同样受同源策略限制，不同源的 Storage 无法共享 Storage 的获取通过 window.sessionStorage 访问会话存储对应的 Storage 实例 通过 window.localStorage 访问本地存储对应的 Storage 实例 Storage 的操作Storage 接口提供了一些对会话存储或本地存储的操作方法 读取键值对Storage 接口的 getItem() 方法用于获取指定键名对应的键值，若数据不存在则返回 null 1window.localStorage.getItem('k') 设置键值对Storage 接口的 setItem() 方法用于设置键值对 1window.localStorage.setItem('k', 'v') 清除键值对Storage 接口的 removeItem() 方法用于移除指定键名对应的键值 1window.localStorage.removeItem('k') 清空存储Storage 接口的 clear() 方法用于清除整个存储 1window.localStorage.clear() 其他Storage 接口的 length 属性返回存储的长度 Storage 接口支持直接使用键名索引来获取或设置对应的键值，支持直接使用 delete 关键字移除对应的键值 Storage 接口的 key() 方法用于获取指定索引的值，索引的顺序是由浏览器决定的，因此该顺序是不可靠的，若数据不存在则返回 null 12345678window.localStorage.lengthwindow.localStorage.kwindow.localStorage['k']window.localStorage.k = 'v'window.localStorage['k'] = 'v'delete window.localStorage.kdelete window.localStorage['k']window.localStorage.key(0) 存储更改会话存储或本地存储的更改会在与之同域的会话中触发全局 Window 的 storage 事件，并返回一个 StorageEvent 事件 StorageEvent 事件的 storageArea 属性返回存储变化的 Storage 实例 StorageEvent 事件的 url 属性返回存储变化的文档的 URL StorageEvent 事件的 key 属性返回存储变化的键名 StorageEvent 事件的 oldValue 属性返回存储变化的原键值或 null StorageEvent 事件的 newValue 属性返回存储变化的现键值或 null 1234567window.addEventListener('storage', (e) =&gt; { console.log(e.key) console.log(e.oldValue) console.log(e.newValue) console.log(e.url) console.log(e.storageArea)}) 类型123456789101112131415161718192021222324interface Window { readonly localStorage: Storage readonly sessionStorage: Storage onstorage: ((this: WindowEventHandlers, ev: StorageEvent) =&gt; any) | null}interface Storage { readonly length: number clear(): void getItem(key: string): string | null key(index: number): string | null removeItem(key: string): void setItem(key: string, value: string): void [name: string]: any}interface StorageEvent extends Event { readonly key: string | null readonly newValue: string | null readonly oldValue: string | null readonly storageArea: Storage | null readonly url: string initStorageEvent(type: string, bubbles?: boolean, cancelable?: boolean, key?: string | null, oldValue?: string | null, newValue?: string | null, url?: string | URL, storageArea?: Storage | null): void} 链接 https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API https://html.spec.whatwg.org/multipage/webstorage.html","link":"/2023/10/21/Web-Storage-API/"},{"title":"Window Controls Overlay API","text":"Window Controls Overlay API 给 PWA 应用提供了管理默认系统的应用标题栏的能力，允许应用完全掌控应用窗口的区域，不过仅支持 PC 端 PWA 应用 该 API 通过 WindowControlsOverlay 接口提供了相关功能，并通过 navigator.windowControlsOverlay 对外暴露该接口实例 使用该 API 需要在 PWA 应用的 Manifest 文件的 display_override 选项指定 window-controls-overlay WindowControlsOverlay 的信息WindowControlsOverlay 接口的 visible 只读属性表示了应用标题栏的可见性 WindowControlsOverlay 接口的 getTitlebarAreaRect() 方法返回了应用标题栏的几何信息，方法返回一个 DOMRect 接口实例 WindowControlsOverlay 接口的 geometrychange 事件在应用标题栏的可见性和几何信息变化时触发，事件返回一个 WindowControlsOverlayGeometryChangeEvent 事件实例 1234567891011navigator.windowControlsOverlay.addEventListener('geometrychange', (e) =&gt; { const { visible, titlebarAreaRect: rect } = e if (visible) { console.log('visible') console.log('rect info', rect) } else { console.log('not visible') }}) 相关的 CSS 环境变量 titlebar-area-x 应用标题栏左上角横坐标 titlebar-area-y 应用标题栏左上角纵坐标 titlebar-area-width 应用标题栏宽度 titlebar-area-height 应用标题栏高度 可以通过 env() CSS 函数使用 CSS 环境变量 1234env(titlebar-area-x)env(titlebar-area-y)env(titlebar-area-width)env(titlebar-area-height) 示例 https://github.com/skyclouds2001/Frontend-Learning/blob/main/next-learning/PWA-eg 类型1234567891011121314interface Navigator { readonly windowControlsOverlay: WindowControlsOverlay}interface WindowControlsOverlay extends EventTarget { readonly visible: boolean getTitlebarAreaRect(): DOMRect ongeometrychange: ((this: WindowControlsOverlay, ev: WindowControlsOverlayGeometryChangeEvent) =&gt; any) | null}interface WindowControlsOverlayGeometryChangeEvent extends Event { readonly titlebarAreaRect: DOMRect readonly visible: boolean} 链接 https://developer.mozilla.org/en-US/docs/Web/API/Window_Controls_Overlay_API https://wicg.github.io/window-controls-overlay/","link":"/2023/10/03/Window-Controls-Overlay-API/"},{"title":"Window Management API","text":"Window Management API 允许获取连接到设备的显示器的详细信息，并将窗口放置在指定的屏幕上 检测是否多屏Screen 接口的 isExtended 属性指示当前用户设备是否支持多屏 被 window-management 权限策略禁止时，始终返回 false 1screen.isExtended 监测屏幕变化Screen 接口的 change 事件在屏幕的参数变化时触发，返回一个 Event 事件，针对 width height availWidth availHeight colorDepth orientation 属性 ScreenDetailed 接口的 change 事件亦支持 left top availLeft availTop devicePixelRatio label isPrimary isInternal 属性 123screen.addEventListener('change', (e) =&gt; { //}) 获取屏幕信息调用 Window 接口的 getScreenDetails() 方法获取用户端可用的所有 返回一个 Promise 的 ScreenDetails 实例 被 window-management 权限策略禁止或明确被用户拒绝授予 window-management 权限时，会抛出 NotAllowedError 异常 1const screenDetails = await window.getScreenDetails() ScreenDetails 接口反映了所有设备可用的屏幕的信息，该接口继承自 EventTarget 接口 ScreenDetails 接口的 currentScreen 属性返回一个 ScreenDetailed 实例，代表当前浏览器窗口所在的屏幕 ScreenDetails 接口的 screens 属性返回一个 ScreenDetailed 实例数组，代表当前设备可用的屏幕 12const screens = screenDetails.screensconst current = screenDetails.currentScreen ScreenDetails 接口的 currentscreenchange 事件在浏览器窗口移动至其他屏幕或当前屏幕的任意属性改变时触发，返回一个 Event 事件 ScreenDetails 接口的 screenschange 事件在当前设备可用的屏幕变化时触发，返回一个 Event 事件 123456screenDetails.addEventListener('currentscreenchange', () =&gt; { current = screenDetails.currentScreen})screenDetails.addEventListener('screenschange', () =&gt; { screens = screenDetails.screens}) ScreenDetailed 接口反映了单个设备可用的屏幕的信息，该接口继承自 Screen 接口 ScreenDetailed 接口的 availLeft 属性返回一个 number，代表可用屏幕区域的 x 坐标 ScreenDetailed 接口的 availTop 属性返回一个 number，代表可用屏幕区域的 y 坐标 ScreenDetailed 接口的 devicePixelRatio 属性返回一个 number，代表屏幕的 device pixel ratio（当前屏幕时，等价于 window.devicePixelRatio） ScreenDetailed 接口的 isInternal 属性返回一个 boolean，指示是否为设备内部的屏幕 ScreenDetailed 接口的 isPrimary 属性返回一个 boolean，指示是否为操作系统的主屏幕 ScreenDetailed 接口的 label 属性返回一个 string，代表屏幕的描述性标签 ScreenDetailed 接口的 left 属性返回一个 number，代表总屏幕区域的 x 坐标 ScreenDetailed 接口的 top 属性返回一个 number，代表总屏幕区域的 y 坐标 Screen 接口反映了屏幕的信息，可以通过 window.screen 使用 Screen 接口的 height 属性返回一个 number，代表屏幕的高度 Screen 接口的 width 属性返回一个 number，代表屏幕的宽度 Screen 接口的 availHeight 属性返回一个 number，代表屏幕可用区域的高度 Screen 接口的 availWidth 属性返回一个 number，代表屏幕可用区域的宽度 Screen 接口的 colorDepth 属性返回一个 number，代表屏幕的颜色位深度 Screen 接口的 pixelDepth 属性返回一个 number，代表屏幕的像素位深度 指定屏幕打开窗口调用 Window 接口的 open() 方法时，通过 windowFeatures 可选参数指定打开窗口的 left top width height 参数，从而实现指定屏幕打开窗口 123456const left = screenDetails.currentScreen.availLeftconst top = screenDetails.currentScreen.availTopconst width = screenDetails.currentScreen.availWidth / 2const height = screenDetails.currentScreen.availHeight / 2window.open('about:blank', '_blank', `left=${left},top=${top},width=${width},height=${height}`) 指定屏幕放置全屏Element 接口 requestFullscreen() 方法的配置项支持传入 screen 参数，指定将全屏的窗口放置至指定屏幕 123456el.requestFullscreen({ screen: screen.isExtended ? screenDetails.screens.filter(s =&gt; s !== screenDetails.currentScreen).at(0) : screenDetails.currentScreen,}) 权限策略该 API 受 window-management 权限策略的限制（无论是通过 Permissions-Policy 响应头指定抑或是通过 iframe 元素的 allow 属性指定） 默认为 self，即允许在当前上下文或内嵌的其他同源上下文中使用 权限 API该 API 调用需要用户授予 window-management 权限，可以调用 Permission.query() 方法检查用户是否已授予了该权限 类型1234567891011121314151617181920212223242526272829303132interface Screen extends EventTarget { readonly isExtended: boolean onchange: ((this: Screen, ev: Event) =&gt; any) | null}interface Window { getScreenDetails(): Promise&lt;ScreenDetails&gt;}interface ScreenDetails extends EventTarget { readonly screens: ScreenDetailed[] readonly currentScreen: ScreenDetailed onscreenschange: ((this: ScreenDetails, ev: Event) =&gt; any) | null oncurrentscreenchange: ((this: ScreenDetails, ev: Event) =&gt; any) | null}interface ScreenDetailed extends Screen { readonly availLeft: number readonly availTop: number readonly left: number readonly top: number readonly isPrimary: boolean readonly isInternal: boolean readonly devicePixelRatio: number readonly label: string}interface FullscreenOptions { screen: ScreenDetailed} 链接 https://developer.mozilla.org/en-US/docs/Web/API/Window_Management_API https://w3c.github.io/window-management/","link":"/2023/11/04/Window-Management-API/"},{"title":"Worker","text":"Web Worker 是 HTML 标准定义的 Web API 的一部分，可以在后台运行一个耗时的任务，避免因长期执行 JS 任务而阻塞用户界面渲染与交互 Web Worker 可以被 Window 环境创建，也可以被其他的 Worker 创建 Web Worker 是独立于主线程的一个线程，具有独立的作用域，其中运行的任务不会阻塞主线程 Web Worker 中的全局作用域 DedicatedWorkerGlobalScope 与 Window 的全局作用域不同，Window 环境中部分 API 在 Worker 环境中不可用或受到一定的限制 Web Worker 线程与主线程之间的通信通过 message 机制实现，传递的数据通过结构化拷贝算法传递，因此通常不存在处理线程安全的需要 创建 Worker通过调用 Worker() 构造函数，传入 Worker 脚本的 URL，来创建一个 Worker 1const worker = new Worker('./worker.js') Worker 脚本需要与 Client 同域 Worker() 构造函数支持传入一组可选的配置项其 type 参数指定脚本的类型，值可以是 classic 或 module，默认值是 classic其 name 参数指定 Worker 的名称，在 debug 时候有一定作用，在 Worker 内可以通过 name 只读属性访问其 credentials 参数指定 Worker 的 credentials 选项，允许的值可以是 omit、same-origin 或 include若传入的 URL 解析失败，会抛出一个 SyntaxError 错误若接收到的脚本文件并非 JavaScript 格式，会抛出 NetworkError 错误若当前文档环境不支持创建 Worker，如未遵守同源策略，会抛出 SecurityError 错误 Worker 消息传递无论是 Worker 端还是 Client 端，通过调用 postMessage() 方法实现发送消息，通过监听 message 事件实现接收消息 Client 发送消息 1worker.postMessage('message from client') Client 接收消息 123worker.addEventListener('message', (e) =&gt; { console.log('receive message in client: ', e.data)}) Worker 发送消息 1self.postMessage('message from worker') Worker 发送消息 123self.addEventListener('message', (e) =&gt; { console.log('receive message in worker: ', e.data)}) 此外，可以选择传入一组数组或包含 transfer 参数的配置项，定义需要转移所有权的对象 所有权被转移后，对应对象在原环境内不再可用，而是仅在新环境内可用 普通消息当然，传递的消息可以不仅仅是 string 类型，可以是其他任何可以被结构化拷贝算法执行的数据，包括： number string boolean null undefined bigint 普通 object Array RegExp Date Error Set Map Blob ArrayBuffer TypedArray 等等 结构化拷贝算法，严格来说，与 JSON.stringfy() 及 JSON.parse() 行为上不同。在结构化拷贝算法中，试图复制 Function 参数会抛出异常；但结构化拷贝算法支持复制包含循环对象的对象 可转移对象可以转移的对象可以是： ArrayBuffer MessagePort ReadableStream WritableStream TransformStream WebTransportReceiveStream AudioData ImageBitmap VideoFrame OffscreenCanvas RTCDataChannel 可共享对象SharedArrayBuffer 可以用于多个线程之间的共享数据，并利用 Atomics 实现线程同步与线程锁功能。 启用该 API 需要 secure context，并且需要 cross-origin isolate，可以通过检测 isSecureContext 全局变量和 crossOriginIsolated 全局变量来确定是否可以使用 SharedArrayBuffer 卸载 Worker通过调用 worker 实例的 terminate() 方法，来卸载一个 Worker 1worker.terminate() 或者调用 Worker 环境中的 close() 方法，来卸载当前的 Worker 1self.close() 卸载是立即执行的，不会等待 worker 内部任务的完成 Worker 全局环境Worker 全局环境通过 DedicatedWorkerGlobalScope 表示，该接口继承自 WorkerGlobalScope。 Worker 全局环境的 messageerror 事件会在传递的消息无法解析时触发，可用用于监听发送失败的消息（Worker 对象上同样存在） Worker 全局环境的 importScripts() 方法可以导入一组同源的脚本文件，并在 Worker 全局环境下执行 示例 https://github.com/skyclouds2001/Frontend-Learning/blob/main/next-learning/worker.html https://github.com/skyclouds2001/Frontend-Learning/blob/main/next-learning/worker.js 类型12345678910111213141516171819202122232425262728interface Worker extends EventTarget, AbstractWorker { constructor(scriptURL: string | URL, options?: WorkerOptions) postMessage(message: any, transfer: Transferable[]): void postMessage(message: any, options?: StructuredSerializeOptions): void terminate(): void}interface DedicatedWorkerGlobalScope extends WorkerGlobalScope { readonly name: string close(): void onmessage: ((this: DedicatedWorkerGlobalScope, ev: MessageEvent) =&gt; any) | null onmessageerror: ((this: DedicatedWorkerGlobalScope, ev: MessageEvent) =&gt; any) | null postMessage(message: any, transfer: Transferable[]): void postMessage(message: any, options?: StructuredSerializeOptions): void}interface StructuredSerializeOptions { transfer?: Transferable[]}interface WorkerOptions { credentials?: RequestCredentials name?: string type?: WorkerType}type WorkerType = 'classic' | 'module' 链接 https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API https://html.spec.whatwg.org/multipage/workers.html","link":"/2023/09/21/Worker/"},{"title":"ajax","text":"AJAX Ajax 简介AJAX = Asynchronous JavaScript And XML 网页中发生一个事件（页面加载、按钮点击） 由 JavaScript 创建 XMLHttpRequest 对象 XMLHttpRequest 对象向 web 服务器发送请求 服务器处理该请求 服务器将响应发送回网页 由 JavaScript 读取响应 由 JavaScript 执行正确的动作（比如更新页面） Ajax 使用XMLHttpRequest 对象用于同后台服务器交换数据 12345678910111213let request = new XMLHttpRequest();request.open('POST', 'https://www.baidu.com', true);request.setRequestHeader('Content-Type', 'application/json');request.onreadystatechange = function() { if(this.readyState === 4 &amp;&amp; this.status === 200) { console.log(this.responseText) }}request.send({}); readyState 请求状态 0：已创建对象未调用open方法 1：已调用open方法 2：已调用send方法已接收响应头 3：数据接收中 4：请求完成，数据接收完成或失败 status 服务器响应状态 responseText 请求返回的数据 请求数据类型 Content-Type application/x-www-form-urlencoded url 末尾加， ? 接 = 连接的键值对， 以 &amp; 分隔多个参数 https://www.baidu.com?id=1&amp;name=Lily 中文字符等会进行 URL 编码 使用 decodeURL() 编码，encodeURL() 解码 Ajax 默认请求数据类型 application/json json 数据类型 multipart/form-data 常用于上传文件 Ajax 新特性 设置请求时限 123456// 请求时限request.timeout = 3000;// 超时回调函数request.ontimeout = (e) =&gt; { console.log(e);} 使用 FormData 对象管理表单 12let data = new FormData();data.append('key', value); 上传文件 12345678// 获取文件let files = document.querySelector('input[type=file]').files;// 检测文件是否已选中if(files.length &lt;= 0) return alert('ERROR');// 创建 FormData 实例let data = new FormData();data.append('file', files[0]); 获取数据传输进度信息 12345678request.upload.onprogress = function (e) { // lengthComputable 表示上传的资源是否具有可计算的长度 if(e.lengthComputable) { // loaded 已传输的子节 // total 需传输的总子节 let percentComplete = Math.ceil((e.loaded / e.total) * 100); }} jQuery 的 Ajax $.ajax() 方法 1234567891011121314151617181920212223242526$('#button').on('click', function () { const files = $('#file')[0].files; if(files.length &lt;= 0) { return; } const data = new formData(); data.append('file', files[0]); $.ajax({ method: 'POST', url: 'https://www.baidu.com', data: data, // 内容编码类型 // 默认值: &quot;application/x-www-form-urlencoded&quot; contentType: false, // 是否进行url编码 // 默认值: true processData: false, success: function (res) { console.log(res); }, });}); $(document).ajaxStart() 方法 在 Ajax 请求发送前执行函数 123$(document).ajaxStart(function () { $('#loading').show();}); $(document).ajaxStop() 方法 在 Ajax 请求结束执行函数 axios专注于网络数据请求的库 目前最主流的 官方网站 axios.get &amp; axios.post 123456789101112axios.get(url, params) .then(function (res) { // 处理成功情况 console.log(res); }) .catch(function (err) { // 处理错误情况 console.log(err); }) .then(function () { // 总是会执行 }); axios.get(url[, config]) axios.post(url[, data[, config]]) axios({}) 123456789101112131415161718// promise 语法axios({ url: '', method: '', params: {}, // GET 数据：url参数 data: {}, // POST 数据：默认json参数对象}).then(res =&gt; { // do something with res.data});// async-await 语法const {data} = await axios({ url: '', method: '', params: {}, data: {},});// do something with data","link":"/2022/12/14/ajax/"},{"title":"css-1","text":"1. CSS简介CSS 即层叠样式表 (Cascading Style Sheets)，用于设置网页中元素的样式最新的CSS版本为CSS3 2. CSS 基本语法（1）CSS 结构 选择器 选择器用于选中页面中指定元素 声名块 声名块内包含为元素设定的样式 声名 声名组成声名块，声明是键值对的形式 （2）CSS 注释12345/* 这是一条CSS注释 *//* * 这也是一条CSS注释 */ 可以在代码中的任何位置添加注释，注释可以横跨多行 （3）HTMLclass属性与id属性**class** 属性规定元素的一个或多个 class 名称**id** 属性规定元素的唯一 id 值两者都是 HTML 元素的全局属性区别在于，同一个类名可以由多个 HTML 元素使用，而一个 id 名称只能由页面中的一个 HTML 元素使用 （4）CSS 样式表插入位置有三种插入样式表的方法： 内联样式，在标签内通过 style 属性设置元素样式 内部样式表，将样式写在 head 标签的 style 标签里 外部样式表，在外部 CSS 文件中写样式，再通过 link 标签导入 12345678910111213141516171819202122232425&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;css&lt;/title&gt; &lt;!-- 外部样式表 --&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;example.css&quot;&gt; &lt;!-- 内部样式表 --&gt; &lt;style type=&quot;text/css&quot;&gt; div { width: 100px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 内联样式 --&gt; &lt;div class=&quot;e&quot; id=&quot;e0&quot; style=&quot;height: 100%&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 3. CSS 颜色在HTML中，我们已经了解了一些颜色使用方式，如 颜色关键字，如 white 等 十六进制颜色，如 #de34e3 rgb 函数及 rgba 函数，如 rgb(12,34,250) 与之对应的是RGB颜色模式，取值均从0至255 红色（red） 绿色（green） 蓝色（blue） 以下是其他一些在CSS中的颜色使用方法 hsl函数及hsla函数 hsl(hue, saturation, lightness) hsla(hue, saturation, lightness, alpha) 与之对应的是HSL颜色模式 色相（hue）是色轮上从 0 到 360 的度数，0 是红色，120 是绿色，240 是蓝色 饱和度（saturation）是一个百分比值，可以认为是颜色的强度，0％ 表示灰色阴影，而 100％ 是全色 亮度（lightness）也是百分比，可以认为是应为颜色赋多少光，0％ 是黑色，50％ 是既不明也不暗，100％是白色 transparent 关键字 | 指定透明色 currentColor 关键字 | 指定从当前元素的文字颜色获取当前属性应指定的颜色 4. CSS 单位许多 CSS 属性接受“长度”值，长度是一个后面跟着长度单位的数字，数字和单位之间不能出现空格；但若数字为 0，则可以省略单位 长度单位有两种，分别是绝对单位和相对单位 绝对长度单位是固定的，用任何一个绝对长度表示的长度都将恰好显示为这个尺寸 相对长度单位规定相对于另一个长度属性的长度 绝对单位 描述 cm 厘米 mm 毫米 in 英寸 (1in = 96px = 2.54cm) Q 四分之一毫米 px 像素 (1px = 1/96th of 1in) pt 点 (1pt = 1/72 of 1in) pc 派卡 (1pc = 12 pt) 其中最常用的是px 相对单位 描述 em 相对于元素的字体大小（font-size）（2em 表示当前元素的字体大小的 2 倍） ex 相对于当前字体的字符 “x” 的高度 ch 相对于当前字体的字符 “0” 的宽度 rem 相对于根元素的字体大小（font-size） vw 相对于视窗宽度的 1% vh 相对于视窗高度的 1% vmin 相对于视窗宽度与高度内的较小尺寸的 1％ vmax 相对于视窗宽度与高度内的较大尺寸的 1％ % 相对于父元素相应属性的百分比","link":"/2022/08/05/css-1/"},{"title":"css-2","text":"选择器选择器用于选取需要设置样式的 HTML 元素 （1）简单选择器（i）元素选择器 作用：根据元素名选中指定元素 语法：**elementname {}** （ii）id 选择器 作用：根据元素 id 属性值选中一个元素 语法：**#idname {}** （iii）类选择器 作用：根据元素的 class 属性值选中一组元素 语法：**.classname {}** （iv）通配选择器 作用：选中页面中所有元素 语法：*** {}** （2）复合选择器（i）交集选择器 作用：选中同时符合多个条件的元素 语法：**_selector1selector2selector3 _{}** 注意：交集选择器中如果有元素选择器，必须以元素选择器开头 （ii）并集选择器 作用：同时选中多个选择器对应的元素 语法：**_selector1，selector2，selector3 _{}** 123456789101112/* * 选择器1 * {} * 选择器2 span {} * 选择器3 .outer {} * 选择器4 #inner {} * 选择器5 span.inner {} * 选择器6 .outer, .inner {} */&lt;div class=&quot;outer&quot;&gt; /* 选中的选择器：1|3|6 */ &lt;span class=&quot;inner&quot;&gt;&lt;/span&gt; /* 选中的选择器：1|2|5|6 */ &lt;div class=&quot;inner&quot; id=&quot;inner&quot;&gt;&lt;/div&gt; /* 选中的选择器：1|4|6 */&lt;/div&gt; （3）关系选择器关系选择器根据元素之间的关系选取元素，一般直系后代选择器与后代选择器使用的较多一些 （i）直系后代选择器 作用：选中指定父元素的指定子元素 语法：father &gt; son （ii）后代选择器 作用：选中指定元素的指定后代元素 语法：ancestor progeny （iii）相邻兄弟选择器 作用：选择下一个相邻兄弟元素 语法：prior + next 注意：一定是选中下一个、相邻的兄弟弟元素 （iv）通用兄弟选择器 作用：选择之后所有兄弟元素，不包括自己本身 语法：elderbrother ~ youngerbrother 1234567891011121314151617181920212223242526272829303132&lt;main&gt; &lt;p&gt;我是p元素&lt;/p&gt; &lt;div&gt; &lt;span&gt;span0&lt;/span&gt; &lt;/div&gt; &lt;span&gt;span1&lt;/span&gt; &lt;span&gt;span2&lt;/span&gt; &lt;span&gt;span3&lt;/span&gt;&lt;/main&gt;&lt;style&gt; /* 样式1 没有元素字体变红色 */ p + span { color: red; } /* 样式2 span1 字体变红色 */ div + span { color: red; } /* 样式3 span1、span2、span3 字体变红色 */ p ~ span { color: red; } /* 样式4 span1、span2、span3 字体变红色 */ main &gt; span { color: red; } /* 样式5 span0、span1、span2、span3 字体变红色 */ main span { color: red; }&lt;/style&gt; （4）属性选择器属性选择器根据 HTML 元素具有的 HTML 属性选取相应的元素 一般属性选择器使用相对较少，通常用于根据表单元素的type属性选取相应的元素以设置样式 以下 attribute 代表 HTML 属性，value 代表 HTML 属性值 （i）[attribute] 选择器选取带有指定属性的元素 （ii）[attribute=”value”] 选择器选取带有指定属性和值的元素（值必须是完整或单独的单词） （iii）[attribute~=”value”] 选择器选取属性值包含指定词的元素 （iv）[attribute|=”value”] 选择器选取指定属性以指定值开头的元素（值必须是完整或单独的单词） （v）[attribute^=”value”] 选择器选取指定属性以指定值开头的元素（值不必是完整单词） （vi）[attribute$=”value”] 选择器选取指定属性以指定值结尾的元素（值不必是完整单词） （vii）[attribute*=”value”] 选择器选取属性值包含指定词的元素（值不必是完整单词） 123456789101112131415161718192021222324252627282930313233a { color: blue;}/* 包含href属性的超链接元素 */a[href] { background-color: white;}/* href属性以 &quot;#&quot; 开头的超链接元素 */a[href^=&quot;#&quot;] { background-color: gold;}/* href属性包含 &quot;example&quot; 的超链接元素 */a[href*=&quot;example&quot;] { background-color: silver;}/* href属性包含 &quot;insensitive&quot; 的超链接元素,，不区分大小写 */a[href*=&quot;insensitive&quot; i] { color: cyan;}/* href属性包含 &quot;cAsE&quot; 的超链接元素，区分大小写 */a[href*=&quot;cAsE&quot; s] { color: pink;}/* href属性以 &quot;.org&quot; 结尾的超链接元素 */a[href$=&quot;.org&quot;] { color: red;} （5）伪类选择器伪类选择器是用于选择处于特定状态的元素的选择器 （i）子元素的伪类（序号） :first-child 选中父元素的第一个子元素 :last-child 选中父元素的最后一个子元素 :nth-child() 选中父元素的第 n 个子元素 特殊值： n 选中父元素的所有子元素 2n 或 even 选中父元素的所有偶数个子元素 2n+1 或 odd 选中父元素的所有奇数个子元素 :nth-last-child() 选中父元素从末尾开始数的第n个元素 :only-child 选取没有任何兄弟元素的元素 （_以上伪类根据父元素的所有子元素排序计数_） （ii）子元素的伪类（类型） :first-of-type 选中父元素中第一个同类的子元素 :last-of-type 选中父元素中最后一个同类的子元素 :nth-of-type() 选中父元素中第 n 个同类的子元素 :nth-last-of-type() 选中父元素中第 n 个同类的子元素 :only-of-type 选取没有任何相同类型的兄弟元素的元素 （_以上伪类根据父元素的同类子元素排序计数_） （iii）超链接的伪类建议按LVHA 顺序 :link — :visited — :hover — :active 声明超链接样式，否则可能会覆盖预期的样式 :link 选取表示没访问过的链接（正常链接） :visited 选取表示访问过的链接 由于隐私原因，这个伪类只能修改链接的文字颜色、背景颜色、边框颜色、轮廓颜色，且无法修改链接的透明度 :any-link 选取任一具有href属性的链接 实际效果相当于同时匹配 :link 或 :visited （iv）用户交互相关伪类 :hover 选取处于鼠标移入状态的元素 注意这个伪类在触摸屏上使用会存在一些问题，不建议在触摸屏设备上使用 :active 选取表示鼠标点击状态的元素，即鼠标点击至松开之间的阶段 （v）表单相关伪类 :checked 选取被选中的input:radio元素或input:checkbox元素或option元素 :focus 选取获得焦点的input元素 常见的情形如表单输入时显示提示性的样式 :focus-within 选取自身或自身子元素获得焦点的元素 相当于其自身或其子元素匹配到:focus伪类的元素 :indeterminate 选取处于不确定状态的input元素 不确定状态如存在未选中的相同name的input:radio元素或input:checkbox元素的indeterminate设定为true或不确定的progress元素 :default 选取默认状态的input元素 允许在input:radio元素或input:checkbox元素或option元素或button元素上使用 :placeholder-shown 选取placeholder文本起效时的input或textarea元素 :disabled 选取被禁用的input元素 :enabled 选取被启用的input元素 以上两个属性可能需要使用input元素或form元素的disabled属性 :in-range 选取值在规定范围内的input元素 :out-of-range 选取值超出规定范围内的input元素 一般需要规定input的type属性为number以上两个属性需要规定input元素的min属性或max属性以确定数值范围，否则没有意义 :invalid 选取具有非法值的input元素 :valid 选取具有合法值的input元素或form元素 :optional 选取非必须的input元素或select元素或textarea元素 :required 选取必须的input元素或select元素或textarea元素 以上两个属性可能需要使用input元素或form元素的required属性 :read-only 选取规定只读的元素 :read-write 选取规定可写的元素 以上两个属性可能需要使用表单元素的readonly属性或其他元素的contenteditable属性 （vi）类函数伪类 :not() 接收一个选择器参数，将符合条件的元素从原选择器选中元素中去除 :is() 接收任意数量的选择器参数，匹配符合任一选择器的元素 :where() 接收任意数量的选择器参数，匹配符合任一选择器的元素 :where() 和 :is() 的不同之处在于:where() 的优先级总是为 0 而 :is() 的优先级总是由它的选择器列表中优先级最高的选择器决定的 （vii）其他伪类 :root 选取文档的根元素 通常网页中指html元素，且优先级较高通常用于声明全局 CSS 变量 :scope 匹配选择器应匹配的参考点的元素 在样式表使用时，等价于:root在 DOM API 使用时，等价于调用 API 的元素 :target 选取唯一的页面元素(目标元素)，其id 与当前URL片段匹配 如https://www.baidu.com.html#p2，:target可以匹配到id为p2的任意类型的元素 :empty 匹配没有子元素或内部没有文本的每个元素 :lang() 根据元素的语言属性选取元素 lang可能由元素的 lang 属性决定或文档head标签内的 meta 标签规定的 lang 属性决定 :fullscreen 选取处于全屏状态的元素 :defined 选取已定义的元素：包括原生元素以及自定义元素 可以用于控制复杂的自定义组件加载完成前的显示，使其仅在加载完成后显示 （6）伪元素选择器伪元素选择器用于选取页面中一些特殊的并不存在的元素或是特殊的位置 ::first-letter 选择文本第一个字母 只适用于块状元素 ::first-line 选择文本第一行 ::placeholder 选取表单元素的placeholder属性规定的文本 ::selection 表示选中的内容 ::marker 选取列表项目的符号或是数字 注意：以上四个伪元素选择器仅允许使用特定的CSS属性 ::before 选择元素的开始，可以在元素开始插入一些内容 必须结合 content 属性使用 ::after 选择元素的最后，可以在元素结束插入一些内容 必须结合 content 属性使用 ::backdrop 选取全屏模式下的元素的背景，会在当前元素之下但在其他元素之上 可以用于在一些元素的全屏模式下修改默认的背景表现","link":"/2022/08/05/css-2/"},{"title":"css-3","text":"1. 样式继承&amp;样式覆盖CSS 为一个元素设置的某个样式，如果这个样式是允许继承的，那么这个样式也会应用到它的后代元素上 注意：不是所有样式都会被继承，只有可继承的样式才会从祖先元素基础样式的继承性建议查阅相应元素的参考手册 当一个元素同时被应用上多个相同的样式属性时，浏览器必须从中选择一个属性值，这个过程就是样式覆盖 样式继承有如下的规则： 当元素继承的样式发生冲突时，从最近祖先继承的样式有效 继承的样式和元素自身设置的样式冲突时，自身设置的样式有效 元素自身设置的样式发生冲突时，样式权值高的有效 样式权值按如下的列表相加确定 内联样式： 1,0,0,0 id 选择器： 0,1,0,0 类及伪类选择器： 0,0,1,0 标签及伪元素选择器： 0,0,0,1 通配选择器： 0,0,0,0 即：内联样式&gt;&gt;id选择器&gt;&gt;类及伪类选择器&gt;&gt;标签及伪元素选择器&gt;&gt;通配选择器 样式权值相同时，后设置的有效 !important的样式属性不被覆盖（除非同样为 !important 时，后设置的起效） 可以使用!important来阻止样式被覆盖 注意：除非不得已，尽量避免使用!important 2. 文档流模型（1）概念网页是一个多层结构，通过 CSS 可以给每层设置样式，上层会覆盖下层的内容，覆盖的内容不会被用户看到 这些多层结构中，最底下的一层即为文档流，默认情况下元素都在文档流中排列 （2）元素在文档流中特点 块元素 在页面中独占一行 默认情况下，宽度会把父元素撑满，即宽度由父元素宽度决定 默认情况下，高度会被内容撑开，即高度由内容的高度决定 行内元素 不会在页面中独占一行，只占自身大小 行内元素在页面中从左至右排列，如果一行不能容下，则换到第二行继续自左往右排列，即会自动换行 默认情况下，宽度和高度都被内容撑开，即宽高均由内容决定 （3）元素脱离文档流特点元素从文档流中脱离，不占据文档流中位置 元素脱离文档流后，无论块元素和行内元素，均会表现为块元素，有以下特点： 不会在页面中独占一行 宽高默认被内容撑开 设置 float、position、flex 等属性可使元素脱离文档流 3. 盒模型（1）盒模型概念所有 HTML 元素都可以视为一个盒子，在盒子模型中对页面的布局实际上就变成将不同的盒子摆放到不同位置 盒子模型包括：外边距、边框、内边距以及内容 内容 content 框的内容，其中显示子元素的内容 内边距 padding 内容周围的区域，内边距是透明的 边框 border 围绕内边距和内容的边框 外边距 margin 边界外与其他元素不覆盖的区域，外边距是透明的 （2）可见框概念可见框即元素可以看到的区域，由内容区、边框、内边距组成，不包括外边距 4. 内容区-content（1）width 属性及 height 属性分别设置内容区的宽度与高度 可以取以下值： auto 让浏览器计算高度和宽度【默认】 length 以 px 等单位定义高度或宽度 % 以包含块的百分比定义高度或宽度 initial 将高度或宽度设置为默认值 inherit 从其父值继承高度或宽度 这也是大多数与长度&lt;length&gt;有关的属性的合法取值 （2）min-width 属性 min-height 属性及max-width 属性 max-height 属性设置元素的最大/最小的宽度/高度 默认值为none，即表示忽略该属性 5. 内边距-padding（1）padding 属性设置四个方向内边距 （i）取值长度单位，要求为正值 或取值为auto （ii）值个数可为1~4，不同数量下取值按如下情况所示 按顺时针顺序依次指定值 四个值：上 右 下 左 按顺序分别设置上边距，右边距，下边距，左边距 三个值：上 左右 下 按顺序分别设置上边距，左右边距，下边距 两个值：上下 左右 按顺序分别设置上下边距，左右边距 一个值：上下左右 同时设置上下左右边距 （2）padding-top、padding-right、padding-bottom、padding-left属性单独设置某方向内边距 6. 边框-border（1）border-style 属性指定边框类型，必需，简写属性 （i）取值 dotted 定义点线边框 dashed 定义虚线边框 solid 定义实线边框 double 定义双边框 none 定义无边框【默认】 hidden 定义隐藏边框 groove 定义 3D 坡口边框，效果取决于 border-color 值 ridge 定义 3D 脊线边框，效果取决于 border-color 值 inset 定义 3D inset 边框，效果取决于 border-color 值 outset 定义 3D outset 边框，效果取决于 border-color 值 （ii）border-top-style、border-right-style、border-bottom-style、border-left-style属性指定一个方向的边的边框类型 （2）border-width 属性指定边框的宽度，简写属性 （i）取值长度，只能为正值 亦可取预设值thin、medium【默认】、strong （ii）border-top-width、border-right-width、border-bottom-width、border-left-width属性指定一个方向的边的边框宽度 （3）border-color 属性指定边框的颜色，简写属性 （i）取值允许所有颜色模式，如rgb()等亦可取transparent表示透明色 （ii）border-top-color、border-right-color、border-bottom-color、border-left-color属性指定一个方向的边的边框颜色 （4）border属性同时设置四条边框宽度、颜色、样式，是border-width、border-style 以及 border-color 的简写属性 （i）取值border: width color style 如果不设置其中的某个值也是允许的 （ii）值个数 四个值：上 右 下 左 按顺序分别设置上边框，右边框，下边框，左边框 三个值：上 左右 下 按顺序分别设置上边框，左右边框，下边框 两个值：上下 左右 按顺序分别设置上下边框，左右边框 一个值：上下左右 同时设置上下左右边框 （5）border-top、border-right、border-bottom、border-left属性同时设置一个方向的一条边框宽度、颜色、样式，简写属性 7. 外边距-margin（1）margin属性为元素的四周指定外边距的属性 （i）取值 长度单位，允许负值的使用允许取值为auto （ii）值个数 四个值：上 右 下 左 按顺序分别设置上边距，右边距，下边距，左边距 三个值：上 左右 下 按顺序分别设置上边距，左右边距，下边距 两个值：上下 左右 按顺序分别设置上下边距，左右边距 一个值：上下左右 同时设置上下左右边距 （2）margin-top、margin-right、margin-bottom、margin-left属性为元素的四周分别指定外边距的属性 8. 块元素盒模型拥有margin、border、padding、content等结构 （1）水平方向布局一般而言，子元素在父元素内的元素总宽度应满足公式： 元素总宽度 = 宽度 + 左内边距 + 右内边距 + 左边框 + 右边框 + 左外边距 + 右外边距 若不成立，称为过度约束，此时遵循如下规则确定元素的实际宽度 如果七个值中没有 auto，则会调整 margin-right 的值使等式成立 比如子元素 width 超过父元素内容区大小，margin-right 会调整为负值，使子元素溢出父元素 如果 width、margin-left、margin-right中有一个设置为 auto，则会调整被设置为 auto 的那个值，使等式成立 比如 width 默认值为 auto，所以块元素默认宽会充满整个父元素 如果 width、margin-left、margin-right 中有两个及以上设置为 auto 如果 width 设置为固定值，margin-left 和 margin-right 设置为 auto，则同时调整 margin-left 与 margin-right 使等式成立，此时子元素居中如果 width 设为 auto，则子元素 width 调为最大，其余被设置为 auto 的属性取值为 0 设置 margin: auto 是设置子元素在父元素内水平居中的一种常用方法 （2）垂直方向布局一般而言，默认情况下父元素高度被内容撑开，子元素在父元素内的元素总高度应满足公式 元素总高度 = 高度 + 上内边距 + 下内边距 + 上边框 + 下边框 + 上外边距 + 下外边距 若父元素设置了高度，且子元素高度大于父元素，此时公式不成立，称为溢出，此时子元素会从父元素溢出： 此时可设置overflow属性来处理溢出问题 （3）overflow属性定义溢出元素内容区的内容的处理方式是 overflow-x 与 overflow-y 的简写属性 （i）取值 visible【默认】 内容不会被修剪，会呈现在元素框之外 hidden 内容会被修剪，并且其余内容是不可见的 scroll 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容（无论有无溢出都会产生滚动条） auto 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容（有溢出才会产生滚动条） （ii）overflow-x 与overflow-y属性指定元素在x轴上或者y轴上对溢出元素内容区的内容的处理方式 9. 行内元素盒模型行内元素盒模型的结构和块元素基本相同 但亦存在以下几点区别： 行内元素不支持设置 width 和 height，内容区宽高只由其内容决定 可以设置 border，但是垂直方向 border 不会影响布局 可以设置 padding，但是垂直方向 padding 不会影响布局 可以设置 margin，但是垂直方向 margin 不会影响布局 10. 盒子大小-box-sizing属性默认情况下width属性及height属性指的是内容区的大小 box-sizing属性可以改变盒子尺寸计算方式 取值有 content-box【默认值】 宽高用来设置内容区大小 width = content border-box 宽高用来设置盒子可见框的大小 width = content + padding + border box-sizing: border-box 在前端开发中应用非常广泛，可以用于 控制盒子的可见区域大小","link":"/2022/08/06/css-3/"},{"title":"git","text":"git版本控制版本控制软件 操作简便|易于对比|易于回溯|不易丢失|协作方便 本地版本控制系统-&gt;集中化版本控制系统-&gt;分布式版本控制系统 git快照：在原有文件基础上重新生成一个文件，类似于备份 操作：本地执行，云端同步 git 文件状态 未跟踪（untracked）未被 git 管理 未修改（unmodified）工作区文件内容与 git 仓库内文件相同 已修改（modified）表示修改了文件，但还没保存到 git 本地仓库中，自上次检出后，作了修改但还没有放到暂存区域 已暂存（staged）表示对一个已修改文件的当前版本做了标记以使之包含在下次提交的快照中，文件已修改并放入暂存区 已提交（committed）表示数据已经安全地保存在 git 仓库中，Git 目录中保存着特定版本的文件 git 项目阶段 工作区是对项目的某个版本独立提取出来的内容，供用户修改与使用 暂存区是一个文件，保存了下次将要提交的文件列表信息 Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方 git 全局配置文件路径 C:/Users/用户名文件夹/.gitconfig 文件 查看所有全局配置项 git config --list --global git 帮助git help &lt;verb&gt; git 初始化仓库 将尚未进行版本控制的本地目录转换为 Git 仓库 git init 从其它服务器克隆一个已存在的 Git 仓库 git clone &lt;url&gt; [&lt;storagename&gt;] 允许 https 协议等，以及 git 协议与 SSH 协议 git 文件操作git status 检测文件所处状态 git status -s git status –short 标记 A 表示新建的文件 标记 M 表示修改的文件 标记?? 表示未修改的文件 git diff 显示尚未暂存的改动 git add &lt;filename&gt; 开始跟踪新文件&amp;将已跟踪新文件放至暂存区 git commit [-m &quot;message&quot;] 从暂存区提交更新至 git 仓库 ​ git commit -a [-m &quot;message&quot;] 一次性将跟踪的文件暂存并提交 git checkout -- &lt;filename&gt; 撤销对文件的修改：将对应工作区文件修改还原成 git 仓库中保存的版本 git reset HEAD &lt;filename&gt; 从暂存区移除文件 git rm {-f|--cached} &lt;filename&gt; -f 从仓库与工作区移除文件:–cached 仅从仓库移除文件，但保留工作区文件 git mv &lt;filefrom&gt; &lt;fileto&gt; 移动文件或重命名文件 git 忽略文件创建 .gitignore 的文件列出要忽略的文件的模式 所有空行或者以 # 开头的行都会被 Git 忽略 可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中 匹配模式可以以（/）开头防止递归 匹配模式可以以（/）结尾指定目录 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反 glob 模式是指 shell 所使用的简化了的正则表达式 星号（*）匹配零个或多个任意字符 [abc] 匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c） 问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字） 使用两个星号（**）表示匹配任意中间目录，比如 a/**/z 可以匹配 a/z 、 a/b/z 或 a/b/c/z 等 1234567891011121314151617# 忽略所有的 .a 文件*.a# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件!lib.a# 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO/TODO# 忽略任何目录下名为 build 的文件夹build/# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txtdoc/*.txt# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件doc/**/*.pdf 参考链接 git 查看文件历史git log ​ -&lt;number&gt; 显示指定的提交历史 按 q 退出 开源开源：open source code 开源许可协议：open source license ​ GPL MIT 等 开源项目托管平台：github、gitlab、gitee 远程仓库访问方式 HTTPS 无需配置，每次需输入账号密码 git remote add &lt;本地版本库&gt; &lt;远程仓库url&gt; git remote add origin gitutl-httpsgit push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; git push origin master SSH 需额外配置，每次无需输入账号密码 SSH key 个人私钥 git 服务器公钥 分支查看、创建、切换、合并、删除、跟踪、拉取 主分支 master实际用于保存及记录整个项目已完成及审计的代码 功能分支：专门用于开发新功能的分支 查看分支git branch 分支前的 * 代表当前分支 创建分支git branch &lt;branch-name&gt; 相较于当前分支创建分支 创建分支时不改变原所在分支 切换分支git checkout &lt;new-branch-name&gt; 快速创建切换分支git checkout -b &lt;new-branch-name&gt; 合并分支git merge &lt;branch-name&gt; 将指定分支合并到当前分支 若两分支存在分歧，需要主动处理冲突 删除分支git branch -d &lt;branch-name&gt; git branch -D &lt;branch-name&gt; 强制删除 推送分支至远程仓库git push -u &lt;remote-repository&gt; &lt;local-branch&gt;:&lt;remote-branch&gt; 第一次 之后直接 git push 即可 查看远程仓库分支列表git remote show &lt;remote-repository&gt; 跟踪[远程仓库]分支git checkout &lt;remote-branch&gt; git checkout &lt;local-branch&gt; &lt;remote-repository&gt;/&lt;remote-branch&gt; 同时重命名本地分支 拉取[远程仓库最新]分支git pull 相较于当前分支 删除[远程仓库]分支git push &lt;remote-repository&gt; --delete &lt;remote-branch&gt;","link":"/2022/08/09/git/"},{"title":"hello world","text":"我的个人博客正式开通啦！","link":"/2022/07/20/hello-world/"},{"title":"HTML-1","text":"HTML-11. HTML 简介（1）HTML 概念HTML 全名是超文本标记语言 (Hyper Text Markup Language) ，是专门用来描述网页的一种语言 HTML 不是一种编程语言，而是一种标记语言 (markup language) 标记语言是一套标记标签 (markup tag) HTML 使用标记标签来描述网页 HTML文档 = 网页 HTML 文档描述 网页 HTML 文档包含 HTML 标签和纯文本 HTML 文档也被称为网页 （2）HTML 版本当下普遍使用的是 HTML5HTML5 是最新的 HTML 标准，拥有许多令人激动的新特性，目前大多数主流浏览器都支持HTML5的大部分特性下一个版本的 HTML 标准 —— HTML6 ，正在讨论中，也许不久之后 HTML6 就会面向广大开发者 （3）推荐编辑器推荐使用 Visual Studio Code 软件进行前端web端的开发VS code 官方下载链接 2. HTML 基本语法（1）标签HTML 标记标签通常被称为 HTML 标签 (HTML tag) HTML 标签是由尖括号包围的关键词，比如 HTML 标签通常是成对出现的，比如 和 HTML 标签对中的第一个标签是开始标签（start tag），第二个标签是结束标签（end tag） 开始和结束标签也被称为开放标签和闭合标签 123&lt;标签名&gt;&lt;/标签名&gt;如：&lt;html&gt;&lt;/html&gt; （2）元素 HTML 元素以开始标签起始，以结束标签终止 HTML 元素的内容是开始标签与结束标签之间的内容 某些 HTML 元素具有空内容（empty content），空元素在开始标签中进行关闭（以开始标签的结束而结束） 大多数 HTML 元素可拥有属性 123&lt;空元素/&gt;如：&lt;img/&gt; 大多数 HTML 元素可以嵌套，即大多数 HTML 元素可以包含其他 HTML 元素， HTML 文档由相互嵌套的 HTML 元素构成 （3）属性HTML 元素可以设置属性属性可以在元素中添加附加信息属性放置在开始标签内属性总是以键-值对的形式出现，比如：name=”value” 123&lt;标签名 属性名=&quot;属性值&quot;&gt;&lt;/标签名&gt;如：&lt;a href=&quot;http://www.baidu.com&quot;&gt;This is a link&lt;/a&gt; （4）注释HTML 注释使用 &lt;!-- 注释内容 --&gt; 描述，注释内容放置于开始标签与结束标签之间 1&lt;!-- 这是一个HTML注释！ --&gt; （5）文档结构以下是一个典型的 HTML 文档的结构 1234567891011121314151617181920212223242526&lt;!-- 文档声名，声名当前网页版本：区别是html、xml等文档类型 --&gt;&lt;!DOCTYPE html&gt;&lt;!-- html 根标签，网页中所有元素都写在根元素里边 --&gt;&lt;html&gt; &lt;!-- head 是网页头部，head 中绝大多数内容不会在网页中直接出现，主要用于帮助浏览器和搜索引擎解析网页 --&gt; &lt;head&gt; &lt;!-- meta 一般用于设置网页元数据，这里 meta 用于设置网页字符集，避免乱码问题 --&gt; &lt;!-- 注意：对于中文网页需要使用 &lt;meta charset=&quot;utf-8&quot;&gt; 声明为utf-8编码，否则会因为默认编码无法解析汉字出现乱码情况 --&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;!-- title 中的内容会显示在浏览器标题栏中，搜索引擎会主要根据 title 判断网页主要内容 --&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;/head&gt; &lt;!-- body 是 html 的子元素，表示网页的主体，网页中所有可见内容都应该写在 body 里 --&gt; &lt;body&gt; &lt;!-- 这里写的是网页的主体内容 --&gt; &lt;/body&gt;&lt;/html&gt; （6）字符实体在 HTML 中，某些字符是预留的，比如在 HTML 中不能直接使用小于号（&lt;）和大于号（&gt;），这是因为浏览器会把小于号（&lt;）和大于号（&gt;）误认为标签 如果希望正确地显示预留字符，必须在 HTML 源代码中使用字符实体，比如小于号（&lt;）和大于号（&gt;）可用&amp;lt; 和 &amp;gt;来表示从而正常显示 浏览器常常会截短 HTML 页面中的空格，如果在文本中写 10 个空格，在显示该页面之前，浏览器会合并这些空格，只留下一个空格，如e e在浏览器中实际显示效果为e e，如果需要在页面中增加空格的数量，可以使用 &amp;nbsp; 正常了解以上3个字符实体在开发中是足够了的，更多的字符实体可以参考链接 （7）颜色HTML中支持多种方式表示颜色，大都基于rgb颜色模式 颜色名，如 white black等 关于浏览器支持的颜色名可参考链接 十六进制，如 #01ef20，特别的如同 #111111 形式的可简写为 #111 rgb函数及rgba函数，如rgb(12,34,250) 我们会在CSS部分讲解更多与颜色相关的知识 （8）代码规范在编写HTML文档时，遵守一些公认的代码规范有助于提高代码的可读性，也利于团队协作 使用正确的文档类型 始终在文档的首行声明文档类型&lt;!DOCTYPE html&gt; 使用小写元素名 关闭所有HTML元素与HTML空元素 使用小写属性名 所有属性值添加引号 合理利用空格和缩进 3. 文本格式化标签及段落标签（1）标题标签 &lt;h1&gt; ~ &lt;h6&gt;标题（Heading）是通过 &lt;h1&gt; - &lt;h6&gt; 等标签进行定义的，&lt;h1&gt; 定义最大的标题，&lt;h6&gt; 定义最小的标题 （2）段落标签 &lt;p&gt;段落通过 标签定义，浏览器会自动地在段落的前后添加空行 （3）水平线标签 &lt;hr/&gt; 与换行标签 &lt;br/&gt;（4）其他文本格式化标签 粗体 &lt;strong&gt; 斜体 &lt;em&gt; 下划线 &lt;ins&gt; 删除线 &lt;del&gt; 上标 &lt;sup&gt; 下标 &lt;sub&gt; 123456789101112131415161718&lt;h1&gt;this is a h1 tag&lt;/h1&gt;&lt;h2&gt;this is a h2 tag&lt;/h2&gt;&lt;h3&gt;this is a h3 tag&lt;/h3&gt;&lt;h4&gt;this is a h4 tag&lt;/h4&gt;&lt;h5&gt;this is a h5 tag&lt;/h5&gt;&lt;h6&gt;this is a h6 tag&lt;/h6&gt;&lt;p&gt;this is a p tag&lt;/p&gt;&lt;p&gt;this is a p tag too&lt;/p&gt;&lt;p&gt;use br tag &lt;br/&gt; like this&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;this is a &lt;strong&gt;strong&lt;/strong&gt; tap&lt;/p&gt;&lt;p&gt;this is a &lt;em&gt;em&lt;/em&gt; tap&lt;/p&gt;&lt;p&gt;this is a &lt;ins&gt;ins&lt;/ins&gt; tap&lt;/p&gt;&lt;p&gt;this is a &lt;del&gt;del&lt;/del&gt; tap&lt;/p&gt; 效果如下 其他文本格式化标签可参考 W3School标签参考手册 一般实际开发中很少用到文本格式化标签，更常见的是使用CSS字体样式来实现文本格式化效果，这里仅做简单介绍；一般使用文本格式化标签用于表现相关的语义 4. 块元素与行内元素（1）概念 块元素：独占一行的元素，如 &lt;p&gt; 行内元素：不会独占一行的元素，如 &lt;img&gt; 大多数 HTML 元素被默认定义为块级元素或内联元素，块级元素在浏览器显示时，通常会以新行来开始（和结束），内联元素在显示时通常不会以新行开始 注意：一般情况下块元素中放置块元素或行内元素，行内元素内仅放置行内元素，而不推荐在行内元素中放置块元素 （2）分组标签&lt;div&gt; 默认是块元素&lt;span&gt; 默认是行内元素 标签 描述 &lt;div&gt; 定义文档中的分区或节（division/section） &lt;span&gt; 定义 span，用来组合文档中的行内元素 &lt;div&gt; &lt;span&gt; 在前端开发中非常常用，常用于与CSS相互配合，分别实现对大的内容块和部分文本设置样式；或是充当包裹其他HTML元素的容器和文本的容器 5. 语义化标签（1）概念语义化标签，就是让标签有自己的含义，利用本身传达它所包含内容的一些信息，使浏览器和搜索引擎直观的认识标签和属性的用途和作用；同时也能够提高HTML文档的可读性，便于协作开发与后续维护 （2）优点 代码结构清晰，可读性高，减少差异化，便于团队开发和维护 在页面没有加载CSS的情况下，也能呈现良好的内容结构，提升用户体验 对搜索引擎友好，良好的结构和语义，有助于爬虫抓取更多的有效信息 （3）一些语义化标签简介 标签 描述 &lt;article&gt; 定义文章。 &lt;aside&gt; 定义页面内容以外的内容。 &lt;details&gt; 定义用户能够查看或隐藏的额外细节。 &lt;figcaption&gt; 定义 &lt;figure&gt; 元素的标题。 &lt;figure&gt; 规定自包含内容，比如图示、图表、照片、代码清单等。 &lt;footer&gt; 定义文档或节的页脚。 &lt;header&gt; 规定文档或节的页眉。 &lt;main&gt; 规定文档的主内容。 &lt;mark&gt; 定义重要的或强调的文本。 &lt;nav&gt; 定义导航链接。 &lt;section&gt; 定义文档中的节。 &lt;summary&gt; 定义 &lt;details&gt; 元素的可见标题。 &lt;time&gt; 定义日期/时间。 下图给出了一些常见语义化标签的使用场景","link":"/2022/07/27/html-1/"},{"title":"jquery","text":"jQuery简介官方文档https://jquery.com/ 内容jQuery JavaScript函数库 jQuery文件结构(function() {} ())，实质是一个自执行函数，给window对象添加一个jQuery属性和$属性 $是一个函数，传一个匿名函数即入口函数；传一个字符串即选择器；传一个dom对象即jQuery对象 可以用jQuery代替$的使用 引入jQuery即执行该js文件内代码 入口函数$(function() {}) 等价于 window.onload() 可以写多个jQuery入口函数，其执行时机快于window.onload：window.onload等待所有资源加载完毕后执行；jQuery入口函数只等待dom树加载完成 $(document).ready(function(){})入口函数 建议 把所有 jQuery 代码置于事件处理函数中 把所有事件处理函数置于文档就绪事件处理器中 把 jQuery 代码置于单独的 .js 文件中 如果存在名称冲突，则重命名 jQuery 库 jQuery对象概念 jQuery对象是伪数组，实际是dom对象的一个包装集合 通过jQuery($())包装DOM的对象后产生的对象，为jQuery独有 与DOM对象无法相互使用彼此方法 建议jQuery对象在变量名前加$ jQuery对象获取DOM对象 [index] .get(index) jQuery对象获取DOM对象 $()包装 jQuery事件 触发点击事件 .click() 设置点击事件 .click(function(){}) 特别的，仅会返回符合条件的第一个属性值 鼠标移入事件 .mouseover() .mouseenter() 特别的，over在移入其本身及其子元素都会触发，enter仅移入其本身才触发 鼠标移出事件 .mouseleave .mouseout 特别的，out在移出其本身及其子元素都会触发，leave仅移出其本身才触发 事件添加简单事件-&gt;bind事件-&gt;delegate事件-&gt;on事件 简单事件：click(function(){}) 不支持同时注册与动态注册 bind事件：.bind(‘click’, function(){}) 不支持动态注册 delegate事件：.delegate(‘selector‘, {click: function(){}}) on事件： 事件注册 $(selector).on(‘click’, function(){}) 事件委托 $(selector).on(‘click’, ‘selector’, function() {}) 事件解绑unbind() 不推荐 undelegate() 不推荐 off() 推荐 无参 事件触发trigger() 触发事件 事件对象jQuery事件对象是对原生js事件对象的封装，已处理了兼容性 坐标 screenX|screenY 原点屏幕左上角 clientX|clientY 原点可见页面区域左上角 pageX|pageY 原点页面区域左上角 方法 stopPropagation() 阻止事件冒泡 preventDefault() 阻止浏览器默认行为 事件响应方法返回false，可阻止事件冒泡与浏览器默认行为 keyCode 获取按下键盘的键码 jQuery选择器简单选择器 id选择器 $(‘#id‘) 类名选择器 $(‘.class‘) 元素选择器 $(‘tag’) 通配选择器 $(‘*’) 选取当前元素 $(this) 复合选择器 并集选择器 $(‘selector1‘, ‘selector2‘) 交集选择器 $(‘selector1selector2‘) 关系选择器 子运算选择器 $(‘father &gt; son‘) 后代元素选择器 $(‘grandfather son‘) 过滤选择器 $(‘:eq(index)’) 特定序号子元素选择 $(‘:odd’) 奇数子元素选择 $(‘:even’) 偶数子元素选择 筛选选择器/方法 .next() 找下一个兄弟元素 .prev() 找上一个兄弟元素 .eq(index) 查找指定下标的兄弟元素 .parent() 查找父元素 .siblings(selector) 查找不包含自身的兄弟元素 .find(selector) 后代选择器 .children(selector) 子类选择器 jQuery HTML元素操作获取及设置元素内容属性 设置元素内文本 .text(*String*) .text(function(i, origText) {return *string*}) ​ 会覆盖内部所有内容包括子元素内容 ​ 不会解析字符串中的HTML部分 ​ 存在隐式迭代现象 ​ 回调函数形式：回调函数由两个参数：被选元素列表中当前元素的下标，以及原始（旧的）值，然后以函数新值返回您希望使用的字符串 1234$(&quot;#test1&quot;).text(function(i,origText){ return &quot;Old text: &quot; + origText + &quot; New text: Hello world! (index: &quot; + i + &quot;)&quot;;}); 获取元素内所有文本 .text() 获取及设置元素内容 .html() 同text 可以解析设置内容的元素节点 获取及设置表单字段的值 .val() 同text 创建节点 $() 需要主动添加到页面内 获取及设置元素样式属性 设置元素CSS属性 .css(‘property‘, value) ​ .css(‘property1‘: value1) ​ .css({‘property1‘: value1, ‘property2‘: value2}) 修改与添加 获取元素 CSS属性内容 .css(‘property‘) 12345678$('#box1').css('width', '300px')$('#box1').css('width', 300)$('#box1').css({ width: 300, 'height': '300px', 'background-color': 'green'}) 获取和设置元素的属性值 .attr() 同css，回调函数同text 移除属性值 .removeAttr(‘tag‘) 设置布尔类型的属性：即元素标签内添加起效，不添加不起效的 .attr(‘tag‘) 获取元素尺寸 获取或设置元素宽高 .width() .height() 获取元素含内边距宽高 .innerwidth() .innerheight() 获取元素含内边距及边框宽高 .outerwidth() .outerheight() 获取元素含内外边距及边框宽高 .outerwidth(true) .outerheight(true) 获取元素位置 获取元素距document位置 .offset() 返回对象，包括top和left的值 获取元素距设置定位属性的父元素offsetParent的位置 .position() 返回值情况同offset 插入元素 在元素开头结尾插入内容 .prepend(string1, …) .append(string1, …) $(&quot;p&quot;).append(&quot;Some appended text.&quot;); ​ .appendTo() .prependTo() $(content).appendTo(selector) 在元素之前之后插入元素 .before() .after() $(&quot;img&quot;).after(&quot;Some text after&quot;); 删除元素 删除元素及其子元 素 .remove() .remove(selector) $(&quot;#div1&quot;).remove(); $(&quot;p&quot;).remove(&quot;.italic&quot;); 过滤 删除元素子元素 .empty() $(&quot;#div1&quot;).empty(); 获取及设置类class 添加类 .addClass() $(&quot;#div1&quot;).addClass(&quot;important&quot;); $(&quot;div&quot;).addClass(&quot;important blue&quot;); 移除类 .removeClass() $(&quot;h1,h2,p&quot;).removeClass(&quot;blue&quot;); $(&quot;div&quot;).addClass(&quot;important blue&quot;); $(&quot;h1,h2,p&quot;).removeClass(); 添加&amp;删除类 .toggleClass() 判断类的存在 .hasClass() 返回布尔值 $(&quot;#div1&quot;).hasClass(&quot;important&quot;); 其他 查询并设置元素内容被卷曲出去的宽高度 scrollLeft() scrollTop() 即元素的子元素宽高度超出元素本身的宽高度 克隆元素 .clone() 克隆的节点需要主动添加至页面上 参数true表示克隆事件，否则不克隆事件，默认不克隆 jQuery效果与方法元素隐藏及显示 隐藏元素 .hide() 显示元素 .show() 隐藏及显示元素 .toggle() 无参数无动画效果，有参数有动画效果 speed 参数规定隐藏/显示的速度，可以取以下值：”slow”、”normal”、”fast” 或毫秒 callback 参数是 toggle() 方法完成后所执行的函数名称 实质是修改display属性 元素淡入淡出 淡入已隐藏元素 .fadeIn() $(selector).fadeIn(speed,callback); 淡出可见元素 fadeOut() $(selector).fadeOut(speed,callback); 淡入或淡出元素 fadeToggle() $(selector).fadeToggle(speed,callback); 渐变为指定不透明度 fadeTo() $(selector).fadeTo(speed,opacity,callback); 实质是修改opacity属性 元素滑动 向下滑动 .slideDown() $(selector).slideDown(speed,callback); 向上滑动 .slideUp() $(selector).slideUp(speed,callback); 向下或向上滑动 .slideToggle() $(selector).slideToggle(speed,callback); 实质是修改padding和margin属性等 元素动画(自定义动画) 自定义动画 .animate() $(selector).animate({params},speed,easing,callback); easing 可选 规定在不同的动画点中设置动画速度的 easing 函数（swing缓动 或 linear匀速） 可以定义相对值（该值相对于元素的当前值），在值的前面加上 += 或 -= 停止动画 .stop() $(selector).stop(stopAll,goToEnd); 可选的 stopAll 参数规定是否应该清除动画队列，默认是 false，即仅停止活动的动画，允许任何排入队列的动画向后执行 可选的 goToEnd 参数规定是否立即完成当前动画。默认是 false 其他 释放 $ 标识符的控制，并返回对$的引用，可创建新的jQuery对象 $.noConflict() jQuery遍历祖先 parent() 获取给定元素的直接父元素 parents() 获取给定元素的所有祖先元素，直至文档根元素html 允许参数，以过滤搜索祖先元素 parentsUntil() 获取直至给定元素间的所有祖先元素 后代 children() 获取给定元素的所有直接子元素 可添加参数过滤搜索 find() 获取给定元素的后代元素 必须添加参数决定搜索范围 兄弟 siblings() 获取给定元素的所有兄弟元素，不包括原给定元素 next() 返回给定元素的下一个兄弟元素 nextAll() 返回给定元素的之后所有兄弟元素 nextUntil() 返回给定元素与给定参数间所有跟随的同胞元素 prev() prevAll() prevUntil() 过滤 first() 选取首个元素 last() 选取最后一个元素 eq() 选取指定下标的元素，接受参数代表下标 filter() 选取符合给定规则的所有元素 not() 选取不符合给定规则的所有元素 jQuery Ajax方法load() 方法从服务器加载数据，并把返回的数据放入被选元素中 $(selector).load(URL,data,callback); 必需的 URL 参数规定加载的 URL 可选的 data 参数规定与请求一同发送的查询字符串键/值对集合 可选的 callback 参数是 load() 方法完成后所执行的函数名称 123456789$(&quot;#div1&quot;).load(&quot;demo_test.txt&quot;);$(&quot;#div1&quot;).load(&quot;demo_test.txt #p1&quot;);$(&quot;#div1&quot;).load(&quot;demo_test.txt&quot;,function(responseTxt,statusTxt,xhr){ if(statusTxt==&quot;success&quot;) alert(&quot;外部内容加载成功！&quot;); if(statusTxt==&quot;error&quot;) alert(&quot;Error: &quot;+xhr.status+&quot;: &quot;+xhr.statusText);}); get() 方法通过 HTTP GET 请求从服务器上请求数据 $.get(URL,callback); 必需的 URL 参数规定请求的 URL 可选的 callback 参数是请求成功后所执行的函数名 第一个回调参数存有被请求页面的内容，第二个回调参数存有请求的状态 1$.get(&quot;demo_test.asp&quot;,function(data,status){}); post() 方法通过 HTTP POST 请求从服务器上请求数据 $.post(URL,data,callback); ajax() 方法通过 HTTP 请求加载远程数据 可自选请求参数 其他链式编程 如$('div').width(100).height(100).css('backgroundColor', 'red'); 返回值需均为相应的jQuery对象才能持续调用 end() 返回调用函数链的原始jQuery对象 each() 遍历jQuery对象集合，为各元素执行一次回调函数，回调函数第一个参数为下标，第二个·参数为对应元素的引用","link":"/2022/08/14/jquery/"},{"title":"HTML-2","text":"1. 超链接标签及媒体元素标签（1）超链接标签&lt;a&gt;简介 超链接可以用于跳转到新的文档或网页或者当前文档中的某个部分，超链接可以是一个字，一个词，或者一组词，也可以是一幅图像，一块区域等等超链接标签内可以包裹其他任意标签（超链接标签本身除外） 属性 href 定义指向一个文件或是一个网址的 url 或是一个 url 片段 target 定义超链接的跳转方式 _self：在当前页面中打开超链接【默认值】 _blank：在新页面中打开超链接 download 定义下载 url 指向的文件而不是打开链接，会提示用户保存该文件 用法 1234567891011121314151617181920212223242526&lt;!-- 跳转到网页 --&gt;&lt;a href=&quot;https://baidu.com&quot;&gt;百度&lt;/a&gt;&lt;!-- 新窗口打开网页 --&gt;&lt;a href=&quot;https://baidu.com&quot; target=&quot;_blank&quot;&gt;百度&lt;/a&gt;&lt;!-- 链接到同目录下另一个 html 文件 --&gt;&lt;a href=&quot;another.html&quot;&gt;HTML&lt;/a&gt;&lt;!-- 页面书签 --&gt;&lt;a name=&quot;label&quot;&gt;看这里&lt;/a&gt;&lt;a href=&quot;#label&quot;&gt;书签&lt;/a&gt;&lt;!-- 页面书签：利用元素id属性实现 --&gt;&lt;p id=&quot;label&quot;&gt;看这里&lt;/p&gt;&lt;a href=&quot;#label&quot;&gt;书签&lt;/a&gt;&lt;!-- 特别的：假如浏览器找不到已定义的命名锚，那么就会定位到文档的顶端，不会产生任何错误 --&gt;&lt;a href=&quot;#&quot;&gt;去顶部&lt;/a&gt;&lt;!-- # 可作为超链接路径占位符 --&gt;&lt;a href=&quot;#&quot;&gt;我是假的超链接&lt;/a&gt;&lt;!-- 也可用 javascript 方式占位 --&gt;&lt;a href=&quot;javascript:;&quot;&gt;我是假的超链接&lt;/a&gt;&lt;!-- 发送电子邮件：将用户的电子邮件程序打开来发送新邮件 --&gt;&lt;a href=&quot;mailto:nowhere@mozilla.org&quot;&gt;Send email to us.&lt;/a&gt; （2）图像标签&lt;img&gt;简介 图像标签可以用于向网页中嵌入一幅图像 属性 src 规定图片的 url 路径 alt 规定图片的描述 当图片无法加载时会显示 alt 属性内的描述 同时屏幕阅读器会将 alt 属性内的描述读给需要使用阅读器的使用者听，便于理解图像的含义 搜索引擎会根据 alt 中内容识别图片，不给出 alt 属性不会收录图片 空alt属性表明该图像不是内容的关键部分 建议：alt 属性的值应能够清晰、简洁地描述图像的内容而不仅仅是图片文件名或是用于体现图片的存在 width 及 height 指定图片的宽与高 图片实行的是等比例缩放 建议仅指定 width 和 height 属性中其一，不同时使用，否则可能会扭曲图片的比例 建议仅使用像素px作为图片标签的单位，不推荐使用百分比作为图片标签的单位 可以用CSS的width属性和height属性替代 decoding 规定图片的解码方式 sync 同步解码图片，会阻碍其他内容的显示，可能会导致页面渲染时间增长 async 异步解码图片，不会阻碍其他内容显示 auto 浏览器自动决定 【默认值】 importance 规定图片加载时的优先级 high 规定图片加载优先级较高 low 规定图片加载优先级较低，图片可能会延后显示 auto 图片加载优先级由浏览器自动决定 【默认值】 loading 规定图片的加载方式 eager 立即加载图片 【默认值】 lazy 延迟加载图片，直至其与浏览器视窗接近一定距离再开始显示，可以加快网页页面的显示 图片格式 jpeg（jpg） 支持颜色比较丰富，不支持透明效果，不支持动图 一般用来显示照片 gif 支持的颜色比较少，支持简单透明，支持动图 颜色单一的图片，动图 png 支持颜色丰富，支持复杂透明，不支持动图 颜色丰富、复杂透明图片（转为网页而生） webp 新推出的专用于表示网页中表示图片的格式，具备其他图片格式的所有优点，而且图片特别小 缺点：兼容性较弱（IE 等） （3）音频标签&lt;audio&gt;简介 用于向当前页面嵌入一个外部音频文件 属性 src 音频的 url 路径 controls 规定向用户提供显示控制元件，比如播放按钮 唯一合法取值 controls loop 规定音频应循环播放 唯一合法取值 loop autoplay 规定音频应自动播放，无需等待整个音频文件加载完成 唯一合法取值 autoplay muted 规定音频是否静音 默认取值为 false，即不静音；true 代表静音 preload 建议音频的加载方式 none 提示浏览器无需缓存音频 metadata 提示浏览器获取音频元信息但不加载 auto 提示浏览器需缓存音频 空字符串 等效于auto属性 其他 可以在开始标签和结束标签之间放置文本内容，这样老的浏览器就可以显示出不支持该标签的信息 123456789101112&lt;!-- 常规用法 --&gt;&lt;audio src=&quot;someaudio.wav&quot; controls=&quot;controls&quot; autoplay=&quot;autoplay&quot; loop=&quot;loop&quot;&gt; 您的浏览器不支持 audio 标签&lt;/audio&gt;&lt;!-- 考虑音频文件兼容性的写法 --&gt;&lt;!-- 仅做了解即可 --&gt;&lt;audio controls=&quot;controls&quot; height=&quot;100&quot; width=&quot;100&quot;&gt; &lt;source src=&quot;song.mp3&quot; type=&quot;audio/mp3&quot; /&gt; &lt;source src=&quot;song.ogg&quot; type=&quot;audio/ogg&quot; /&gt; &lt;embed height=&quot;100&quot; width=&quot;100&quot; src=&quot;song.mp3&quot; /&gt;&lt;/audio&gt; （4）视频标签&lt;video&gt;简介 用于向当前页面引入一个外部视频文件，也可以用来引入一个外部音频文件（但建议使用 audio 标签） 属性 src 规定视频 url 路径 controls 规定向用户显示控制元件，比如播放按钮 唯一合法取值 controls loop 规定视频循环播放 唯一合法取值 loop autoplay 规定视频应自动播放，无需等待缓存完成 唯一合法取值 autoplay width height 规定视频播放器宽度及高度 单位是像素 推荐在使用&lt;video&gt;标签时都规定视频播放器的高度和宽度 muted 规定视频是否默认静音 默认取值为 false，即不静音；true 代表静音 poster 规定视频的海报帧，默认未指定时使用视频的第一帧替代 preload 建议视频的加载方式 none 提示浏览器无需缓存视频 metadata 提示浏览器获取视频元信息但不加载 auto 提示浏览器需缓存视频 空字符串 等效于auto属性 其他 可以在开始标签和结束标签之间放置文本内容，这样老的浏览器就可以显示出不支持该标签的信息 12345678910111213&lt;!-- 建议用法 --&gt;&lt;video src=&quot;movie.ogg&quot; controls=&quot;controls&quot;&gt;您的浏览器不支持 video 标签。&lt;/video&gt;&lt;!-- 考虑兼容 IE 8 --&gt;&lt;!-- 仅做了解即可 --&gt;&lt;video width=&quot;320&quot; height=&quot;240&quot; controls=&quot;controls&quot;&gt; &lt;source src=&quot;movie.mp4&quot; type=&quot;video/mp4&quot; /&gt; &lt;source src=&quot;movie.ogg&quot; type=&quot;video/ogg&quot; /&gt; &lt;source src=&quot;movie.webm&quot; type=&quot;video/webm&quot; /&gt; &lt;object data=&quot;movie.mp4&quot; width=&quot;320&quot; height=&quot;240&quot;&gt; &lt;embed src=&quot;movie.swf&quot; width=&quot;320&quot; height=&quot;240&quot; /&gt; &lt;/object&gt;&lt;/video&gt; 2. 表格（1）表格简介表格由 &lt;table&gt; 标签来定义。每个表格均有若干行（由 &lt;tr&gt; 标签定义），每行被分割为若干单元格（由 &lt;td&gt; 标签定义）。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等 1234567891011&lt;!-- 一个简单的表格示例 --&gt;&lt;table&gt; &lt;tr&gt; &lt;td&gt;row 1, cell 1&lt;/td&gt; &lt;td&gt;row 1, cell 2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row 2, cell 1&lt;/td&gt; &lt;td&gt;row 2, cell 2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 效果如图 （2）&lt;th&gt; 标签表格的表头单元格使用 标签进行定义 一般表头会显示为粗体居中的文本 （3）合并单元格colspan 属性规定单元格可横跨的列数 rowspan 属性规定单元格可横跨的行数 以上两个属性具有最大值 65534，超出的值会自动当作 65534 处理 （4）&lt;caption&gt; 标签&lt;caption&gt; 标签用于定义表格标题 &lt;caption&gt; 标签必须紧随 table 标签之后。只能对每个表格定义一个标题，通常标题会居中于表格主体内容之上 （5）空单元格问题如果某个单元格是空的（没有内容），部分浏览器可能无法显示出这个单元格的边框，为此可以在空单元格中添加一个空格占位符从而避免这种状况出现 1234567891011121314151617181920&lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;th1&lt;/th&gt; &lt;th&gt;th2&lt;/th&gt; &lt;th&gt;th3&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row 1, cell 1&lt;/td&gt; &lt;td&gt;row 1, cell 2&lt;/td&gt; &lt;td&gt;row 1, cell 3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;row 2, cell 1&amp;2&lt;/td&gt; &lt;td rowspan=&quot;2&quot;&gt;row 2&amp;3, cell 3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row 3, cell 1&lt;/td&gt; &lt;td&gt;row 3, cell 2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; （6）&lt;thead&gt;标签及&lt;tbody&gt;标签及&lt;tfoot&gt;标签这些标签常作为语义化标签 &lt;thead&gt;标签定义表格的列首行&lt;tbody&gt;标签定义表格的内容主体行&lt;tfoot&gt;标签定义表格的汇总行 3. 列表（1）无序列表无序列表是一个项目的列表，列表项使用粗体圆点进行标记无序列表使用 &lt;ul&gt; 标签定义，各列表项使用 &lt;li&gt; 定义 type 规定无序列表的序号类型 注意：不推荐使用该 HTML 属性，而是建议使用 CSS 的 list-style-type 属性替代 12345&lt;ul&gt; &lt;li&gt;结构&lt;/li&gt; &lt;li&gt;表现&lt;/li&gt; &lt;li&gt;行为&lt;/li&gt;&lt;/ul&gt; （2）有序列表有序列表也是一列项目，列表项目使用数字进行标记有序列表使用 &lt;ol&gt; 标签定义，各列表项使用 &lt;li&gt; 标签定义以下属性是 &lt;ol&gt; 标签的 HTML 属性 reversed 规定有序列表的项是否反向排列，即序号自大而小排列 start 规定有序列表的起始项的序号，默认值是 1 type 规定有序列表的序号的种类，默认值是 1 a 表示小写英文字母编号 A 表示大写英文字母编号 i 表示小写罗马数字编号 I 表示大写罗马数字编号 1 表示数字编号 注意：不推荐使用该 HTML 属性，而是建议使用 CSS 的 list-style-type 属性替代以下属性是 &lt;li&gt; 标签在&lt;ol&gt; 标签内可选的 HTML 属性 value 规定项的序号，只允许使用数字，其后的项会从设置的该项的序号开始计数 12345&lt;ol&gt; &lt;li&gt;结构&lt;/li&gt; &lt;li&gt;表现&lt;/li&gt; &lt;li&gt;行为&lt;/li&gt;&lt;/ol&gt; （3）自定义列表自定义列表不仅仅是一列项目，而是项目及其注释的组合自定义列表使用 &lt;dl&gt; 标签定义，各自定义列表项使用 &lt;dt&gt;定义 ，各自定义列表项的定义使用&lt;dd&gt; 定义 12345&lt;dl&gt; &lt;dt&gt;结构&lt;/dt&gt; &lt;dd&gt;结构表示网页结构&lt;/dd&gt; &lt;dd&gt;规定网页中哪里是标题，哪里是段落&lt;/dd&gt;&lt;/dl&gt; （4）列表的使用实际用的时候直接用列表原生样式比较少（由于样式比较简陋）使用时更主要是使用其代表的结构和语义其中无序列表用的比较多，多用于网页导航栏（nav），或者侧边栏等地方；自定义列表可以实现下拉框另外，列表允许互相嵌套 4. 表单HTML 表单用于收集不同类型的用户输入并发送给服务器 （1）&lt;form&gt; 标签&lt;form&gt; 标签用于为用户输入创建 HTML 表单 建议：所有的表单元素都应当包含于&lt;form&gt; 标签内 name 属性 规定表单的名称 该属性的值必须是独有的值且不能是空字符串 另外，只有设置了 name 属性的表单元素才能在提交表单时传递它们的值，所以一般收集信息的_表单元素_都应设置 name 属性 action 属性 规定当提交表单时，向何处发送表单数据，即发送信息的目标服务器的 URL method 属性 规定如何发送表单数据，即HTTP 请求方法 取值：’post’ 或 ‘get’等 target 属性 规定在提交表单信息后如何显示响应信息 _self 在当前的浏览上下文加载 _blank 在新的浏览上下文加载 autocomplete属性 建议浏览器是否应自动补全表单元素内容 on 开启 off 关闭 该属性的效果取决于浏览器如何处理该属性 novalidate属性 规定浏览器提交表单前是否应验证表单元素内容的合法性 唯一取值为 novalidate （2）表单输入元素&lt;input&gt; 标签用于搜集用户信息 根据不同的 type 属性值，输入字段可以拥有非常非常多样的形式 type 属性 规定 input 元素的类型 （以下标粗的是推荐掌握的） button 定义按钮（通常用于通过 JavaScript 启动脚本） checkbox 定义复选框 file 定义输入字段和 “浏览”按钮，用于文件上传 hidden 定义隐藏的输入字段 image 定义图像形式的提交按钮 password 定义密码字段，该字段中的字符会被掩码 radio 定义单选按钮 reset 定义重置按钮（会清除表单中的所有数据） submit 定义提交按钮（会把表单数据发送到服务器） text 定义单行的输入字段，用户可在其中输入文本，默认宽度为 20 个字符 number 定义输入数字的控件 range 定义输入数字的滚动条 tel 定义输入电话号码的控件 email 定义输入电子邮件地址的控件 url 定义输入 url 的控件 color 定义指定颜色的控件 month 定义输入日期-年月的控件 date 定义输入日期-年月日的控件 datetime-local 定义输入日期时间的控件 time 定义输入时间的控件 week 定义输入日期-年与周数的控件 search 定义用于搜索字符串的单行文字区域 value 属性 规定 input 元素的值，对不同的 input 元素会有不同的效果 disabled 属性 规定 input 元素是否可使用 placeholder 属性 规定 input 元素输入为空且未获得焦点时控件显示的内容 spellcheck 属性 规定是否应检测输入的拼写语法 required 属性 规定 input 元素是必须的且应检查值的合法性 （仅对 password, search, tel, text, url 有效） checked 属性 规定 input 元素是否初始时应被选中 （仅对 radio、checked 有效） autofocus 属性 规定 input 元素在加载后自动聚焦 autocomplete 属性 建议 input 元素应使用自动填充功能 multiple 属性 规定可选择多个选项 （仅对 email file 有效）更多 input 元素的 HTML 属性，可以参考 链接 （3）下拉列表&lt;select&gt; 标签用于定义下拉列表 列表选项应使用 &lt;option&gt; 元素定义，通常会把首个选项显示为被选选项，但可以通过对特定的 &lt;option&gt; 元素添加 selected 属性来定义预定义选项select 标签拥有 autocomplete、autofocus、disabled、multiple、required 等属性 option 标签拥有 disabled、value 等属性，其中若 value 属性未指定值则默认是元素的文本内容 12345&lt;select name=&quot;pets&quot; id=&quot;pet-select&quot;&gt; &lt;option value=&quot;&quot;&gt;--Please choose an option--&lt;/option&gt; &lt;option value=&quot;dog&quot;&gt;Dog&lt;/option&gt; &lt;option value=&quot;cat&quot;&gt;Cat&lt;/option&gt;&lt;/select&gt; （4）文本域&lt;textarea&gt; 标签定义多行输入字段（即文本域） autocomplete、autofocus、disabled、value 等属性 cols 属性 和 rows 属性规定文本可见宽度及高度，推荐使用 CSS 选择器替代 （5）按钮&lt;button&gt; 标签定义可点击的按钮 type属性 规定 button 的类型 取值可为：button reset submit autocomplete、autofocus、disabled、maxlength、minlength、placeholder、required、value 等属性 效果同相同type属性取值的 &lt;input&gt; 标签，但可以在 button 标签内放置更多的元素因而可以有更加多样的样式表现 注意：请始终应为按钮规定 type 属性，因为其默认值在不同浏览器中不同 （6）&lt;label&gt; 标签 标签为 input 元素定义标注 当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上 标签的 for 属性应当与相关元素的 id 属性相同 1234567891011121314151617181920212223242526272829303132&lt;!-- 参考代码 --&gt;&lt;form method=&quot;post&quot; action=&quot;#&quot; name=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;text&quot; maxlength=&quot;25&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;radio&quot; name=&quot;radio&quot; checked /&gt;r &lt;br /&gt; &lt;input type=&quot;checkbox&quot; name=&quot;checkbox&quot; /&gt;c1 &lt;br /&gt; &lt;input type=&quot;checkbox&quot; name=&quot;checkbox&quot; /&gt;c2 &lt;br /&gt; &lt;input type=&quot;button&quot; value=&quot;按钮&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;reset&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; accept=&quot;image/jpg&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;image&quot; name=&quot;image&quot; src=&quot;https://www.xidian.edu.cn/__local/C/BD/8E/B4E1319F602F3F83CF5538DDABD_CA336AC2_43244.jpg&quot; alt=&quot;&quot; width=&quot;100&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;hidden&quot; /&gt; &lt;br /&gt; &lt;hr /&gt; &lt;select name=&quot;select&quot;&gt; &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;3&quot; selected&gt;3&lt;/option&gt; &lt;/select&gt; &lt;br /&gt; &lt;textarea name=&quot;textarea&quot; placeholder=&quot;...&quot; cols=&quot;20&quot; rows=&quot;20&quot;&gt;&lt;/textarea&gt; &lt;br /&gt;&lt;/form&gt; 参考效果 5. 内联框架iframe 用于在网页内嵌入另外一个网页 1&lt;iframe src=&quot;URL&quot;&gt;&lt;/iframe&gt; src 属性 设置内联网页的 url width 属性 和 height 属性 设置内联框架的宽度和高度 实际使用内联框架情况比较少见，常常是用来引用 bilibili 播放器等开放资源，如 123456789&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=422093073&amp;bvid=BV1J3411475Q&amp;cid=453689337&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt;&lt;/iframe&gt;","link":"/2022/07/29/html-2/"},{"title":"es6","text":"ES6 标准入门2022.03.22No.1 let 与 const 具有块状作用域，仅在声明的代码块内可使用 不存在变量提升现象 仅可在变量声明后使用，声明之前不可使用，即暂时性死区（TDZ）现象 不允许重复声明 const 声明常量，且需立即初始化 原理可以认为是在声明仍会提到块顶部创建变量区域，但会阻止在声明位置后的使用 for 循环的条件部分可视为父作用域，循环体部分可视为子作用域 块作用域 内层作用域可以覆盖外层作用域的变量 外层作用域无法使用内层作用域的变量 函数声明在块作用域的行为类似于 var（浏览器） 顶层对象globalThis 浏览器：window Node：global var 命令与 function 命令声明全局变量是顶层对象属性 let 命令、const 命令与 class 命令声明的不是顶层对象属性 解构赋值 数组 let [a, [b], c = true, ...d] = [1, [2], 3, 4, 5, 6]4a = 1 b = 2 c = 3 d = [4, 5, 6] 根据数组的位置提取值，匹配不到返回 undefined允许默认值，仅 undefined 会起效相当于模式匹配 应为可遍历结构（包含数组、Set 实例） 对象 变量应与对象属性同名取值没有次序 let { log: loge, sin, cos } = Math; 允许重命名变量 2022.03.23No.2 PromisePromise 含义promise 语法上来说是一个对象，它保存了一个未来才会结束的事件的结果，可以用于获取异步操作的结果，是用于异步编程的一种常用的强大的工具，可以解决“回调地狱”问题 promise 对象具有三种状态：pending进行中、fulfilled已成功、rejected已失败，它的状态仅由异步执行的结果决定 promise 对象状态改变只能为 pending-&gt;fulfilled 和 pending-&gt;rejected，且状态改变一旦发生，就无法改变，会一直保持这个结果 promise 对象创建后即无法取消，pending 状态时无法得知事件进展，无法在未设置回调函数时捕获错误 new Promise()1234567const promise = new Promise(function(resolve, reject) { if(/*success*/) { resolve(result); } else { reject(error); }}); promise 对象一旦新建就会立即执行promise 对象接受一个函数作为参数，该函数参数分别为 resolve 和 reject，它们都可以根据需要接收参数，并包装成 Promise 对象返回（若已是 Promise 对象则直接返回）resolve 函数将 promise 对象状态从 pending 改变为 fulfilledreject 函数将 promise 对象状态从 pending 改变为 rejected Promise.prototype.then()12345678promise.then( function (result) { // do something when success }, function (error) { // do something when fail }); then 方法指定 promise 对象的处理回调函数，接收两个方法作为参数，第一个方法处理 fulfilled 状态的回调函数，第二个方法处理 rejected 状态的回调函数，两个方法都是可选的then 方法返回一个新的 Promise 实例，因此 Promise 可以具有链式写法，链式的 then 方法会依次调用 Promise.prototype.catch()相当于 .then(null | undefined, rejection) 指定 Promise 返回错误时的回调函数，包括异步操作抛出错误引起状态改变为 rejected 和回调函数运行时抛出的错误 1234promise.catch((error) =&gt; { // do something to deal with the error console.log(error);}); 一般建议不在 then 方法内定义错误的处理方法，而是统一在最后的 catch 方法统一处理（也比较符合 try-catch 语句的写法） 处理完成后返回的 Promise 实例的状态会重置为 fulfilled Promise.prototype.finally()finally 方法绑定无论 fulfilled 状态还是 rejected 状态都会执行的方法 ES2018 引入 123promise.finally(() =&gt; { // do something to deal with the error}); 该方法无法接收参数实质为 then 方法的特例 2022.03.26No.3 Promise.resolve()返回一个 Promise 实例 参数是 Promise 实例 ：直接返回，不做修改 参数具有 then() 方法 ：转为 Promise 实例并立即调用 then() 方法 参数不具有 then() 方法 ：返回一个 fulfilled 状态的 Promise 实例 无参 ：返回一个 fulfilled 状态的 Promise 实例 Promise.reject()返回一个 rejected 状态下的 Promise 实例 Promise.all()const promiseAll = Promise.all([promise1, promise2]); 该方法将多个 Promise 实例合并为一个新的 Promise 实例以数组形式接收需包装的 Promise 实例，若接收到非 Promise 实例参数会自动转为 Promise 实例 若所有 Promise 实例状态均变成 fulfilled，包装后的新 Promise 实例状态才会变成 fulfilled 反之有任一一个 Promise 实例状态变成 rejected，包装后的新 Promise 实例状态即会变成 rejected 需要注意的是，Promise 实例的 catch 方法会阻碍装后的新 Promise 实例 catch 方法的错误捕获 12345Promise.all([p1, p2]) .then(([pp1, pp2]) =&gt; { // do something with pp1 &amp; pp2 }) .catch(console.error); Promise.race()语法及参数返回值格式同 all 若有一个 Promise 实例状态均变成 fulfilled，包装后的新 Promise 实例状态就会变成 fulfilled 反之若所有的 Promise 实例状态变成 rejected，包装后的新 Promise 实例状态才会变成 rejected Promise.allSettled()语法及参数返回值格式同 all 类似 all 方法 仅在所有 Promise 实例状态变更后才发生状态变更 ES2020 引入 1234567Promise.allSettled([p1, p2]).then((res) =&gt; { // res: // [ // { status: 'fulfilled', value: 42 }, // { status: 'rejected', reason: -1 } // ]}); res 是对象数组，均具有 status 属性代表 Promise 实例的状态；fulfilled 状态具有 value 属性，rejected 状态具有 reason 属性，分别代表 Promise 实例操作的返回值 Promise.any()语法及参数返回值格式同 all 类似 race 与 allSettled 方法 仅在所有 Promise 实例状态变更后才发生状态变更 ES2021 引入 error 是 AggregateError 实例数组，代表各 Promise 实例的错误信息 2022.03.27No.4 Generator 函数Generator Generator 函数是一个状态机，封装了多个内部状态 执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数还是一个遍历器对象生成函数 返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态（通过 yield 定义） 123456789101112131415function* helloWorldGenerator() { yield &quot;hello&quot;; yield &quot;world&quot;; return &quot;ending&quot;;}let hw = helloWorldGenerator();hw.next();// { value: 'hello', done: false }hw.next();// { value: 'world', done: false }hw.next();// { value: 'ending', done: true }hw.next();// { value: undefined, done: true } 调用 Generator 函数时会返回一个遍历器 Iterator 对象实例 每次调用返回的 Iterator 对象实例的 next() 方法时从函数头部或上次停止位置开始执行，直至遇到下一个 yield 表达式或 return 语句为止 每次调用 next() 方法返回的是一个对象，具有 done 属性，表示 Iterator 是否执行完毕；具有 value 属性，代表 yield 后的表达式或 return 后的表达式值（惰性求值） yield 若 Generator 函数不使用 yield，相当于单纯的暂缓执行函数 关键字 yield 只能使用在 Generator 函数内 若 yield 在表达式内使用需加小括号console.log('y' + (yield 'eah')) next() next() 方法可以带一个参数，会给出上一个 yield 表达式的返回值（因此第一次 next() 方法参数无效，可以理解是因为第一次调用 next() 方法会启动遍历器） for-of 可以使用 for-of 循环遍历 Generator 函数运行时生成的 Iterator 对象，且无需调用 next() 方法 特别的， for-of 循环不会返回 return 语句的表达式值 可以应用于遍历任意对象 1234for (let v of hw()) { console.log(v);}// 'hello' 'world' 'ending' throwGenerator 函数运行时生成的 Iterator 对象可以调用 throw 方法，在函数体外抛出错误并可被函数体内的 try-catch 块捕获hw().throw(); returnGenerator 函数运行时生成的 Iterator 对象可以调用 return 方法结束 Generator 函数执行，返回值是 return 的参数hw().return(); next &amp; throw &amp; return next 方法将 yield 表达式替换成一个值 throw 方法将 yield 表达式替换成一个 throw 语句 return 方法将 yield 表达式替换成一个 return 语句 2022.03.28No.5 yield*用于在 Generator 函数内执行另一个 Generator 函数 12345678910function* bar() { yield &quot;x&quot;; yield* foo(); /** * for (let v of foo()) { * yield v; * } */ yield &quot;y&quot;;} 语法上认为 yield* 表达式用于声明返回的是一个遍历器对象且是希望被遍历的，实际效果相当于一个 for-of 循环 可以利用 yield* 取出嵌套数组的所有成员 123456789function* iterTree(tree) { if (Array.isArray(tree)) { for (let i = 0; i &lt; tree.length; i++) { yield* iterTree(tree[i]); } } else { yield tree; }} Generator 函数的 函数对象属性可简写为 12345let obj = { *myGeneratorMethod() { // do something },}; Generator 函数的 thisGenerator 函数 g 返回的遍历器 obj，是 g 的实例，而且继承了 g.prototype Generator 函数无法被用作构造函数，即在 Generator 函数内部利用 this 添加属性无法起效 Generator 函数无法被 new 使用 状态机&amp;协程&amp;上下文可以使用 Generator 函数实现状态机 12345678var clock = function* () { while (true) { console.log(&quot;Tick!&quot;); yield; console.log(&quot;Tock!&quot;); yield; }}; Generator 函数是一个半协程的函数，即只有 Generator 函数的调用者，才能将程序的执行权还给 Generator 函数 Generator 函数的上下文在暂停时会暂时退出堆栈但会冻结在当前状态，启动执行时会再次加入调用栈回复执行 Generator 与异步1234567891011121314151617// 封装异步常规方法var fetch = require(&quot;node-fetch&quot;);function* gen() { var url = &quot;https://api.github.com/users/github&quot;; var result = yield fetch(url); console.log(result.bio);}var g = gen();var result = g.next();// 介于 fetch 模块返回 promise 对象实例result.value .then(function (data) { return data.json(); }) .then(function (data) { g.next(data); }); 2022.03.29No.6 async awaitasync let a function return a promise, await let a expression wait for a promise async 函数是 Generator 函数的语法糖 内置执行器，无需像 Generator 函数一样调用 next 方法 语义清晰化，async 表明函数内含异步操作，await 表明其后的表达式需等待结果 适用性更广，允许 Promise 对象和原始状态的值 async 函数返回 Promise 对象 async 函数内部遇到 await 会先返回一个 Promise 对象，当 await 后的异步操作完成时，才会继续执行函数体后面的语句 await 命令遇到非 promise 对象会直接返回对应的值await 命令后的 promise 对象变为 rejected 状态，所在的整个 async 函数都会终止执行 建议将 await 命令放在 try-catch 代码块中 1234567async function myFunction() { try { await somethingThatReturnsAPromise(); } catch (err) { console.log(err); }} 可以让多个并发的异步任务使用 Promise.all 进行包装 1let [foo, bar] = await Promise.all([getFoo(), getBar()]); await 命令只能在 async 函数内使用 async 函数可以保留运行堆栈，错误信息不会被遗漏 Iterator简介Iterator 为各种不同的数据结构（部署了 Iterator 接口）提供了统一的访问接口 Iterator 遍历时，首先创建一个指向当前数据结构起始位置的指针对象，随后调用指针对象的 next 方法，依次访问数据结构的各个成员，直至指向数据结构的结束位置 每次遍历返回一个对象，包含 value 属性和 done 属性（同 Generator 函数） Iterator 接口部署在 Symbol.iterator 属性上，其亦是判断是否可遍历的标准 原生 Iterator 接口数据结构有 Array、Map、Set、String、函数的 arguments 对象、NodeList 对象 12345// 使用数组的 iteratorlet iter = [1, 2][Symbol.iterator]();iter.next(); // { value: 1, done: false }iter.next(); // { value: 2, done: false }iter.next(); // { value: undefined, done: true } 调用 解构赋值（数组、Set） 扩展运算符 … yield* 数组遍历 for…of、Array.from()、Map()、Set()、WeakMap()、WeakSet()、Promise.all()、Promise.race() 实现123456789// 使用 Generator 函数let myIterable = { [Symbol.iterator]: function* () { yield 1; yield 2; yield 3; },};[...myIterable]; // [1, 2, 3] return 与 throw 方法 return 遍历提前结束时调用，如 break 或 Error 发生 throw 配合 Generator 函数使用 for - of可以遍历任意具有 Symbol.iterator 的对象或对象实例 123for (let v of [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]) { console.log(v); // red green blue} for-in 循环获取对象的键名 for-of 循环获取对象的键值 遍历的对象方法 Object.entries() 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组 Object.keys() 返回一个遍历器对象，用来遍历所有的键名 Object.values() 返回一个遍历器对象，用来遍历所有的键值 2022.03.30No.7 字符串扩展字符串 Unicode 表示更新1234&quot;\\u{20BB7}&quot;;// &quot;𠮷&quot;&quot;\\u{41}\\u{42}\\u{43}&quot;;// &quot;ABC&quot; 字符串遍历器接口可以识别大于 0xFFFF 的码点而不是分开识别 123for (let c of &quot;foo&quot;) { console.log(c);} 模板字符串使用反引号标识字符串 可以定义多行字符串 可以在字符串内嵌入变量乃至表达式及函数 会保留多行字符串内部的空格和缩进 内部使用反引号需转义 1`${x} + ${y} = ${x + y}`; 标签模板相当于向函数传入一个特殊的模板字符串数组，其具有 raw 属性，代表转义后的原字符串 123456789// 两者等价alert`hello`;alert([&quot;hello&quot;]);let a = 5, b = 10;tag`Hello ${a + b} world ${a * b}`;// 等同于tag([&quot;Hello &quot;, &quot; world &quot;, &quot;&quot;], 15, 50); 可以用于过滤 HTML 字符串，防止用户输入恶意内容（过滤 &lt; &gt; &amp; 等特殊字符）可用于多语言转换 字符串新增方法 includes(SearchString, [StartIndex]) 表示是否找到参数字符串 startsWith(SearchString, [StartIndex]) 表示参数字符串是否在原字符串头部 endsWith(SearchString, [StartIndex]) 表示参数字符串是否在原字符串尾部 方法均返回布尔值方法均支持第二个参数，代表开始搜索的位置 repeat(RepeatCount) 将给定字符串重复指定的次数 参数应为有限的正整数小数会取整0 会返回空串负数及 Infinity 会报错NaN 等价于 0 padStart() 用于头部补全 padEnd() 用于尾部补全 ES2017 引入 第一个参数指定补全后字符串的长度第二个参数指定用于补全的字符串，默认为一个空格 原字符串长度超出指定的长度，不起效补全用字符串与原字符串长度之和超出最大长度会截取补全用的字符串 常用于为数值补全指定位数，或用于提示字符串格式 trimStart() 消除字符串头部空格，浏览器中同 trimLeft() trimEnd() 消除字符串尾部空格，浏览器中同 trimRight() matchAll() 返回正则表达式在当前字符串的所有匹配 replaceAll(searchValue, replacement) 替换字符串中所有的匹配到的字符串 searchValue 可以为字符串或带g修饰符的正则表达式 12345678910111213141516171819202122232425262728// $&amp; 表示匹配的字符串，即`b`本身// 所以返回结果与原字符串一致&quot;abbc&quot;.replaceAll(&quot;b&quot;, &quot;$&amp;&quot;);// 'abbc'// $` 表示匹配结果之前的字符串// 对于第一个`b`，$` 指代`a`// 对于第二个`b`，$` 指代`ab`&quot;abbc&quot;.replaceAll(&quot;b&quot;, &quot;$`&quot;);// 'aaabc'// $' 表示匹配结果之后的字符串// 对于第一个`b`，$' 指代`bc`// 对于第二个`b`，$' 指代`c`&quot;abbc&quot;.replaceAll(&quot;b&quot;, `$'`);// 'abccc'// $1 表示正则表达式的第一个组匹配，指代`ab`// $2 表示正则表达式的第二个组匹配，指代`bc`&quot;abbc&quot;.replaceAll(/(ab)(bc)/g, &quot;$2$1&quot;);// 'bcab'// $$ 指代 $&quot;abc&quot;.replaceAll(&quot;b&quot;, &quot;$$&quot;);// replacement可以是一个函数&quot;aabbcc&quot;.replaceAll(&quot;b&quot;, () =&gt; &quot;_&quot;);// 'aa__cc' at() 选取字符串指定位置的字符，允许负索引 2022.03.31No.8 数值表示方法 二进制 0b11 八进制 0o11 转为十进制可使用 Number() 方法 数值分隔符特点 允许数值使用 _ 作为分隔符 分隔符之间没有指定间隔的位数 12_34_56 12_345_567 允许应用于小数与指数 0.123_21 1e1_234 允许应用于其他进制的数值 注意点 数值分隔符无法放在数值最前面或最后面 数值分隔符不能连在一起使用 小数的小数点前后不能有分隔符 指数的 e 符号前后不能有分隔符 进制前缀后不能加分隔符 字符串转数值函数不支持数值分隔符 Number('123_456') // NaN parseInt('123_456') // 123 Number 对象新增方法 Number.isFinite()检测数值是否为有限的 数值为 ±Infinity 或 NaN 返回 false，其他返回 true 非数值一律返回 false Number.isNaN()检测数值是否为 NaN 仅 NaN 返回 true，其他均为 false 与传统的全局方法 isFinite()和 isNaN()的区别，对于非数值类型，全局方法会调用 Number()方法转换再比较，而 Number 对象方法一律直接返回 false Number.parseInt() Number.parseFloat()将数值转换为整数与浮点数使用与相应的全局方法相同 Number.isInteger()判断数值是否为整数若数值的小数部分过小，可能会发生误判非数值一律返回 false Number.EPSILON代表 js 所能够表示的最小精度数，实质是可接受的最小误差范围两个浮点数的差小于该数时，可以认为两浮点数相等 Number.MAX_SAFE_INTEGER 2^53-1 Number.MIN_SAFE_INTEGER -(2^53-1)表示 js 能够精确表示的整数的范围 Number.isSafeInteger()检测数值是否为能够精确表示的非数值或非整数一律返回 false 2022.04.01No.9 Math 对象新增方法大多数非数值参数会先调用 Number() 方法尝试转换 Math.trunc()对浮点数执行取整操作，去除小数部分空值或无法转为整数的值返回 NaN Math.sign()判断数值的符号 正数返回 +1 负数返回 -1 0 返回 0 -0 返回-0 其他返回 NaN Math.cbrt()计算数值的立方根 Math.clz32()“count leading zero bits in 32-bit binary representation of a number”将参数转为 32 位无符号整数形式，并返回 32 位数的前导 0 的个数小数只会考虑整数部分Math.clz32(0) // 32Math.clz32(1) // 31Math.clz32(1000) // 22Math.clz32(0b01000000000000000000000000000000) // 1Math.clz32Math.clz32(3.2) // 30 Math.imul()返回两数以 32 位有符号整数相乘的结果正常情况 Math.imul(a, b)与 a _ b 效果相同(0x7fffffff _ 0x7fffffff)|0 // 0 Math.imul(0x7fffffff, 0x7fffffff) // 1主要应用于获取大数相乘时的正确的低位数值 Math.fround()返回数的 32 位单精度浮点数形式绝对值超出 2^24 的数字会丢失精度Math.fround(0) // 0Math.fround(2 ** 24 - 1) // 16777215Math.fround(2 ** 24) // 16777216Math.fround(2 ** 24 + 1) // 16777216主要应用于将 64 位双精度浮点数转为 32 位单精度浮点数 Math.hypot()返回所有参数的平方和的平方根对于非数值类型参数，会先转为数值，若任一参数无法转换，即会返回 NaNMath.hypot(3, 4); // 5Math.hypot(); // 0Math.hypot(NaN); // NaNMath.hypot(3, 4, 'foo'); // NaNMath.hypot(-3); // 3 Math.log2()返回以 2 为底的 x 的对数 Math.log10()返回以 10 为底的 x 的对数 Math.log1p()返回 ln(1 + x) Math.expm1()返回 e^x - 1 Math.sinh(x)返回 x 的双曲正弦 Math.cosh(x)返回 x 的双曲余弦 Math.tanh(x)返回 x 的双曲正切 Math.asinh(x)返回 x 的反双曲正弦 Math.acosh(x)返回 x 的反双曲余弦 Math.atanh(x)返回 x 的反双曲正切 BigInt 类型 ES2020 引入 只能用于表示整数 可以表示任意位数的整数2172141653n * 15346349309n // 33334444555566667777n2172141653 * 15346349309 // 33334444555566670000 允许使用各种进制表示整数0b1101n // 二进制0o777n // 八进制0xFFn // 十六进制 通过后缀 n 声明整数1234 // 普通整数1234n // BigInt1n + 2n // 3n typeof 运算符返回 ‘bigint’typeof 123n // 'bigint' 可以使用-，不可以使用+-42n // CORRECT+42n // ERROR 可以使用 BigInt()将其他类型的值转换为 BigInt 类型的变量 BigInt.asUintN(width, BigInt)给定的 BigInt 转为 0 到 2^width - 1 之间对应的值。 BigInt.asIntN(width, BigInt)给定的 BigInt 转为 -2^(width-1) 到 2^(width-1) - 1 之间对应的值。 BigInt.parseInt(string[, radix])近似于 Number.parseInt()，将一个字符串转换成指定进制的 BigInt 大多数运算符，除&gt;&gt;&gt;与+外，均可应用于 BigInt 对象 2022.04.02No.10 数组扩展Array 对象新增方法 Array.from()将类数组对象(具有 length属性)及可遍历对象(具有 Iterator 接口)转为数组允许接受第二个参数即回调函数，作用类似 map 方法，对元素进行处理并放入返回的数组 转换各种值为数组 将字符串转为数组以判断字符串正确的长度 12345678let arr2 = Array.from({ 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3,}); // ['a', 'b', 'c']Array.from([1, 2, 3], (x) =&gt; x * x);// [1, 4, 9] Array.of()将一组值转换为数组Array.of(3, 11, 8) // [3,11,8] Array.prototype.copyWithin()将当前数组内部指定位置成员复制至其他位置并返回当前数组Array.prototype.copyWithin(target, start = 0, end = this.length) target 开始替换数据位置 start 开始读取数据位置 end 结束读取数据位置 [1, 2, 3, 4, 5].copyWithin(0, 3, 4) Array.prototype.find()传入一个回调函数，返回第一个符合条件的值 Array.prototype.findIndex()传入一个回调函数，返回第一个符合条件的值的下标 Array.prototype.includes()查找数组内是否包含指定的值 Array.prototype.fill()使用给定值填充一个数组new Array(3).fill(7) // [7, 7, 7]['a', 'b', 'c'].fill(7, 1, 2) // ['a', 7, 'c'] Array.prototype.entries() Array.prototype.keys() Array.prototype.values()keys()是对键名的遍历values()是对键值的遍历entries()是对键值对的遍历可以使用 for-of 循环 1234567891011121314151617for (let index of [&quot;a&quot;, &quot;b&quot;].keys()) { console.log(index);}// 0// 1for (let elem of [&quot;a&quot;, &quot;b&quot;].values()) { console.log(elem);}// 'a'// 'b'for (let [index, elem] of [&quot;a&quot;, &quot;b&quot;].entries()) { console.log(index, elem);}// 0 &quot;a&quot;// 1 &quot;b&quot; Array.prototype.flat()展平多维数组形成低维的数组默认展平一层可以传入一个数值或 Infinity，代表期望展平的层数[1, [2, [3]]].flat(Infinity) // [1, 2, 3] Array.prototype.flatMap()先对原数组各元素进行遍历后执行展平操作接受一个回调函数参数，只能展平一层 Array.prototype.at()根据数组下标获取元素允许负值 数组空位不同方法对数组空位的处理方法不同 forEach(), filter(), reduce(), every() 和 some()都会跳过空位 map()会跳过空位，但会保留这个值 join()和 toString()会将空位视为 undefined，最终被处理成空字符串 Array.from()方法与扩展运算符会将数组的空位，转为 undefined copyWithin()会连空位一起拷贝 fill()会将空位视为正常的数组位置 for…of 循环也会遍历空位 entries()、keys()、values()、find()和 findIndex()会将空位处理成 undefined 建议数组中不要出现空位 2022.04.05No.11 运算符扩展指数运算符 ** ES2016 右结合2 ** 3 ** 2 // 相当于 2 ** (3 ** 2) 指数赋值运算符 **=链判断运算符 ?. ES2020 从 const firstName = (message &amp;&amp; message.body &amp;&amp; message.body.user &amp;&amp; message.body.user.firstName) || 'default';到 const firstName = message?.body?.user?.firstName || 'default'; 在链式调用的时候判断左侧的对象是否为 null 或 undefined。如果是的，就不再往下运算，而是返回 undefined obj?.prop // 对象属性是否存在 obj?.[expr] // 同上 func?.(…args) // 函数或对象方法是否存在 空值合并运算符 ?? ES2020 只有运算符左侧的值为 null 或 undefined 时，才会返回右侧的值 逻辑赋值运算符 &amp;&amp;= ||= ??=可以用于为变量或属性设置默认值 从 opts.foo = opts.foo ?? 'bar';到 opts.foo ??= 'bar'; 对象 Object 新增方法Object.is()用来比较两个值是否严格相等基本类似 === 运算符 区别：+0 不等于-0 ； NaN 等于本身 Object.assign()用于对象合并，将源对象所有可枚举自身属性复制到目标对象 第一个参数是目标对象，剩余的参数是源对象 若只有第一个参数，会直接返回该对象若该参数不是对象，会转为对象再处理若该参数是 null 或 undefined 会报错若非对象参数是剩余参数，会尝试转为对象，若失败则忽略跳过（实际只有字符串能以字符数组合入）该方法只能拷贝源对象自身的可枚举属性，不能拷贝源对象继承属性，也不能拷贝不可枚举的属性 浅拷贝源对象的对象属性拷贝的是引用 替换同名属性对于同名属性，该方法会直接替换该属性而不是添加 取值函数对于 get 函数，该方法会先求值再复制，不会复制 get 函数 为对象添加属性 12345class Point { constructor(x, y) { Object.assign(this, {x, y}); },} 为对象添加方法 12345678Object.assign(SomeClass.prototype, { someMethod(arg1, arg2) { ··· }, anotherMethod() { ··· },}); 克隆对象 123function clone(origin) { return Object.assign({}, origin);} 合并多个对象 12const merge = (target, ...sources) =&gt; Object.assign(target, ...sources);const merge = (...sources) =&gt; Object.assign({}, ...sources); 指定属性默认值 12345678const DEFAULTS = { logLevel: 0, outputFormat: &quot;html&quot;,};function processContent(options) { options = Object.assign({}, DEFAULTS, options); // ...} 2022.04.06No.12 Object.getOwnPropertyDescriptors(Object) ES2017 引入 返回指定对象的所有非继承的自身属性的描述对象 12345678910111213141516171819202122Object.getOwnPropertyDescriptors({ foo: 123, get bar() { return &quot;abc&quot;; },});/** * { * foo: { * value: 123, * writable: true, * enumerable: true, * configurable: true, * }, * bar: { * get: [Function: get bar], * set: undefined, * enumerable: true, * configurable: true, * }, * } */ 可以用于配合 Object.defineProperties()方法方法正确拷贝对象（特别是对象的 get 和 set 属性） 配合 Object.create()方法，将对象属性克隆到一个新对象（浅拷贝） 实现对象之间的继承 __proto__ Object.setPrototypeOf() Object.getPrototypeOf()__proto__ 用于读取并设置对象的原型对象特别注意的是它仅规定在浏览器需要实现 Object.setPrototypeOf() Object.getPrototypeOf()分别用于设置和获取对象的原型对象不是对象的参数会自动转为对象 Object.keys() Object.values() Object.entries()Object.keys() 返回包含对象自身所有的非继承的可遍历的属性键名的数组Object.values() 返回包含对象自身所有的非继承的可遍历的属性键值的数组Object.entries() 返回包含对象自身所有的非继承的可遍历的属性键值对数组的数组 1234var obj = { foo: &quot;bar&quot;, baz: 42 };Object.keys(obj); // [&quot;foo&quot;, &quot;baz&quot;]Object.values(obj); // [&quot;bar&quot;, 42]Object.entries(obj); // [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ] Object.fromEntries()相当于 Object.entries() 的逆操作将一个键值对数组转为对象 1234Object.fromEntries([ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42],]); // { foo: &quot;bar&quot;, baz: 42 } 可以利用该方法与其逆方法实现map 数据结构与对象之间的相互转换 对象扩展属性的简洁表示方法可以在大括号里面，直接写入变量和函数，作为对象的属性和方法，此时属性名就是变量名，属性值就是变量值 1234const foo = &quot;bar&quot;;const baz = { foo,}; 方法的简洁表示方法12345const o = { method() { return &quot;Hello!&quot;; },}; get 与 set 的显示方法 123456789101112const cart = { _wheels: 4, get wheels() { return this._wheels; }, set wheels(value) { if (value &lt; this._wheels) { throw new Error(&quot;数值太小了！&quot;); } this._wheels = value; },}; 属性名表达式允许将变量值作为对象的属性名注意：默认会将非对象变量值转为字符串 12345let propKey = &quot;foo&quot;;let obj = { [propKey]: true, [&quot;a&quot; + &quot;bc&quot;]: 123,}; 2022.04.07No.13 方法的 name 属性 普通方法 方法名 普通对象方法 方法名 get set 对象方法 get|set+方法名 Function 构造函数方法 anonymous bind 方法 bound+方法名 Symbol 方法 Symbol 的描述 属性可枚举性与遍历对象属性描述对象对象的各属性均有一个相应的描述对象可以使用 Object.getOwnPropertyDescriptor() 方法获取属性的描述对象 enumerable属性属性 enumerable 用于描述对象属性是否可枚举 遍历方法 for…in 遍历对象自身的和继承的可枚举的非 Symbol 属性的属性 Object.keys(obj) 遍历对象自身的可枚举的非 Symbol 属性的属性 Object.getOwnPropertyNames(obj) 遍历对象自身的非 Symbol 属性的属性 Object.getOwnPropertySymbols(obj) 遍历对象自身的Symbol 属性的属性 Reflect.ownKeys(obj) 遍历对象自身的所有属性 遍历次序 首先遍历所有数值键，按照数值升序排列 其次遍历所有字符串键，按照加入时间升序排列 最后遍历所有Symbol键，按照加入时间升序排列 super 关键字指向当前对象的原型对象（只能用于对象的方法内，只能在对象方法的简写法可使用） 1234567891011121314151617181920// correctconst obj = { foo: &quot;world&quot;, find() { return super.foo; },};// errorconst obj = { foo: super.foo,};const obj = { foo: () =&gt; super.foo,};const obj = { foo: function () { return super.foo; },}; super.foo 原理上等同于 Object.getPrototypeOf(this).foo （属性）或 Object.getPrototypeOf(this).foo.call(this) （方法） 对象扩展运算符 ES2018 引入 对象的解构赋值12345let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };x; // 1y; // 2z; // { a: 3, b: 4 }/* ...必须为最后一个参数 */ 扩展运算符取出对象的所有可遍历属性并拷贝到当前对象内，也可以应用于合并对象 1234567let z = { a: 3, b: 4 };let n = { ...z };n; // { a: 3, b: 4 }let ab = { ...a, ...b };// 同名属性会依照出现的顺序被覆盖// 可以设置对象属性的默认值以及修改现有对象的属性 实际效果等同于使用 Object.assign()方法 AggregateError 错误对象 ES2021 引入 AggregateError 在一个错误对象里面，封装了多个错误 AggregateError(errors[, message])errors 以数组形式接收产生的错误对象（必须）message 以字符串形式接收抛出时的提示信息（可选）以上亦是对象实例的属性 123456789const error = new AggregateError( [ new Error(&quot;ERROR_11112&quot;), new TypeError(&quot;First name must be a string&quot;), new RangeError(&quot;Transaction value must be at least 1&quot;), new URIError(&quot;User profile link must be https&quot;), ], &quot;Transaction cannot be processed&quot;); 2022.04.09No.14 函数的扩展函数默认值12345678// 形参function f(a, b = 12) { /* ... */}// 解构赋值function g({ a, b = 1 }) { /* ... */} 形参默认声明，因而无法再次声明 不允许出现重名参数 参数默认值是惰性求值，即每次重新计算值 建议函数默认值放在末尾（不然为取到默认值，需要显式传参 undefined） 指定默认值的函数，length 属性表示未指定默认值的参数个数（非末尾参数的默认值后的参数不再计入）【length 属性指的是函数预期传入的参数个数】 1234// 双重默认值function fetch(url, { body = &quot;&quot;, method = &quot;GET&quot;, headers = {} } = {}) { /* ... */} 另外函数的形参部分运行时会生成一个独立的作用域 12345var x = 1;function f(x, y = x) { console.log(y);}f(2); // 2 可以利用默认值强制实现函数参数不可省略的特性 123function foo(mustBeProvided = () =&gt; throw new Error(&quot;Missing parameter&quot;)) { /* ... */} rest 参数用于搭配一个数组变量，获取函数多余的参数格式 ...变量名 函数的 length 属性，不包括 rest 参数 1const sortNumbers = (...numbers) =&gt; numbers.sort(); 另外，rest 参数必须为函数的最后一个参数 函数的严格模式可以在函数内部设定严格模式 但是若函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式 可以设定全局的严格模式规避 可以将函数包裹在无参数的立即执行函数内部 函数的 name 属性返回函数的函数名称 匿名函数会返回实际的函数名 Function 构造函数创建的函数返回 ‘anonymous’ bind 返回的函数返回的有 bind 前缀 箭头函数() =&gt; {} 尾调用优化函数式编程函数的返回调用另一个函数得到的结果（且应是函数的最后一步操作） 123function f(x) { return g(x);} 它可以提高性能节省内存，尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了 若尾调用自身，即尾递归优点在于不易发生栈溢出错误 123456789101112// 阶乘function factorial(n, total) { if (n === 1) return total; return factorial(n - 1, n * total);}// Fibonacci 数列function Fibonacci2(n, ac1 = 1, ac2 = 1) { if (n &lt;= 1) { return ac2; } return Fibonacci2(n - 1, ac2, ac1 + ac2);} 尾递归优化起效必须开启严格模式 函数参数尾逗号 ES2017 生效 允许函数最后一个参数出现逗号 Function.prototype.toString() 优化 ES2019 生效 会完全返回一模一样的原始代码（包括注释、空格等等） catch 的参数忽略允许 catch 语句忽略参数 12345try { // ...} catch { // ...} 2022.04.10No.15 Map 与 SetSetSet 类似于数组，但是 Set 成员的值都是唯一的，没有重复的值 Set 构造方法 new Set() new Set([1, 2, 3])构造方法可以接受一个数组或其他具有 Iterator 接口的数据结构参数 去除数组重复成员 [...new Set(array)] &gt; &gt; Array.from(new Set(array))去除字符串重复成员[...new Set(string)].join('') Set 对象添加值时，不会发生类型转换，且使用 Same-value-zero equality 判断值是否重复（类似===），特别的是任意对象均不相同 可以使用 Array.from() 方法将 Set 结构转为数组可以利用扩展运算符对 Set 实例转为数组执行一些操作 Set 原型属性 Set.prototype.constructor Set构造函数，即 Set 函数 Set.prototype.size返回 Set 实例的成员数量 Set 原型{操作}方法 Set.prototype.add(value)向 Set 实例添加一个值返回 Set 结构本身因此该方法可以链式调用 Set.prototype.delete(value)删除某个值返回一个布尔值，表示删除是否成功 Set.prototype.has(value)检测该值是否为 Set 实例的成员返回一个布尔值 Set.prototype.clear()清除所有成员没有返回值 1234567s.add(1).add(2).add(2);s.size; // 2s.has(1); // trues.has(2); // trues.has(3); // falses.delete(2);s.has(2); // false Set 原型{遍历}方法 Set.prototype.keys()返回键名的遍历器 Set.prototype.values()返回键值的遍历器 Set.prototype.entries()返回键值对的遍历器 Set.prototype.forEach()使用回调函数遍历每个成员，分别执行某种操作没有返回值接受第一个参数作为将执行的回调函数，第二个参数作为绑定的 this 对象 特别的，Set 结构键名和键值是同一个值，因此 keys 方法和 values 方法的行为完全一致 123456789101112131415let set = new Set([&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]);for (let item of set.keys()) { console.log(item); // red green blue}for (let item of set.values()) { console.log(item); // red green blue}for (let item of set.entries()) { console.log(item); // [&quot;red&quot;, &quot;red&quot;] [&quot;green&quot;, &quot;green&quot;] [&quot;blue&quot;, &quot;blue&quot;]}new Set([1, 4, 9]).forEach((value, key) =&gt; console.log(key + &quot; : &quot; + value));// 1 : 1 4 : 4 9 : 9 MapMap 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现（因为 Object 对象的键名只允许为字符串） Map 构造方法构造方法类似 Set 的构造方法，可以接受任意具有 Iterator 接口且每个成员都是一个双元素的数组的数据结构作为参数Map 亦不允许出现键值相同的元素特别的，Map 判断键值相同是基于内存地址的，因此对于对象而言，相同内容的对象可能被 Map 认为是不同的键值 Map 原型属性及方法 size返回 Map 结构的成员总数 Map.prototype.set(key, value)设置键对应的值若键已存在会覆盖已有的值返回当前的 Map 结构因此可以采取链式写法 Map.prototype.get(key)读取键对应的值查找成功返回键对应的值，否则返回 undefined Map.prototype.has(key)检测某个键是否存在于当前 Map 对象内返回一个布尔值 Map.prototype.delete(key)删除某个键返回一个布尔值，表示是否删除成功 Map.prototype.clear()清除所有成员方法没有返回值 12345678const map = new Map();map.set(&quot;foo&quot;, &quot;val&quot;);map.size; // 1map.get(&quot;foo&quot;); // 'val'map.has(&quot;foo&quot;); // truemap.delete(&quot;foo&quot;); // truemap.delete(&quot;foo&quot;); // falsemap.clear(); Map.prototype.keys()返回键名的遍历器 Map.prototype.values()返回键值的遍历器 Map.prototype.entries()返回所有成员的遍历器 Map.prototype.forEach()遍历 Map 的所有成员 同样，Map 的遍历顺序即插入顺序 WeakSet 及 WeakMapWeakSet 只接受对象作为成员WeakMap 只接受对象作为键名（null 除外），键值则没有限制WeakSet 中的对象与 WeakMap 的键名所指向的对象，不计入垃圾回收机制 因此 WeakSet 和 WeakMap 是不可遍历的，且不具有 size 属性，且无法执行清空操作WeakSet 和 WeakMap 的其他方法基本相同 它们主要应用于解决使用 Set 和 Map 时可能出现的内存泄漏问题 2022.04.11No.16 WeakRef ES2021 引入 对象的弱引用 直接使用 new WeakRef(target) 创建基于对象 target 的新对象，该对象是对对象 target 的弱引用，垃圾回收机制不会计入这个引用新对象的引用不会妨碍原始对象 target 被垃圾回收机制清除 实例 deref() 方法可以判断原始对象是否已被清除 123456789101112131415// 作为缓存function makeWeakCached(f) { const cache = new Map(); return (key) =&gt; { const ref = cache.get(key); if (ref) { const cached = ref.deref(); if (cached !== undefined) return cached; } const fresh = f(key); cache.set(key, new WeakRef(fresh)); return fresh; };}const getImageCached = makeWeakCached(getImage); FinalizationRegistry指定目标对象被垃圾回收机制清除以后，所要执行的回调函数 12345678// 新建注册表实例，接受一个回调函数参数作为当该对象被回收时的回调函数const registry = new FinalizationRegistry((heldValue) =&gt; { // ....});// 注册表实例的register()方法注册所要观察的目标对象并确定将传入回调函数的参数registry.register(theObject, &quot;some value&quot;, theObject);// unregister()方法可以取消注册当前的对象registry.unregister(theObject); Symbol概述原始数据类型 Symbol，表示独一无二的值，是一种类似于字符串的数据类型Symbol 值通过 Symbol() 函数生成可以添加一个字符串参数表示对 Symbol 实例的描述（若为对象则会调用 toString() 方法转为字符串） 12let s = Symbol(); // typeof s === &quot;symbol&quot;let s1 = Symbol(&quot;foo&quot;); // Symbol(foo) 任意两个 Symbol 变量使用 === 运算符比较都是不等的 Symbol 无法与其他类型的值进行运算，否则会报错；但可以显式转为字符串与布尔值（恒为 true） Symbol.prototype.description ES2019 引入 表示 Symbol 的描述（实际上就是传入 Symbol 的参数） 12const sym = Symbol(&quot;foo&quot;);sym.description; // &quot;foo&quot; Symbol 作属性名Symbol 值可以作为标识符，用于对象的属性名，从而保证不会出现同名的属性 123let a = { [mySymbol]: &quot;bar&quot;,}; 注意：Symbol 值作为对象属性名时，不能用点运算符，只能使用中括号运算符 Symbol 类型可以用于定义一组常量，可以替代魔术字符串的使用 Symbol 的遍历Symbol 成员属性不会被大多数循环所遍历但可以使用 Object.getOwnPropertySymbols() 方法与 Reflect.ownKeys() 获取用作属性名的 Symbol 值因此可以用于为对象定义一些非私有的、但又希望只用于内部的方法 2022.04.12No.17 Symbol 的方法Symbol.for()接受一个字符串作为参数，然后搜索有没有以该参数作为名称的全局环境的 Symbol 值，若存在，就返回这个 Symbol 值；否则就新建一个以该字符串为名称的 Symbol 值，并将其全局注册 1234Symbol.for(&quot;foo&quot;) === Symbol.for(&quot;foo&quot;);// trueSymbol(&quot;bar&quot;) === Symbol(&quot;bar&quot;);// false Symbol.keyFor()返回一个已登记的 Symbol 类型值的 key，否则返回 undefined Symbol 的内置值Symbol.hasInstance对象的 Symbol.hasInstance 属性，指向一个内部方法，该内部方法会在其他对象使用 instanceof 运算符，判断是否为该对象的实例时调用 12345678910111213class M { [Symbol.hasInstance](foo) { return foo instanceof Array; },};[1, 2] instanceof new MyClass() // trueclass N { static [Symbol.hasInstance](obj) { return Number(obj) &gt; 0; },};1 instanceof N // true-1 instanceof N // true Symbol.isConcatSpreadableSymbol.isConcatSpreadable 属性是一个布尔值表示该对象用于Array.prototype.concat()时，是否可以展开 默认数组可以展开，值为 undefined（true 亦可） 类数组对象默认不可展开，值为 false，（设为 true 可展开） 123456789101112131415class A1 extends Array { constructor(args) { super(args); this[Symbol.isConcatSpreadable] = true; },};class A2 extends Array { constructor(args) { super(args); }, get [Symbol.isConcatSpreadable] () { return false; },};/* 注意：实例内与类内的区别 */ Symbol.speciesSymbol.species 属性，指向一个构造函数，在创建衍生对象时调用 12345class MyArray extends Array { static get [Symbol.species]() { return Array; }} 可以指定衍生对象的类型（相当于指定原型对象） Symbol.matchSymbol.match 属性，指向一个函数，在执行str.match(myObject)时，如果该属性存在，会调用该属性，返回该方法的返回值 Symbol.replaceSymbol.replace 属性，指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值Symbol.replace 方法会收到两个参数，第一个参数是 replace 方法正在作用的对象；第二个参数是替换后的值 Symbol.search对象的 Symbol.search 属性，指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值 Symbol.split对象的 Symbol.search 属性，指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值 Symbol.iterator对象的 Symbol.iterator 属性，指向该对象的默认遍历器方法对象进行 for…of 循环时，会调用 Symbol.iterator 方法，返回该对象的默认遍历器 1234myIterable[Symbol.iterator] = function* () {};class Collection { *[Symbol.iterator]() {},}; 特别的，这个方法应当是一个 Generator 函数 Symbol.toPrimitive对象的 Symbol.toPrimitive 属性，指向一个方法，该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值 123456789101112131415161718let obj = { [Symbol.toPrimitive](hint) { switch (hint) { case &quot;number&quot;: return 123; case &quot;string&quot;: return &quot;str&quot;; case &quot;default&quot;: return &quot;default&quot;; default: throw new Error(); } },};2 * obj; // 2463 + obj; // '3default'obj == &quot;default&quot;; // trueString(obj); // 'str' 该方法可以接受一个字符串参数 Number：该场合需要转成数值 String：该场合需要转成字符串 Default：该场合可以转成数值，也可以转成字符串 Symbol.toStringTag对象的 Symbol.toStringTag 属性，指向一个属性的 get 方法，在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，它的返回值会出现在 toString 方法返回的字符串之中，表示对象的类型可以用来定制[object Object]或[object Array]中 object 后面的那个字符串 部分特殊的对象已具有自带的 Symbol.toStringTag 属性 Symbol.unscopables对象的 Symbol.unscopables 属性，指向一个对象，该对象指定了使用 with 关键字时，哪些属性会被 with 环境排除 123456789101112131415class MyClass { foo() { return 1; } get [Symbol.unscopables]() { return { foo: true }; }}var foo = function () { return 2;};with (MyClass.prototype) { foo(); // 2 （没有时为1）} 2022.04.13No.18 class 语法class 简介ES6 引入了 class 关键字用于定义类，作为对象的模板可以认为是构造函数的另外一种写法，用法完全和构造函数一样 12345678910class Point { constructor(x, y) { this.x = x; this.y = y; } toString() { return &quot;(&quot; + this.x + &quot;, &quot; + this.y + &quot;)&quot;; }}const point = new Point(1, 2); 实际上类模板内的所有方法实质是定义在构造方法的 prototype 对象上 prototype 对象的 constructor()属性，直接指向’类’的本身 特别的，类内部定义的所有方法，都是不可枚举的 特别的，类必须使用new指令调用，否则会报错 类内部默认是严格模式 类不存在变量提升现象 类的 name 属性返回类名 类成员方法的 this 默认指向类的实例（因此不建议单独使用成员方法，除非绑定了 this 的指向） constructor 方法类的默认方法（必须的），使用 new 命令时会被调用 默认返回实例对象，即 this class 实例实例的属性除非显式定义在其本身（即定义在 this 对象上），否则都是定义在原型上（即 class 上） 类的所有实例共享一个原型对象（浏览器可以使用proto属性访问，亦可使用 Object.getPrototypeOf（）获取实例的原型对象） 另外，如果需要修改原型对象，需要非常非常谨慎 取值函数与存值函数存值函数和取值函数直接设置在属性的 Descriptor 对象上，会拦截赋值和读取行为 1234567891011class MyClass { constructor() { // ... } get prop() { return &quot;getter&quot;; } set prop(value) { console.log(&quot;setter: &quot; + value); }} 属性表达式与 class 表达式12345678910111213/* 属性表达式 */let methodName = &quot;getArea&quot;;class A { [methodName]() {}}/* class表达式 */const B = class {};/* 立即执行的class表达式 */let c = new (class { constructor() {}})(); 2022.04.14No.19 静态方法在 class 内定义的方法加 static 关键字，使该方法不被实例继承而是直接通过类调用静态方法的 this 关键字指向类本身继承时父类的静态方法可以被子类继承，亦可通过 super 关键字调用 123456class Foo { static classMethod() { return &quot;hello&quot;; }}Foo.classMethod(); // 'hello' 实例属性实例属性可以定义在类的顶层 123456class Foo { count = 0; get value() { return this.count; }} 静态属性定义在 class 本身的属性，而不是定义在实例对象上的属性 12class Foo {}Foo.prop = 1; static 修饰静态属性 私有方法及私有属性 通过命名时前加下划线_加以提示 将变量名命名为 Symbol 值，增大获取的难度 将私有方法放在类外 新 method，使用#前缀 1234class Foo { #count = 0; #cause() {}} 同样可以使用 in 运算符判断私有属性的存在（但只能在类内部使用），常规的继承也可以使用 静态块在类生成时运行一次，且仅运行一次主要用于对静态属性进行初始化（内部可以使用类名或 this 指代当前类） 123456class C { static x = 1; static { this.x; // 等价于C.x }} new.target 属性在构造函数之中，返回 new 命令作用于的那个构造函数，若不是 new 调用的，会返回 undefined可以用来确定构造函数的调用方式子类继承父类时，new.target 会返回子类 1234567function Person(name) { if (new.target !== undefined) { this.name = name; } else { throw new Error(&quot;必须使用 new 命令生成实例&quot;); }} 2022.04.15No.20 class 继承使用 extends 关键字声明继承 12345678class Point { constructor() {}；}class ColorPoint extends Point { constructor() { super(); };} constructor 必须在显式声明的 constructor()方法内部显式调用 super()方法，否则会报错（未指定 constructor()方法会默认添加且内部会调用 super()方法） 原因是需要先调用父类的构造方法才可以生成 this 对象，从而子类才可在 this 上添加方法及属性可以认为，任意子类方法都有一个 constructor()方法 属性及方法 子类会继承父类所有属性方法，包括静态属性与静态方法（不包括私有属性与私有方法）但如果子类定义了私有属性的读写非私有方法，即可通过方法读写私有属性 super 关键字 super 作为函数调用时，代表父类的构造函数 super 方法只能用于子类的构造函数内 super 作为对象使用时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类 实例方法调用 super 内部 this 指向调用 super 的子类的实例静态方法调用 super 内部 this 指向 super 所在的子类 由于对象总是继承其他对象，因此实际上任意对象中均可使用 super 关键字 prototype 属性和 __proto__ 属性class 同时具有以上两种属性 子类 子类 __proto__ 属性指向父类 子类 prototype 属性的 __proto__ 属性，指向父类的 prototype 属性 12345class A {}class B extends A {}B.__proto__ === A; // trueB.prototype.__proto__ === A.prototype; // true 作为一个对象，子类（B）的原型（proto属性）是父类（A） 作为一个构造函数，子类（B）的原型对象（prototype 属性）是父类的原型对象（prototype 属性）的实例 子类实例 子类实例的proto属性的proto属性，指向父类实例的proto属性 1234var a = new A(2, 3);var b = new B(2, 3, &quot;red&quot;);b.__proto__.__proto__ === a.__proto__; // true 子类的原型的原型，是父类的原型 2022.04.16No.21 Module模块 CommonJS 服务器端 AMD 浏览器端 ES6 模块通过 export 显式指定输出的代码，并使用 import 导入 这是编译时加载，可以实现静态分析，可以提高加载效率 模块自动采用严格模式 export命令规定模块的对外接口 可以直接输出变量、函数、对象等 1234567// 输出变量export const a = 100;const b = 200;export { b };// 输出函数及类classexport function c() {} 通常export输出变量名称即其原本名称，但可以使用as关键字重命名 12const d = 300;export { d as D }; export指令规定的对外接口，必须与模块内部变量建立一一对应的关系 export输出的接口，与其对应的值是动态绑定关系，可以实时获取模块内部的值 import命令加载模块 import命令接受一对大括号，内部指定从其他模块导入的变量名（该变量名必须与对外接口名称相同） 1import { a, b } from &quot;module.js&quot;; 可以使用as关键字对输入变量重命名 1import { c as C } from &quot;module.js&quot;; import输入的接口是只读的，无法对其重新赋值（若其为对象，可改变其的内容） import 后的 from 规定模块文件的位置，相对路径与绝对路径均可，单独的模块名需要相应的配置文件给出模块的位置 1import jQuery from &quot;jquery&quot;; import命令具有提升效果，会把变量提升到模块头部首先执行（因为 import 命令是编译阶段执行的，在代码运行之前） import命令无法使用表达式与变量，也无法在 if、for 等块状作用域内执行 import 语句会执行所加载的模块 12// 执行一次lodash模块，但不会导入任何值import &quot;lodash&quot;; 模块整体加载使用*与as实现 12import * as Z from &quot;module.js&quot;;Z.c(); export default指令为模块指定默认输出，用户可以自行定义任意的名称 12345// export.jsfunction foo() {}export default foo;// import.jsimport FOO from &quot;export.js&quot;; 该命令只能使用一次，因为一个模块只能有一个默认输出 本质上，export default就是输出一个叫做default的变量或方法，并且系统允许为它取任意名字 2022.04.17No.22 export与import的复用1export { foo } from &quot;module.js&quot;; 相当于导入了模块并作为对外接口发放出去（但实际上并没有导入当前模块，不能直接使用） 1234567// 其他一些用法export { foo as FOO } from 'module';export * from 'module';export * as BAR from 'module';export { default } from 'module';export { foo as default } from 'module';export { default as foo } from 'module'; 模块的继承12345678export * from &quot;circle&quot;;export var e = 2.71828182846;export default function (x) { return Math.exp(x);}import * as math from &quot;circleplus&quot;;import exp from &quot;circleplus&quot;; 跨模块常量将 const 常量作为对外接口导出 12export const A = 1;import { A } from &quot;./constants&quot;; 动态导入使用import(specifier)动态导入模块，接受一个参数代表模块的位置，返回一个 Promise 实例（它是一个异步加载方法） 1234567import(`./section-modules/${someVariable}.js`) .then((module) =&gt; { module.doSomeThing(); }) .catch((err) =&gt; { console.error(err); }); 按需加载在需要时再加载模块 条件加载在if代码块内根据需要加载不同的模块 动态模板路径加载动态生成希望加载的模块路径 可以结合 async - await 使用 123456789async function main() { const myModule = await import('./myModule.js'); const { export1, export2 } = await import('./myModule.js'); const [ module1, module2, module3 ] = await Promise.all([ import('./module1.js'), import('./module2.js'), import('./module3.js'), ]);} 2022.04.18No.23 Proxy 代理器ProxyProxy 用于修改某些操作的默认行为，相当于在目标对象前添加一层拦截，可以对外界的访问进行过滤与改写 使用如下的方法生成一个对象的拦截器const proxy = new Proxy(target, handler);其中target代表将拦截的目标对象handler代表拦截行为，是一个对象 12345678910111213141516171819/** define */var obj = new Proxy({}, { get: function (target, propKey, receiver) { console.log(`getting ${propKey}!`); return Reflect.get(target, propKey, receiver); }, set: function (target, propKey, value, receiver) { console.log(`setting ${propKey}!`); return Reflect.set(target, propKey, value, receiver); }});/** test */obj.count = 1// setting count!++obj.count// getting count!// setting count!// 2 要使得Proxy起效，需要直接对Proxy实例进行操作而不是对目标对象进行操作显而易见Proxy实例可以做其他对象的原型对象同一个拦截器对象可以一次性拦截多个操作可以把拦截器设置到proxy属性上var object = { proxy: new Proxy(target, handler) };因而可以在object对象上调用 Proxy 实例方法 get(target, propKey, receiver) 简介拦截对象属性的读取标对象某属性不可写且不可配置，则对该属性的get方法会报错 参数 target 目标对象 propKey 属性名 receiver 操作行为所针对的proxy实例（可选） 目标 proxy.foo proxy['foo'] 作用 实现链式调用 set(target, propKey, value, receiver) 简介拦截对象属性的设置应返回一个布尔值（严格模式下返回 false 或 undefined 均会报错）目标对象的不可写属性，则对该属性的set方法不起效 参数 target 目标对象 propKey 属性名 value 属性值 receiver 操作行为所针对的proxy实例（可选） 目标 proxy.foo = v proxy['foo'] = v 作用 阻止内部属性的点运算符与中括号运算符访问，实现私有属性的效果 has(target, propKey) 简介拦截propKey in proxy的操作目标对象不可配置或不可扩展时使用has方法会报错返回一个布尔值特别的其对 for - in 循环不起效 参数 target 目标对象 key 查询的属性名 目标 foo in proxy 作用 阻止对内部属性的in运算符访问，实现私有属性的效果 deleteProperty(target, propKey) 简介拦截delete操作返回一个布尔值目标对象的不可扩展属性无法被删除，否则会报错 参数 target 目标对象 propKey 删除的属性名 目标 delete proxy[propKey] 作用 阻止对内部属性的in运算符访问，实现私有属性的效果 ownKeys(target) 简介拦截读取对象自身属性操作返回一个数组（数组成员只能是字符串或Symbol值，其他值出现会报错）会自动过滤不存在的属性、不可遍历的属性，Symbol值属性不可配置的属性必须被返回，否则报错不可扩展的目标对象必须包含所有属性，否则会报错 参数 target 目标对象 目标 Object.getOwnPropertyNames(proxy) Object.getOwnPropertySymbols(proxy) Object.keys(proxy) for...in循环 getOwnPropertyDescriptor(target, propKey) 简介拦截Object的获取属性描述对象方法返回属性的描述对象或undefined 参数 target 目标对象 propKey 希望获取属性描述对象的属性名 目标 Object.getOwnPropertyDescriptor(proxy, propKey) defineProperty(target, propKey, propDesc) 简介拦截Object的定义属性方法返回一个布尔值不可扩展的目标对象无法被删除，否则会报错目标对象的不可写属性或者不可配置属性无法被改变 参数 target 目标对象 propKey 删除的属性名 propDesc 删除的属性描述对象 目标 Object.defineProperty(proxy, propKey, propDesc） Object.defineProperties(proxy, propDescs) preventExtensions(target) 简介拦截Object的标记对象不可扩展方法必须返回一个布尔值仅目标对象不可扩展时才能返回true，否则会报错（因此通常内部需要调用一次Object.preventExtensions(proxy)方法） 参数 target 目标对象 目标 Object.preventExtensions(proxy) getPrototypeOf(target) 简介拦截获取原型对象操作返回一个对象或null不可扩展的目标对象，必须返回目标对象的原型对象 参数 target 目标对象 目标 Object.prototype.__proto__ Object.prototype.isPrototypeOf() Object.getPrototypeOf() Reflect.getPrototypeOf() instanceof isExtensible(target) 简介拦截判断对象可扩展性操作返回一个布尔值其返回值必须与目标对象的isExtensible属性一致 参数 target 目标对象 目标 Object.isExtensible(proxy) setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截 简介拦截设置原型对象方法必须返回一个布尔值不可扩展的目标对象不得改变其原型对象 参数 target 目标对象 proto 将设置的原型对象 目标 Object.setPrototypeOf(proxy, proto) apply(target, object, args) 简介拦截 Proxy 实例作为函数调用的操作 参数 target 目标对象 ctx 目标对象的上下文对象this args 目标对象的参数数组 目标 proxy(...args) proxy.call(object, ...args) proxy.apply(...) construct(target, args) 简介拦截 Proxy 实例作为构造函数调用的操作返回必须为一个对象 参数 target 目标对象（必须是函数） args 构造函数的参数数组 newTarget new命令作用的构造函数 目标 new proxy(...args) 作用 阻止对内部属性的in运算符访问，实现私有属性的效果 Proxy 静态方法 Proxy.revocable()返回一个可取消的 Proxy 实例可以应用于：若目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问 12345678910let target = {};let handler = {};let {proxy, revoke} = Proxy.revocable(target, handler);proxy.foo = 123;proxy.foo // 123revoke();proxy.foo // TypeError: Revoked issue of this on ProxyProxy 代理情况下，目标对象内部的this会指向 Proxy 实例此时需要使用bind、apply等方法绑定this的指向 2022.04.19No.24 ReflectReflect 对象是 Object 对象的更新","link":"/2022/12/14/es6/"},{"title":"node","text":"NodeNode 简介基于 Chrome V8 引擎的 JavaScript 运行环境 Node 与 浏览器均存在互不拥有的 API Node.js 中你可以控制环境即控制运行时的 JS 版本 Node.js 使用 CommonJS 模块系统，浏览器使用 ES Modules 标准 Node 内置 APIprocess 核心进程fspathhttp Node 第三方框架express 构建 Web 应用electron 构建桌面应用restify 构建 API 接口项目读写数据库实用命令行工具 Node 简单命令node -v 查看 Node 版本号 node -h 查看 Node 的命令帮助 node &lt;filename|filepath&gt; 执行给定文件名或路径的 js 文件 node 进入 node 交互运行模式 终端快捷键↑ 自动定位至上一条命令TAB 自动补全路径ESC 快速清空当前输入命令cls 清空终端 process 模块node 内置模块隐式导入 process.exit(&lt;exitCode&gt;) 关闭正在执行的 node 进程 process.exitCode 规定 node 进程的退出码 process.env 读取 node 进程启动时设置的所有环境变量 fs 模块node 内置模块 fs.open(&lt;filepath&gt;, &lt;open-mode&gt;, (&lt;err&gt;, &lt;fd&gt;) =&gt; {}) 获取文件描述符（？） fs.readFile(&lt;filepath&gt;, (&lt;err&gt;, &lt;stats&gt;) =&gt; {}) 读取文件属性 stats.isFile() 和 stats.isDirectory() 判断文件是否目录或文件stats.size 获取文件的大小 fs.readFile(&lt;filepath&gt;, [options], (&lt;err&gt;, &lt;data&gt;) =&gt; {}) 读取文件内容 会将文件的全部内容读取至内存中，对于大文件使用流更好 fs.writeFile(&lt;filepath&gt;, data,[options], (&lt;err&gt;) =&gt; {}) 写文件内容 仅在将全部内容写入文件才会结束执行，对于数据量较大的使用流更好 以上函数均有sync后缀的同步版本函数 在读取文件时，存在相对路径 ./ ../，运行时可能会存在问题，一般推荐使用 path 模块动态拼接文件完整路径（如 __dirname + '/&lt;filename&gt;'）或使用绝对路径 __dirname 脚本文件当前的目录路径D:\\程序\\前端学习new\\Node-eg__filename 脚本文件当前的绝对路径D:\\程序\\前端学习new\\Node-eg\\index.js path 模块node 内置模块 path.join([...paths]) 将多个路径片段拼接为完整的路径字符串 path.basename(&lt;filepath&gt;) 获取文件名部分path.basename(&lt;filepath&gt;, path.extname(&lt;filepath&gt;)) 获取文件名不含扩展名部分 path.dirname(&lt;filepath&gt;) 获取文件的父文件夹部分 path.extname(&lt;filepath&gt;) 获取文件扩展名部分 path.resolve() 获得相对路径的绝对路径计算可以在第一个参数的基础上指定路径，以使第二个参数附加第一个参数 需要注意的是，path模块方法仅做单纯的计算而不会主动判断路径的存在与否 http 模块node 内置模块 基于js语言创建本地服务器 IP 地址ip 地址是互联网上各计算机的唯一地址如 192.169.1.1有 ipv4 与 ipv6 域名使用字符串对域名进行唯一的标识 域名服务器负责解析域名并转换为IP地址 端口区分服务器上不同的服务一个服务器只能对应单个服务默认端口是80端口 http.createServer() 创建 http 服务器对象 Serve.prototype.on() 规定监听http请求的回调函数 Serve.prototype.listen() 启动 HTTP 服务器并监听http请求 实现基于url的响应1 获取url地址2 设置默认返回内容3 处理数据并返回 express 库基于 node 的 web 开发框架 快速创建 API 接口服务器与 Web 网站服务器 12345678910111213141516171819202122232425262728293031323334// 导入const express = require('express');// 创建服务器const app = express();// 启动服务器app.listen(8000, () =&gt; { console.log('express server running at http://127.0.0.1:8000');});// 监听请求// req 请求对象// res 响应对象app.get('/:id/user', (req, res) =&gt; { // 获取查询参数 `req.query` // 获取动态参数{如 /:id/} `req.params` // 发送请求内容 `res.send()` res.send('get!!!');});// 托管静态资源|注册全局中间件// 外部 http://localhost:8000/0.css// 内部 /public/0.css// 托管多个静态资源目录，只需多次调用 express.static() 方法app.use(express.static('public'));// 挂载路径前缀// 外部 http://localhost:8000/static/0.css// 内部 /public/0.cssapp.use('/static/', express.static('public')); nodemon监听本地项目文件变动并自动重启项目（类似前端 live server 的作用） 直接使用 nodemon file 指令执行项目 express 路由一种映射关系，express中指的是客户端的请求与服务器处理函数之间的映射关系app.METHOD(PATH, HANDLER) 路由模块化 1234567891011121314// router.jsconst express = require('express');const router = express.Router();router.get('/', (req, res) =&gt; {});router.post('/', (req, res) =&gt; {});module.exports = router;// main.js...const router = require('./router.js');app.use(router); express 中间件请求过程中可以调用中间件对请求进行多次预处理 实质是一个 function next 函数实现多个中间件连续调用，表示启用下一个中间件 123456789// 全局注册中间件app.use((req, res, next) =&gt; { console.log('mid'); next();});// 同时注册多个中间件只需多次调用app.use即可// 局部注册中间件app.post('/', (req, res, next) =&gt; {}, (req, res) =&gt; {}); 需在路由之前注册中间件可以对请求调用多个中间件进行处理注意执行完中间件代码，需调用next方法调用next方法后不应执行其他的任何的代码连续多个中间件之间共享req与res对象 CORS使用 cors 包 123const cors = require('cors');app.use(cors()); 只需服务器做配置，客户端无需做额外的配置 响应头部带 Access-Control-Allow-Origin 字段，表示允许来源的域的名称Access-Control-Allow-Headers 声明允许的请求头字段，Accept Accept-Language Content-Language DPR Downlink Save-Data Viewport-Width Width Content-TypeAccess-Control-Allow-Methods 声明允许的请求方法，默认GET POST HEAD可，其他均需声明 简单请求请求方式与请求头部字段有限 预检请求（预先发送OPTION请求确定是否可请求，仅成功后才会发送实际请求）其他 mysql.js在 node 中访问 MySQL 数据库的 js 库 Web 开发模式 基于服务端渲染的传统 Web 开发模式页面由服务器动态生成前端耗时少利于SEO占用服务器端资源不利于前后端分离开发效率低 基于前后端分离的新型 Web 开发模式依赖于 Ajax 技术，即前端使用接口，后端提供接口开发体验好用户体验好减轻服务器端渲染压力不利于SEO 身份认证出于安全性考虑，需要对用户身份进行认证 （服务器渲染）Session 认证机制（前后端分离）JWT 认证机制 Session 认证机制 HTTP 协议的无状态性 HTTP 请求独立，服务器无法主动保留每次 HTTP 请求的状态 突破无状态性 使用 Cookie Cookie 一段存储在用户浏览器中的字符串可以存储一些特有信息由名称、值及一些可选属性（有效期、安全性、使用范围等）构成不同域名下Cookie相互独立每次客户端请求均会自动发送当前域名下所有未过期的Cookie 1234&lt;!-- 设置cookie --&gt;Set-Cookie: token=1dw21qde43s;&lt;!-- 发送cookie --&gt;Cookie: token=1dw21qde43s; 客户端登录，服务器生成对应的cookie发回客户端保存；之后客户端每次请求均将带cookie，服务器需验证通过后再进行操作返回响应内容","link":"/2022/12/14/node/"},{"title":"network","text":"计算机网络通信：互联网 主体：服务器、客户端浏览器 内容：内容 方式：响应方式 通信协议：通信遵循的规则约定|通信格式 超文本：网页内容 超文本传输协议：网页内容传输协议 HTTP协议客户端与服务器间进行网页内容传输时需遵守的传输格式 提交&amp;响应 HTTP 请求HTTP协议模型：请求/响应 交互模型 HTTP 请求消息HTTP 请求报文 请求行：以空格分隔 请求方式：GET、POST等 URL：域名之后的url部分 协议版本 请求头部：以回车符&amp;换行符分隔，以键值对组成，键值对以冒号分隔 Host：服务器域名 User-Agent：说明客户端的浏览器类型 Connection：客户端与服务器的连接方式 Content-Type：发送到服务器的数据格式 Content-Length：请求体大小 Accept：客户端可接受的返回数据类型 Accept-Language：客户端可接收的语言文本类型 Accept-Encoding：客户端可接受的内容压缩编码形式 空行：回车符or换行符 请求体：POST有、GET无 123456789101112131415161718GET / HTTP/1.1Host: www.baidu.comConnection: keep-aliveCache-Control: max-age=0sec-ch-ua: &quot; Not A;Brand&quot;;v=&quot;99&quot;, &quot;Chromium&quot;;v=&quot;98&quot;, &quot;Google Chrome&quot;;v=&quot;98&quot;sec-ch-ua-mobile: ?0sec-ch-ua-platform: &quot;Windows&quot;DNT: 1Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.81 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Sec-Fetch-Site: noneSec-Fetch-Mode: navigateSec-Fetch-User: ?1Sec-Fetch-Dest: documentAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Cookie: BIDUPSID=028E86627DA4BB24A78F13047AE65439; PSTM=1628179856; BD_UPN=12314753; __yjs_duid=1_0275df3f717d1e5149c8d0bc2305f82d1628213742697; BAIDUID=D5D732CC5CBECD9277FA4AF82CF82B37:FG=1; BDUSS=JzeWVqZmpKdC1kRmFDN2VKRDl4R3d5YUR5WnJzVjV6dWRsdE5tSlotUXdNZGxoRVFBQUFBJCQAAAAAAQAAAAEAAACSPpQhzOy~1bXE1MYxMDAwMDEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADCksWEwpLFhQ3; BDUSS_BFESS=JzeWVqZmpKdC1kRmFDN2VKRDl4R3d5YUR5WnJzVjV6dWRsdE5tSlotUXdNZGxoRVFBQUFBJCQAAAAAAQAAAAEAAACSPpQhzOy~1bXE1MYxMDAwMDEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADCksWEwpLFhQ3; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598; BAIDUID_BFESS=D5D732CC5CBECD9277FA4AF82CF82B37:FG=1; BD_HOME=1; H_PS_PSSID=35834_35106_31253_35765_35489_34584_35491_35871_35246_35905_35796_35316_26350_35884_35724_35879_35746; sug=3; sugstore=0; ORIGIN=0; bdime=0; BA_HECTOR=8004al2520258h0lb41h0s1c90q HTTP 响应消息：HTTP 响应报文 状态行 协议版本 状态码：200等 状态码描述 响应头部 空行 响应体 123456789101112131415161718HTTP/1.1 200 OKBdpagetype: 2Bdqid: 0xbde875de000166a1Cache-Control: privateConnection: keep-aliveContent-Encoding: gzipContent-Type: text/html;charset=utf-8Date: Thu, 17 Feb 2022 08:52:39 GMTExpires: Thu, 17 Feb 2022 08:52:39 GMTServer: BWS/1.1Set-Cookie: BDSVRTM=302; path=/Set-Cookie: BD_HOME=1; path=/Set-Cookie: H_PS_PSSID=35834_35106_31253_35765_35489_34584_35491_35871_35246_35905_35796_35316_26350_35884_35724_35879_35746; path=/; domain=.baidu.comStrict-Transport-Security: max-age=172800Traceid: 1645087959064662324213684317064108533409X-Frame-Options: sameoriginX-Ua-Compatible: IE=Edge,chrome=1Transfer-Encoding: chunked 请求方法 GET 查询 - 获取服务器资源 请求数据放在数据头内 POST 新增 - 提交资源 请求数据放在请求体内 PUT 修改 - 提交新资源并替换 DELETE 删除 - 移除资源 请求删除指定的资源 响应状态码用于标识响应状态 三十进制：字，first类型，then细分 1** 信息：收到请并需继续操作（少见） 2** 成功：请求成功接收并处理 200 OK 请求成功 201 Created 已创建 3** 重定向：需进一步操作以完成请求 301 Moved Permanently 永久移动 使用新URL 302 Found 临时移动 仍使用原有URL 304 Not Modified 未修改 会直接访问缓存内资源 4** 客户端错误：请求包含语法错误或无法完成请求 400 Bad Request 语义有误or请求参数有误 401 Unauthorized 需用户验证 403 Forbidden 拒绝执行请求 404 Not Found 无法找到资源 408 Request Timeout 请求超时 5** 服务器错误：服务器处理请求出错 500 Internal Server Error 服务器内部错误，无法完成请求 501 Not Implemented 不支持请求方法 503 Service Unavailable 服务器暂时无法处理：超载or系统维护 跨域与 JSONP同源策略同源：两页面协议、域名、端口相同 浏览器网页默认端口 80 同源策略：浏览器安全功能-限制来源同一个加载文档脚本与其他源资源的交互 阻止读取非同源网页的 cookie、localstorage 与 indexedDB 阻止接触非同源网页的 DOM 阻止向非同源地址发送 Ajax 请求 跨域：非同源 浏览器会拦截跨域请求回来的数据 JSONPJSON 的一种使用模式，实现跨域数据访问 由于 script 标签允许请求非同源的 js 脚本 利用 script 标签请求，并传递一个回调函数名作为参数；服务器端把数据作为回调函数参数包装后返回；浏览器自动执行回调函数代码，即实现数据渲染 JSONP：兼容性好、只支持 GET 请求 CORS：支持 GET 与 POST，不兼容低版本浏览器 123456789101112131415&lt;div id=&quot;divCustomers&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function callbackFunction(result, methodName) { var html = &quot;&lt;ul&gt;&quot;; for (var i = 0; i &lt; result.length; i++) { html += &quot;&lt;li&gt;&quot; + result[i] + &quot;&lt;/li&gt;&quot;; } html += &quot;&lt;/ul&gt;&quot;; document.getElementById(&quot;divCustomers&quot;).innerHTML = html; }&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://www.runoob.com/try/ajax/jsonp.php?jsoncallback=callbackFunction&quot;&gt;&lt;/script&gt; jQuery 实现用户端 采用动态创建与移除 script 标签：向 head 内添加 script 标签 12345678910111213141516171819202122232425262728&lt;div id=&quot;divCustomers&quot;&gt;&lt;/div&gt;&lt;script&gt; $.getJSON( &quot;https://www.runoob.com/try/ajax/jsonp.php?jsoncallback=?&quot;, function (data) { var html = &quot;&lt;ul&gt;&quot;; for (var i = 0; i &lt; data.length; i++) { html += &quot;&lt;li&gt;&quot; + data[i] + &quot;&lt;/li&gt;&quot;; } html += &quot;&lt;/ul&gt;&quot;; $(&quot;#divCustomers&quot;).html(html); } );&lt;/script&gt;&lt;script&gt; $.ajax({ url: 'https:www.sky.icu', dataType: 'jsonp', // 必需 success: (res) =&gt; { console.log(e); }, jsonp: 'callback' // 发送至服务器参数名称：可选 jsonpCallback: 'jQueryxxx', // 自定义回调函数名称：可选 })&lt;/script&gt;&lt;!-- 会自动带一个jQueryXXXX的回调函数名称 --&gt; 服务器端 123456789&lt;?php header('Content-type: application/json'); //获取回调函数名 $jsoncallback = htmlspecialchars($_REQUEST ['jsoncallback']); //json数据 $json_data = '[&quot;customername1&quot;,&quot;customername2&quot;]'; //输出jsonp格式的数据 echo $jsoncallback . &quot;(&quot; . $json_data . &quot;)&quot;;?&gt; 节流节流，就是指连续触发事件但是在 n 秒中只执行一次函数 减少事件触发频率 使得鼠标事件仅在单位时间内触发一次 降低监测滚动条位置的频率 123456789101112131415161718192021222324// 时间戳function throttle(func, delay) { let prev = 0; // 上次触发时间 return function (...args) { const now = Date.now(); if (now - prev &gt; delay) { last = now; func.apply(this, args); } };}// 定时器function throttle(func, delay) { let timeout = null; return function (...args) { if (!timeout) { timeout = setTimeout(() =&gt; { timeout = null; func.apply(this, args); }); } };} 防抖防抖，就是指触发事件后 n 秒后才执行函数，如果在 n 秒内又触发了事件，则会重新计算函数执行时间 常用于搜索 123456789101112131415161718192021222324252627// 非立即执行// 触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间function debounce(func, delay) { let timer = null; // 上次调用指向的计时器 return function (...args) { if (timer) { clearTimeout(timer); } timer = setTimeout(() =&gt; { func.apply(this, args); }, delay); };}// 立即执行// 触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果function debounce(func, delay) { let timer = null; return function (...args) { if (timer) clearTimeOut(timer); const cal = !timer; timer = setTimeOut(() =&gt; { timer = null; }, delay); if (cal) func.apply(this, args); };}","link":"/2022/12/14/network/"},{"title":"markdown","text":"标题12345678910111213# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推 段落Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车 当然也可以在段落后面使用一个空行来表示重新开始一个段落 粗体斜体12345678910111213*斜体*_斜体_**粗体**__粗体__***斜粗体***___斜粗体___ 分割线删除线12345678910111213-----------------------------------------------------------------___------ 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西 123~~删除线~~ 如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线~~即可 123&lt;u&gt;下划线&lt;/u&gt; 下划线可以通过 HTML 的 &lt;u&gt; 标签来实现 脚注123脚注[^脚注类似这样] 脚注是对文本的补充说明 123[^脚注类似这样]: 对对对 列表1234* 无序列表* and 或者 1234+ s+ d 或者 1234- s- d 无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容 123451. d2. e3. r 有序列表使用数字并加上 . 号来表示 列表嵌套只需在子列表中的选项前面添加四个空格即可 12345671. 1 - ss - ss - e2. w 引用12345678910111213&gt; def&gt;&gt; end&gt;&gt; &gt; d&gt; &gt;&gt; &gt; e&gt; &gt;&gt; &gt; &gt; get&gt; &gt; &gt;&gt; &gt; &gt; end Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号 区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推 区块中使用列表，正常使用即可 列表中使用区块，需要在 &gt; 前添加四个空格的缩进 12345678910111213141516171819* 第一项 &gt; d &gt; 菜鸟教程 &gt; 学的不仅是技术更是梦想* 第二项* &gt;* &gt; d &gt; &gt; dd* d 代码段落上的一个函数或片段的代码可以用反引号把它包起来 123`printf()` 代码区块使用 ``` 包裹一段代码，并指定一种语言（也可以不指定）符 123```javascriptdocument.getElementByTagName(&quot;video&quot;)[0].click() 1234567891011# 链接```markdown [链接](https://www.runoob.com) &lt;https://www.runoob.com&gt; [1]:https://www.runoob.com 可以通过变量来设置一个链接，变量赋值在文档末尾进行[IT][1] 图片123![Oh](https://pics6.baidu.com/feed/72f082025aafa40f99cb5d63e6222f4679f019ca.jpeg?token=6d0ab25f666cf492c9ff83d037cb74e0) 表格123456789| b1 | b2 | b3 | b4 || ---- | ---- | ---- | ---- || d1 | d2 | d3 | d4 || b1 | b2 | b3 | b4 || :---- | ----: | :----: | ---- || d1 | d2 | d3 | d4 |","link":"/2022/12/14/markdown/"},{"title":"npm","text":"npmnpm官网 官方英文文档 中文文档 包：node.js 中的第三方模块 由第三方个人或团队开发的开源代码集 包类型： 项目包 开发依赖包 被记录到devDependencies节点的包，仅开发中使用 核心依赖包 被记录到dependencies节点的包，开发发布后均使用 全局包 命令： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546npm -v查看npm版本npm help查看npm帮助npm init初始化包环境创建package.json包配置文件* -yes -y 使用默认设置初始化包环境npm install &lt;package_name&gt;npm i &lt;package_name&gt;下载npm包在当前目录中创建node_modules目录（如果尚不存在）并将包下载到该目录同时在该目录下添加package-lock.json文件，记录下载的包的信息，如包的版本号、下载url等&lt;package_name&gt;@&lt;tag&gt; &lt;package_name&gt;@&lt;edition&gt; 方式下载指定版本和标签的包未指定package_name参数时会根据package.json的dependencies属性下载包* -global -g 全局安装包* --save-dev -D 把包配置到devDependencies内npm listnpm ls列出所有已安装的包* -global -g 显示全局安装的包* -all -a 显示所有包及其所有的依赖项* -depth=&lt;number&gt; 显示包及其给定深度的依赖项npm uninstall &lt;package_name&gt;卸载npm包* --save 从package-lock.json文件dependencies属性中移除包* --save-dev 从package-lock.json文件devDependencies属性中移除包* -g 删除全局包npm updatenpm update -gnpm update -g &lt;package_name&gt;升级npm包npm outdatednpm outdated -g --depth=0检测npm包是否为最新 包管理配置文件：package.json项目根目录 项目名称、版本号、描述等‘ 项目中使用的包：区分仅开发使用与开发及部署均使用 安装的包会自动更新至package.json文件 name 项目名称：字符串 version 项目版本号：字符串 description 包内容描述：字符串 keywords 项目的关键词：字符串数组 homePage 项目主页：字符串 bugs 项目报告错误的网址：字符串数组 license 项目的许可证：字符串 author 作者：字符串 可使用name、email、url替代 contributors 贡献者：字符串数组 funding 贡献方式：字符串or字符串数组or对象（type &amp; url） files 包作为依赖项需包含的条目 main 标记包的根目录模块 browser 同上，特别指明为浏览器环境 bin 命令名称到本地文件的映射| man 指定为man程序查找的文件名| directories 指定包结构| repository 指定代码所在位置，常为各种git仓库 scripts 指定在包生命周期运行的代码| config 设置持续使用配置参数 dependencies 项目开发与发布均使用的包 devDependencies 项目开发内使用的包 peerDependencies 项目使用的插件| peerDependenciesMeta 标记插件是否为必需| bundledDependencies/bundleDependencies 发布包时将捆绑的包名称| optionalDependencies 可以使用依赖项| overrides 规定依赖项版本| engines 规定适用的node版本 os 规定使用的操作系统版本 cpu 规定适用的cpu版本 private 规定能否发布私有存储库 publishConfig 规定发布配置 workspaces 描述用作工作空间的文件夹的直接路径 版本号： 第一位数字：大版本 第二位数字：功能版本 第三位数字：bug修复版本 其他： 将node_modules文件夹添加到.gitignore文件内，以使git上传时剔除npm包","link":"/2022/12/14/npm/"},{"title":"react","text":"ReactReact 概述React 概念React 用于构建用户界面的 JavaScript 库 MVC 中的 V {视图层} React 特点声明式基于组件应用范围广 react 基本使用react 安装npm i react react-dom react 使用12&lt;script type=&quot;text/javascript&quot; src=&quot;./node_modules/react/umd/react.development.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;./node_modules/react-dom/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; 12const title = React.createElement('h1', null, 'Hello React');ReactDOM.render(title, document.getElementById('root')); React.createElement返回 React 元素第一个参数为元素名第二个参数为元素属性第三个及之后的参数为元素的子节点 ReactDOM.render第一个参数为要渲染的 react 元素第二个参数为将挂载的 DOM 对象 React 脚手架使用npx create-react-app &lt;my-app&gt; npx 在不安装脚手架包情况下使用脚手架包提供的命令 npm init react-app &lt;my-app&gt;yarn create react-app &lt;my-app&gt; 导入 React 创建 React 元素 渲染 React 元素 JSX 概述JSX 基本使用比 createElement 简洁 在 JS 中书写 HTML 格式代码 123const title = &lt;h1&gt;Hello JSX&lt;/h1&gt;;const root = document.getElementById(root);ReactDOM.render(title, root); JSX 注意点React 元素属性名使用驼峰命名法 class 属性需替换为 className 属性for 属性需替换为 htmlFor 属性 无子节点的元素可以以单标签形式写 建议使用小括号包裹 JSX JSX 嵌入 JS 表达式单大括号 123const title = &lt;h1&gt;Hello JSX&lt;/h1&gt;;const root = document.getElementById(root);ReactDOM.render(title, root); 允许使用任意的 JS 表达式但使用对象可能会出现 bug不能使用任意的 JS 语句 条件渲染函数 - ifelse函数 - 三元表达式函数 - 逻辑与运算符 列表渲染使用数组 map 方法实现 123456const array = [1, 2, 3, 4, 5]const list = ( &lt;ul&gt; {array.map(v =&gt; &lt;li key={v}&gt;{v}&lt;/li&gt;)} &lt;/ul&gt;) 样式处理行内样式 &lt;h1 style={{ color: red; }}&gt;&lt;/h1&gt; 类名 className React 组件介绍使用 React 组件介绍从而实现完整的页面功能 函数组件使用函数创建组件 函数名称必须以大写字母开头 函数组件必须有返回值，表示组件内容 | 返回值为 null，为无内容 渲染组件，直接使用函数名为组件标签名 类组件使用 class 类创建组件 类名称必须以大写字母开头 类组件需继承 React.component 父类，以使用父类提供的方法 类组件需提供 render 方法，且应有返回值，表示组件将渲染的内容 独立文件单独组件放在单个JS文件内 事件绑定示例如 onClick={ () =&gt; {} }采用驼峰命名法 事件对象合成事件（包含原生事件）兼容性好 组件分类函数组件 - 无状态组件类组件 - 有状态组件 状态 - 数据 组件状态是私有的 受控组件 - value 绑定 state 变量，监听 change 事件实时改变 state 变量 非受控组件 - | 组件高级组件通讯组件 props | 父组件=&gt;子组件 可以传递各种数据，包括对象、函数乃至JSX等props 只读 父-&gt;子 props属性传数据 子-&gt;父 props属性传回调方法 兄弟&lt;-&gt;兄弟 状态共享至公共父组件，由公共父组件负责管理 跨多个组件的通讯 contextProvider 传送数据Customer 接纳数据 props.children 组件标签的子节点 props 校验 使用 prop-types 设置propTypes支持 array bool func number object string bigint symbolelement node elementTypeinstanceOfoneOf oneOfTypearrayOf objectOfrequiredshape设置defaultProps 组件生命周期仅类组件有生命周期 创建时 constructor 初始化state 绑定this render 渲染UI componentDidMount 发送网络请求 DOM操作 更新时 render componentDidUpdate 卸载时 componentWillUnmount 组件复用 render props 模式 将单独的state及state方法封装为单独的组件利用 prop 传递参数传递函数以函数返回值作为将渲染的 UI 内容（或使用 children） 高阶组件 HOC 函数接受需包装的组件，返回增强的组件（名称约定以 with 开头）组件配置 displayName 作为组件名称 路由SPA 单页面应用，单HTML页面的web应用程序 路由 - 配对路径何组件 安装 react-router-dom 导入组件 import { BrowserRouter as Router, Route, Link } from 'react-router-dom' Router 组件包裹整个应用 Link 作为路由入口 Route 配置路由规则和需要展示的组件|路由出口 Router 组件包裹整个应用，仅使用一次包括 BrowserRouter 和 HashRouter Link 组件作为导航链接Route 组件指定路由展示组件相关信息 编程式导航this.props.history.pushthis.props.history.go 默认路由path为 / 的路由 默认 route 遵从模糊匹配设置 extra 遵从精确匹配","link":"/2022/12/14/react/"},{"title":"svg","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;svg width=&quot;500&quot; height=&quot;500&quot; style=&quot;background-color: #eee;&quot;&gt; &lt;!-- 矩形 rect --&gt; &lt;rect width=&quot;100&quot; height=&quot;100&quot; x=&quot;100&quot; y=&quot;100&quot; rx=&quot;10&quot; ry=&quot;10&quot;&gt;&lt;/rect&gt; &lt;!-- 圆形 circle --&gt; &lt;circle cx=&quot;250&quot; cy=&quot;250&quot; r=&quot;100&quot;&gt;&lt;/circle&gt; &lt;!-- 椭圆 ellipse--&gt; &lt;ellipse cx=&quot;475&quot; cy=&quot;450&quot; rx=&quot;25&quot; ry=&quot;50&quot;&gt;&lt;/ellipse&gt; &lt;!-- 直线 line --&gt; &lt;line x1=&quot;0&quot; y1=&quot;0&quot; x2=&quot;500&quot; y2=&quot;500&quot; stroke=&quot;green&quot;&gt;&lt;/line&gt; &lt;!-- 折线 polyline --&gt; &lt;polyline points=&quot;500 0, 100 100, 0 500&quot; stroke=&quot;blue&quot; fill=&quot;none&quot;&gt;&lt;/polyline&gt; &lt;!-- 多边形 polygon --&gt; &lt;polygon points=&quot;500 0, 400 400, 0 500&quot; stroke=&quot;none&quot; fill=&quot;green&quot;&gt;&lt;/polygon&gt; &lt;!-- 直线路径 path --&gt; &lt;path d=&quot;M 0 0 L 50 50 L 50 100 L 100 400 L 400 400 L 400 100 L 50 50 Z&quot; stroke=&quot;orange&quot; fill=&quot;none&quot; &gt;&lt;/path&gt;&lt;path d=&quot;M 0 0 l 250 150 l 100 0 l 0 -100 l 50 50 l 50 0 l 0 350 l -350 0 l 0 -50 l -50 -50 l 100 0 l 0 -100 Z&quot; stroke=&quot;red&quot; fill=&quot;none&quot; stroke-width=&quot;5&quot; stroke-dasharray=&quot;25 5 10 5&quot; stroke-dashoffset=&quot;5&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot;&gt;&lt;/path&gt; &lt;!-- 属性样式 直接设置在元素属性上 内联样式 设置在元素 style 属性内 内部样式 写在 style 标签内 外部样式 写在独立的 css 文件中 --&gt; &lt;!-- svg 常见属性 fill 填充颜色 stroke 描边颜色 fill-opacity 填充颜色的不透明度 stroke-opacity 描边颜色的不透明度 stroke-width 描边宽度 stroke-dasharray 描边样式 - 可以用于设置虚线 stroke-dashoffset 设置偏移量 stroke-linecap 线帽样式 butt 平头 | 默认 round 圆头 square 方头 stroke-linejoin 拐角样式 miter 尖角 | 默认 round 圆角 bevel 平角 shape-rendering 消除锯齿 crispEdges 关闭反锯齿功能 geometricPrecision 开启反锯齿功能 --&gt; &lt;!-- svg 支持颜色 颜色关键字 十六进制 RGB 和 RGBA HSL 和 HSLA --&gt; &lt;!-- 文本元素 text --&gt; &lt;text x=&quot;250&quot; y=&quot;250&quot; fill=&quot;pink&quot; font-size=&quot;50&quot; font-weight=&quot;bold&quot; text-decoration=&quot;underline&quot; text-anchor=&quot;middle&quot; dominant-baseline=&quot;middle&quot;&gt;SVG&lt;/text&gt; &lt;!-- 多行文本 tspan --&gt; &lt;text font-size=&quot;25&quot;&gt; &lt;tspan x=&quot;400&quot; y=&quot;380&quot;&gt;S&lt;/tspan&gt; &lt;tspan x=&quot;400&quot; y=&quot;400&quot;&gt;V&lt;/tspan&gt; &lt;tspan x=&quot;400&quot; y=&quot;420&quot;&gt;G&lt;/tspan&gt; &lt;/text&gt; &lt;!-- 文本元素属性 font-size 字号 font-weight 粗体 text-decoration 装饰线 text-anchor 水平对齐方式 dominant-baseline 垂直对齐方式 writing-mode 文字方向 --&gt; &lt;!-- 超链接 a --&gt; &lt;a xlink:href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/SVG&quot; xlink:title=&quot;svg&quot; target=&quot;_blank&quot;&gt; &lt;text x=&quot;50&quot; y=&quot;50&quot; font-size=&quot;25&quot;&gt;SVG&lt;/text&gt; &lt;/a&gt; &lt;!-- 图片 image --&gt; &lt;image xlink:href=&quot;https://img.zcool.cn/community/0167b95fc9ea7a11013ee04dc55982.jpg@1280w_1l_2o_100sh.jpg&quot; width=&quot;50&quot; height=&quot;50&quot; x=&quot;100&quot; y=&quot;100&quot;&gt;&lt;/image&gt;&lt;/svg&gt;","link":"/2022/12/14/svg/"},{"title":"regex","text":"正则表达式正则表达式是使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串的搜索模式 语法/正则表达式主体/修饰符(可选) 字符串方法 search() 搜索字符串，返回匹配的字符串下标或-1 1'123456'.search(/234/) // 1 replace() 替换匹配的字符串，返回修改后的字符串 1'123456'.replace(/345/, 'abc') // 12abc6 split() 从指定位置分割字符串，返回一个数组 match() 搜索字符串，返回由所有子串组成的数组或null 正则表达式修饰符 i 忽略区别大小写 g 执行全局匹配 m 执行多行匹配 正则表达式元字符 . 查找单个非换行符字符 \\d 查找数字 \\s 查找空白字符 \\b 匹配单词边界 \\w 查找数字、大小写字母及下划线 正则表达式量词 n+ 匹配一个或多个字符串n n* 匹配零个或多个字符串n n? 匹配零个或一个字符串n ^ 匹配字符串开始(第一个字符) $ 匹配字符串结束(最后一个字符) 正则表达式括号 [0-9] 匹配任何0-9数字 [a-zA-Z] [A-z] 匹配任意大小写字母 [abc] 查找[]内的任意字符 [^abc] 查找[]外的任意字符 (x|y) 查找()内任意选项 RegExp 对象及其方法 test() 匹配字符串是否符合给定模式 返回一个布尔值 exec() 匹配字符串中正则表达式的匹配 返回一个包含搜索结果数组，未查找到返回null 参考链接MDN 正则表达式 菜鸟教程 正则表达式 W3school 正则表达式","link":"/2022/12/14/regex/"},{"title":"vue","text":"vue一套构建用户界面的前端框架 数据驱动视图 双向数据绑定 MVVM：Model-View-ViewModel Model 数据源 View DOM 结构 ViewModal Vue 实例 创建 Vue 实例1234567891011121314151617const app = new Vue({ // Vue实例挂载对象，接收一个选择器 // 若匹配多个DOM对象，取匹配到的第一个DOM对象 el: &quot;#app&quot;, // 普通属性 data: { msg: &quot;&quot;, }, // 计算属性：带返回值的方法 computed: {}, // 监听器 watch: {}, // 普通方法 methods: {}, // 过滤器 filters: {},}); 指令结构指令:参数:修饰符 v-on:submit.prevent=&quot;&quot; 文本“Mustache”语法 {{ }} v-text &lt;span&gt;{{msg}}&lt;/span&gt; 只能用于内容节点 &lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt; 会覆盖内部文本 v-once 单次渲染 原始 HTML v-html &lt;span v-html=&quot;msg&quot;&gt;&lt;/span&gt; 会覆盖内部内容 避免使用，可能会发生 XSS 攻击存在安全风险 绑定 attr v-bind &lt;a v-bind:href='url'&gt;&lt;/a&gt; 简写 &lt;a :href='url'&gt;&lt;/a&gt; 计算属性computed 对象 属性需为一个函数，并返回相应的值 使用时同正常的 data 属性即可 12345computed: { val1: function () { return `the number is ${this.val0} in the input box`; }} 其是依赖于响应式依赖进行缓存的，仅在其相应式依赖改变时才重新计算，因而可以提高性能 可以添加 setter 属性，默认只针对 getter 属性，这样可以同时更新 data 中数据 12345678910computed: { val1: { get: function () { return `the number is ${this.val0} in the input box`; }, set: function (val_1) { this.val0 = val_1; } }} 侦听属性watch 对象 1234567891011watch: { // 方法形式 val0: function (newData, oldData) { }, // 对象形式 val1: { handler (newVal, oldVal) {}, immediate: true, }, deep: true,}, 实质是一个函数，函数名是监听的变量名 immediate 选项 立即以表达式当前值触发回调 deep 选项 用于监听对象内部值的变化 若侦听特殊格式变量，可包裹单引号 如’info.id’ () {} 计算属性与侦听属性区别，计算属性根据其响应式属性的改变而改变，侦听属性根据其监视的属性的改变而修改相应的属性 绑定事件 v-on &lt;a v-on:click='handle_click'&gt;&lt;/a&gt; 简写 &lt;a @click='handle_click'&gt;&lt;/a&gt; 动态事件 &lt;a @[event]='handle_click'&gt;&lt;/a&gt; 传参 &lt;a @click='handle_click(1)'&gt;&lt;/a&gt; 传原生 DOM 事件$event &lt;a @click='handle_click($event)'&gt;&lt;/a&gt; 实际方法无参时可以不用该方法，但有参数时必须使用该方法 事件修饰符 prevent 阻止事件默认行为 stop 阻止事件传播 once 使事件仅触发一次 self 仅在触发事件的元素为绑定的元素本身时起效 capture 捕获事件模式：比内部元素绑定事件处理方法优先处理 passive 预先完成事件的默认行为而不是等待事件处理方法完成 修饰符可以串联使用 鼠标修饰符 left right middle 分别仅在点击鼠标相应侧按键时起效 按键修饰符 可以指定为相应的键码才起效 .enter .tab .delete .esc .space .up .down .left .right 系统修饰符 exact 控制仅为给定的系统修饰符触发的事件 ctrl alt shift meta 控制需按下对应的按键才可触发事件 绑定表单v-model 表单 &lt;input&gt;、&lt;textarea&gt; 及 &lt;select&gt; 元素有效 会忽略所有表单元素的 value、checked、selected attribute 的初始值，故需在 data 中声明数据的初始值 text 和 textarea 元素使用 value property 和 input 事件 checkbox 和 radio 使用 checked property 和 change 事件 select 字段将 value 作为 prop 并将 change 作为事件 修饰符 number 自动转为数值类型 trim 自动过滤字符串两端空格符 lazy 改为在 change 事件后同步而不是默认的 input 事件后同步，即输入时失去或获得焦点才会触发事件 条件绑定 v-if truthy 值显示，falsy 值不显示 实质惰性渲染 v-show truthy 值显示，falsy 值不显示 实质仍渲染，通过 display 属性控制 若经常切换显示与否用 v-show，否则用 v-if；可以大幅提高性能 123&lt;div v-if=&quot;val === 0&quot;&gt;0&lt;/div&gt;&lt;div v-else-if=&quot;val === 1&quot;&gt;1&lt;/div&gt;&lt;div v-else&gt;other&lt;/div&gt; :key 可以用于强制区别元素对象 循环绑定 v-for :key 建议绑定 key 属性，并使用独一无二的值作为 key 的值 一般需为字符串或数字类型 1&lt;div v-for=&quot;(item, index) in array&quot;&gt;{{index + ' : ' + item}}&lt;/div&gt; 过滤器filters 常用于实现文本格式化 可以用于插值表达式或 v-bind 属性 语法 {{ message | capitalize }} v-bind:id=&quot;rawId | formatId&quot; 前一个是定义的变量，后一个是定义的过滤器方法，接收唯一一个参数为变量 定义过滤器方式 123456789101112131415// 局部过滤器filters: { capitalize: function (value) { if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) }}// 全局过滤器Vue.filter('capitalize', function (value) { if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1)}) 其他玩法 过滤器串联 {{ message | filterA | filterB }} 过滤器接收参数 {{ message | filterA('arg1', arg2) }} 默认 message 是第一个参数，’arg1’是第二个参数，arg2 是第三个参数 da SPA 单页面应用程序 &amp; vue-clivue-cli 用于简化使用 webpack 创建 vue 项目的过程 创建 vue 项目vue create PROJECT_NAME vue 项目目录 src： main.js：项目入口脚本文件 App.vue：项目根组件 assets：项目静态资源 如 css 样式表、图片资源 components：组件 public： favicon.ico：项目网页图标 index.html：项目页面文件 vue 项目运行流程 通过 main.js 把 App.vue 渲染到 index.html 的指定位置 导入 vueimport Vue from 'vue'; 导入 app 模板import App from './App.vue'; 12345// 添加 Vue 实例new Vue({ // 渲染 render 函数指定的组件 render: (h) =&gt; h(App),}); 使用 $mount() 代替 el 属性绑定 DOM 对象 组件使用 vue 后缀名文件定义独立组件 注册组件 全局：建议注册于入口文件 main.js 123Vue.component(&quot;my-component-name&quot;, { // ... options ...}); 局部：注册于预期使用的区域 1234567new Vue({ components: { &quot;com-1&quot;: { /* options */ }, },}); 独立组件文件 template 组件模板结构 script 组件 js 行为 style 组件样式 123456789101112131415161718192021&lt;template&gt; &lt;div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default = { name: 'my-component-name', data: function () { return {}; }, watch: {}, computed: {}, filters: {}, // props: ['my-prop-name'], props: { 'my-prop-name' : { default: 'default-value', }, }, };&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 注意点 组件应拥有一个根元素 组件内部 data 必须是返回包含数据的对象的函数 指定 style 的类型 &lt;style lang=&quot;less&quot;&gt; 组件封装后是相互独立的，使用时具有父子关系 导入 vue 文件方法 12345678import Test from &quot;./components/test.vue&quot;;export default { name: &quot;App&quot;, // 声明使用Test组件 components: { Test, },}; 组件属性 props 大多数属性同 Vue 实例对象 name: String 组件名称 props: Array | Object 组件自定义属性可以直接在方法中使用，只读，可以绑定 v-bind 以动态修改自定义属性的值 default 规定属性的默认值 type 规定属性的类型String Number Boolean Array Object Date Function Symbol 一个自定义的构造函数 required 规定属性是否为必须的 样式冲突问题 组件内的样式全局生效，可能会影响到整个 index 页面利用 scoped 设定 &lt;style scoped&gt;原理是通过自定义 HTML 属性结合 CSS 属性选择器实现/deep/ div 仅修改子组件的样式 组件生命周期 生命周期：组件的运行阶段 生命周期函数：Vue 的内置函数，按组件生命周期自动按次序执行 组件创建状态 new Vue() init events &amp; lifecycle：初始化事件与生命周期函数 beforeCreate：尚未初始化数据方法 init injections &amp; reactivity：初始化 props、data、methods created：尚未形成实例模板结构【常用】 基于数据和模板，在内存中编译生成 HTML 结构 beforeMount：即将编译好的 HTML 结构渲染至浏览器中 用内存中编译完成的 HTML 结构替换掉 el 属性指定的 DOM 元素 mounted：已将编译好的 HTML 结构渲染至浏览器中，DOM 树已存在当前组件【常用】 组件运行状态 beforeUpdate：即将根据变化后最新的数据重新渲染组件的模板结构 根据变化后最新的数据重新渲染组件的模板结构 updated：已将根据变化后最新的数据重新渲染组件的模板结构【常用】 组件销毁阶段 beforeDestroy：即将销毁组件 destroyed：已将组件销毁 组件数据共享 父-&gt;子 自定义属性 props 子-&gt;父 自定义事件 $emit() 兄弟&lt;-&gt;兄弟 EventBus 利用 vue 实例中转，使用 bus.$emit() 触发自定义事件，使用bus.$on() 注册自定义事件 12345678910111213141516171819202122232425262728// sonexport default { data() { return { i = 0; }; }, methods: { a() { this.i++; this.$emit('e', this.i); }, },};// fa// &lt;Son @e='f'&gt;&lt;/Son&gt;export default { data() { return { j = 0; }; }, methods: { f(v) { this.j = v; }, },}; 123456789101112131415161718192021// send dataimport bus from './eventBus.js';export default { methods: { send_msg() { bus.$emit('share', /* data */); }, },}// receive dataimport bus from './eventBus.js';export default { created() { bus.$on('share', (/* data */) =&gt; { /* do something with data */ }); },}// eventBus.jsimport Vue from 'vue';export default new Vue(); 操作 DOM 元素ref 引用默认 vue 组件实例包含 $refs 属性，包含组件内所有的设置 ref 属性的 DOM 元素引用，其为一对象，键名是 ref 的值，键值即为相应的 DOM 对象 1234/* &lt;component ref=&quot;name&quot;&gt;&lt;/component&gt; */fun() { // using this.$refs.name} this.$nextTick() 将回调函数推迟至下一个 DOM 更新周期后执行 动态组件利用&lt;component&gt;&lt;/component&gt;实现动态组件渲染 1&lt;component is=&quot;Left&quot;&gt;&lt;/component&gt; &lt;component :is=&quot;comType&quot;&gt;&lt;/component&gt; is 属性指定预期渲染的组件的名称，可以绑定变量实现动态切换使用的组件 可以用&lt;keep-alive&gt;包裹组件，使之能在失活时缓存，从而可以高效重复使用组件 mount: activated() 钩子 组件被激活 deactivated() 钩子 组件被缓存 props: include 仅名称匹配的组件被缓存 exclude 任意名称匹配的组件不被缓存 注意 include 与 exclude 不应同时使用 插槽普通插槽将组件内部在使用组件时插入内容时提供占位符 12345678&lt;!-- 组件 --&gt;&lt;template&gt; &lt;div&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;!-- 文件 --&gt;&lt;Com&gt; g &lt;/Com&gt; 使用 &lt;slot&gt;&lt;/slot&gt; 声明一个插槽区域 内容使用 v-slot: 指令，且应用在 template 标签上，内部放置填充的内容v-slot:default 可简写为 #default 编译时，插槽内使用的数据，父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的 后备内容可以在组件内的插槽的 slot 标签内放入内容，指定若未给出应插入内容时的渲染内容 12345678&lt;!-- 组件 --&gt;&lt;template&gt; &lt;div&gt; &lt;slot&gt;default value&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;!-- 文件 --&gt;&lt;Com&gt; given value &lt;/Com&gt; 具名插槽具有多个插槽的组件，需要指定插槽的名称，才可以正确地插入部件 通过指定 name 属性实现对插槽进行区别， name 属性默认值为 default 1234567891011121314151617&lt;!-- 组件 --&gt;&lt;template&gt; &lt;div&gt; &lt;p&gt;t&lt;/p&gt; &lt;slot name=&quot;s1&quot;&gt;&lt;/slot&gt; &lt;slot name=&quot;s2&quot;&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;!-- 文件 --&gt;&lt;Com&gt; &lt;template v-slot:s1&gt; &lt;p&gt;s1&lt;/p&gt; &lt;/template&gt; &lt;template v-slot:s2&gt; &lt;p&gt;s2&lt;/p&gt; &lt;/template&gt;&lt;/Com&gt; 可以在组件内指定插槽的默认内容 作用域插槽通过插槽自子元素组件向父元素传参 12345678910&lt;!-- 子组件 --&gt;&lt;span&gt; &lt;slot v-bind:user=&quot;user&quot;&gt; {{ user.lastName }} &lt;/slot&gt;&lt;/span&gt;&lt;!-- 父组件 --&gt;&lt;current-user&gt; &lt;template v-slot:default=&quot;slotProps&quot;&gt; {{ slotProps.user.firstName }} &lt;/template&gt;&lt;/current-user&gt; 自定义指令 私有自定义指令 123456789101112131415161718192021// 使用&lt;div v-color=&quot;color&quot;&gt;color&lt;/div&gt;;export default { // 私有自定义指令声明在该节点之下np directives: { color: { // 首次绑定时调用 bind(el, binding) { el.style.color = binding.value; }, // DOM 更新时调用 update(el, binding) { el.style.color = binding.value; }, }, /** * 若binding与update相同时可简写为 * color(el, binding) {}, */ },}; 全局自定义指令 12345Vue.directive(&quot;colo&quot;, { bind() {}, update() {},});Vue.directive(&quot;colo&quot;, function () {}); 钩子函数 bind 指令绑定到元素时调用 inserted 被绑定元素被插入父节点时调用 update 组件的 VNode 更新时调用 componentUpdated 组件的 VNode 及其子 VNode 全部更新时调用 unbind 指令自元素解绑时调用 钩子函数参数 el 指令绑定的元素 binding 指令的一些属性 路由hash 地址与组件之间的对应关系 初始化配置1234567891011121314// 创建实例对象// @/src/router/index.jsimport Vue from &quot;vue&quot;;import VueRouter from &quot;vue-router&quot;;Vue.use(VueRouter);const router = new VueRouter();export default router;// 导入 App.vue// @/App.vueimport router from &quot;@/router&quot;; // 相当于 import router from '@/router/index.js';new Vue({ router, /* ... */}).$mount(&quot;#app&quot;); 模块化导入，给定文件夹，默认导入文件夹下的 index.js 文件 基本路由规定占位符与切换组件 &lt;router-view&gt;&lt;/router-view&gt; 占位符，显示组件 &lt;router-link to=&quot;/about&quot;&gt;关于&lt;/router-link&gt;路由的切换 定义路由关系 123456789101112// 导入组件import Home from &quot;@/components/Home.vue&quot;;// 声明路由关系const router = new VueRouter({ routes: [ { path: &quot;/home&quot;, component: Home, }, // ... ],}); 路由重定向 123456789const router = new VueRouter({ routes: [ { path: &quot;/&quot;, redirect: &quot;/home&quot;, }, // ... ],}); 动态路由使用动态参数实现相同组件不同路由 &lt;router-link to=&quot;/about/${id}&quot;&gt;关于&lt;/router-link&gt; 12345678910const router = new VueRouter({ routes: [ { path: &quot;/movie/:id&quot;, component: Movie, props: true, // 配置利用 props 获取参 }, // ... ],}); 组件内部获取参数 {} = this.$route.params props 方式：直接在 Vue 实例中的 props 中获取参数 路径参数 this.$route.params 查询参数 this.$route.query path：仅路径部分 &amp; fullPath：完全参数 嵌套路由路由内部的路由 1234567891011121314151617181920212223242526const router = new VueRouter({ routes: [ { path: &quot;/about&quot;, component: Home, /** * ! 重定向 * redirect: '/about/tab1', */ children: [ { path: &quot;tab1&quot;, component: Tab1, }, { /** * ! 默认子路由 */ path: &quot;&quot;, component: Tab1, }, ], // ... }, ],}); 声明式导航 &amp; 编程式导航 声明式：点击链接 &lt;a&gt; &lt;route-link&gt; 编程式：调用 API 跳转 location this.$route.push(${url}) 跳转至指定的地址，并增加一条历史记录 this.$route.replace(${url}) 跳转至指定的地址，并替换当前的历史记录 this.$route.go(${number}) 在浏览器记录中进行前进 or 后退 this.$route.push() this.$route.back() 导航守卫控制路由的访问权限 全局前置守卫在所有路由触发时起效 1router.beforeEach((to, from, next) =&gt; {}); 接收一个回调函数参数回调函数第一个参数代表将访问的对象，第二个参数代表将离开的对象，第三个代表调用允许的路由导航 调用 next()方法 next() 允许跳转 next(url) 强制跳转至指定的页面 next(false) 不允许跳转 eslint检查代码的风格的一款插件 .eslintrc.js eslint的配置文件 quotes key-spacing comma-dangle no-multiple-empty-lines no-trailing-spaces eol-last spaced-comment indent space-before-function-paren Vue3","link":"/2022/12/14/vue/"},{"title":"typescript","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282/** TS变量类型 */let an: any;let str: string = '12';let num: number = 20;let flag: boolean = true;let arr: number[] = [1];let ar: Array&lt;number&gt; = [2];let tuple: [string, number] = ['test', 10];enum Color { Red, Green, Blue,};let co: Color = Color.Red;function hello(): void { console.log('hello');}let nu: null;let un: undefined;let ne: never;/** 类型断言 */var num0: number = &lt;number&gt; &lt;any&gt; str;/** 类型推断 *//** * 变量作用域 * - 全局作用域 * - 类作用域 * - 局部作用域 *//** 运算符 *//** 条件 *//** 循环 *//** 函数 */// 可选参数 默认参数 剩余参数function add(x: number = 0, y: number = 0, z?: number/* 可选参数: 必须在参数列表最后 */, ...other: number[]): number { return x + y + (z ?? 0) + add(...other);}const sub = (x: number, y: number): number =&gt; x - yconst add_plus: (x: number, y:number) =&gt; number = (x, y) =&gt; x + y;// 匿名函数 自动执行函数 递归函数 箭头函数var res = function(a: number, b: number) { return a * b;};(() =&gt; console.log('Hello!'))();// 函数重载/** 字面量类型 */// 使用具体值作为类型let fu: '0' | '1' | '2' | '3' = '1';const fv = 1;/** Number String Boolean 包装类型 *//** Array 数组 元组 Map */// 数组let arr1: number[] = [1, 2];let arr2: Array&lt;number&gt; = [3, 4];// 元组 Tuplelet position: [number, string, boolean] = [1, '2', true];// Mapconst m: Map&lt;number, number&gt; = new Map();/** 联合类型 */var union: number | number[];union = 12;union = [12, 34];/** 枚举类型 */enum Direction { Up, Down, Left, Right,};// 枚举成员值默认是自第一个值（默认为0）开始的数值，即默认为数字枚举var dir: Direction = Direction.Up;enum Direction1 { Left = 10, Right,};// 字符串枚举必须有初始值enum Direction2 { Up = 'Up', Down = 'Down', Left = 'Left', Right = 'Right',};/** typeof */var cc: typeof position;/** 接口 interface */// 描述一个对象类型// 当然也可以使用 type 关键字声明interface Person { name: string, age: number, birth?: Date, sayHi: string | string[] | (() =&gt; string),}var csy: Person = { name: 'CSY', age: 20, birth: new Date(), sayHi: (): string =&gt; 'Hi',}const ccc: { name: string, sex?: boolean,} = { name: 'ccc',};// 接口的继承interface Human extends Person { father: Person, mother: Person}/** 类型推论 */// 自动推断变量类型// 1. 声明变量并初始化// 2. 决定函数返回值let c = 20;function f(a: number, b:number) { return a + b;}/** 类型断言 */// （可类型推论变量类型）自行指定变量的类型const alink1 = document.getElementById('link') as HTMLAnchorElement;const alink2 = &lt;HTMLAnchorElement&gt;document.getElementById('link');/** * 类 对象 * - 构造函数 * - 实例属性及实例方法 * - 访问控制修饰符 public protected private * - 继承 extends 类 | implements 接口 * - 只读 readonly (仅适用方法) */abstract class Animal {}class Human extends Animal implements Person { public a: string; protected b: number; private c: boolean; name = 'CSY'; age = 40; birth = new Date(); sayHi = () =&gt; 'Hi'; readonly d: String; constructor (v: boolean) { super(); this.c = v; }; static isHuman = (o: any) =&gt; typeof o === 'object' &amp;&amp; o instanceof Human; get e () { return this.a + this.a } set e (s) { this.a = s.toLowerCase(); }}const son: Human = new Human(true);/** * 类型兼容 不同名称相同结构的类型是等价的 * * - 类 | 若A类型内容包含B类型内容（非严格包含），则A类型变量可赋值给B类型变量 * - 接口 | 若A类型内容包含B类型内容（非严格包含），则A类型变量可赋值给B类型变量 * 类与接口亦可相互兼容 * - 函数 | 若B函数参数表包含A函数参数表（非严格包含），则A类型函数可赋值给B类型函数；相同位置参数需相同或兼容（对象多数服从少数）；返回值需相同或兼容（对象少数服从多数） *//** * 交叉类型（类似接口继承） * 将多个类型组合为同一个类型 * 重复的属性会合并为联合类型，相当于重载 */interface Co1 { a: number,}interface Co2 { b: string,}type Co = Co1 &amp; Co2;const co0: Co = { a: 12, b: '',};/** 泛型 */// 泛型方法function print &lt;T&gt; (v: T): void { console.log(v);}// T 相当于类型变量// 具体类型需用户使用时指定print&lt;number&gt;(10)print&lt;string | boolean&gt;('')// 某些情况下可自动类型推定print(1)// 类型约束 结合interface使用 extendsfunction print0 &lt;T extends Array&lt;string&gt; | string[]&gt; (v: T): void { console.log(v);}function print1 &lt;T, K extends keyof T&gt; (v: T, k: K): void { console.log(v[k]);}// keyof 关键字接受对象类型并生成键名称（字符串和数字）的联合类型// 泛型接口interface PrintInterface &lt;T&gt; { do: (v: T) =&gt; void}// 泛型类class PrintClass &lt;T&gt; { value: T;}// 泛型工具类// Partial&lt;T&gt; 创建一个类型且T中所有属性均可选type partial = Partial&lt;Person&gt;// Readonly&lt;T&gt; 创建一个类型且T中所有属性均只读type readonly = Readonly&lt;Person&gt;// Pick&lt;T, K extends keyof T&gt; 创建一个类型并从给定类型中选出一组属性type pick = Pick&lt;Person, 'name' | 'age'&gt;// Record&lt;K extends keyof any, T&gt; 构造一个对象类型，属性键为keys，属性类型为Typetype record = Record&lt;'a' | 'b', string&gt;// 索引签名类型interface Obj { [K: string]: number,}// [K: string] 表示任意string类型属性名称均可作为对象出现，且属性值为number类型变量// 映射类型 in 关键字和 keyof 关键字type p = { [K in 'x' | 'y' | 'z']: number}type q = { [K in keyof Person]: string}// 索引查询类型type props = { a: number };type typeA = props['a'];/** 命名空间（可嵌套） */namespace n { export interface Person {}; namespace nn {}}var d: n.Person = {};// 单独引用ts文件/// &lt;reference path=&quot;SomeFileName.ts&quot; /&gt;/** 模块 *//** 声明 */declare var jQuery: (selector: string) =&gt; any;","link":"/2022/12/14/typescript/"},{"title":"webpack","text":"前端工程化 模块化 js模块化 css模块化 资源模块化 组件化 复用UI结构、样式、行为 规范化 目录结构划分 编码规范化 接口规范化 文档规范化 git分支管理 自动化 自动化构建 自动部署 自动化测试 标准化企业级项目开发过程：工具、技术、流程、经验 grunt gulp =&gt; webpack(主) parcel =&gt; vite webpack前端项目工程化 代码压缩混淆 处理JavaScript兼容性 性能优化 安装webpacknpm i webpack webpack-cli -D 配置webpack在webpack.config.js文件内保存webpack的打包设定 12345678910111213141516171819202122232425262728293031// 导入 path 包const path = require('path');module.exports = { /** * mode 标记构建模式 * development 开发模式 不会代码压缩或性能优化 打包速度快 * production 发布模式 会代码压缩与性能优化 打包速度慢 * none 无模式 */ mode: 'development', /** * entry 输入文件路径，开始打包的文件路径 * * __dirname：当前文件绝对路径 */ entry: path.join(__dirname, './src/index.js'), /** * output 输出设定 */ output: { /** * path 输出文件路径 */ path: path.join(__dirname, './dist'), /** * filename 输出文件名称 */ filename: 'main.js', },} 在package.json文件内 123&quot;scripts&quot;: { &quot;dev&quot;: &quot;webpack&quot;} 使用webpacknpm run dev webpack-dev-server实时更新修改文件，从而能够随时观察编辑效果实际搭建一个本地服务器，把实时改变的文件放在内存内，以加快访问速度 安装 npm i webpack-dev-server -D 修改 package.json 文件如下： 123&quot;scripts&quot;: { &quot;dev&quot;: &quot;webpack serve&quot;} 可通过 npm run dev 编译 访问 https://localhost:8080 配置 webpack.config.js 12345678910111213141516{ devServer: { /** * 初次打包完成后自动打开浏览器 */ open: true, /** * 指定host名 */ // host: '127.0.0.1', /** * 指定端口 */ // port: 8080, },} html-webpack-plugin编译时实时移动 html 文件至项目根目录自动注入项目打包后的 js 文件和其他文件 安装 npm i html-webpack-plugin -D 配置 webpack.config.js 123456789101112// 导入 HtmlPlugin 包const HtmlPlugin = require('html-webpack-plugin');// 添加 plugins 设置{ plugins: [ new HtmlPlugin({ template: './src/index.html', filename: './index.html', }), ],} loader由于 webpack 仅可处理 js 及 json 文件加载器：协助 webpack 处理特定的文件模块 css-loader 处理 css 文件 less-loader 处理 less 文件 babel-loader 处理高级 js 语法 CSS-loader协助处理 css 文件 安装 npm i style-loader css-loader -D 配置 webpack.config.js 内的 module 选项 123456789101112131415161718{ // 第三方模块的匹配规则 module: { // 规则数组 rules: [ { // 正则表达式匹配的文件类型 test: /\\.css$/, // 使用的 loader // 特别的： loader 中的顺序不可交换，会按从后往前的顺序调用 use: [ 'style-loader', 'css-loader', ], } ], },} 在 index.js 中导入 css 文件import './css/index.css'; less-loader协助处理 less 文件 安装 npm i less less-loader -D 配置 webpack.config.js 内的 module 选项 1234567891011121314{ module: { rules: [ { test: /\\.less$/, use: [ 'style-loader', 'css-loader', 'less-loader', ], }, ], },} 在 index.js 中导入 less 文件import './css/index.less'; url-loader&amp;file-loader协助处理图片会把给定限制大小下的图片转为base64编码，否则仍使用url导入的方式 安装 npm i url-loader file-loader -D 配置 webpack.config.js 内的 module 选项 1234567891011{ module: { rules: [ { test: /\\.jpg|png|gif$/, // limit 指定转换图片的阈值 use: 'url-loader?limit=8192', }, ], },} 在 index.js 中导入图片import logo from './images/icon.png'; 给img标签赋值$('#img').attr('src', logo); babel-loader 安装 npm i babel-loader @babel/core @babel/plugin-proposal-decorators -D 配置 webpack.config.js 内的 module 选项 1234567891011{ module: { rules: [ { test: /\\.js$/, use: 'babel-loader', exclude: /node_modules/, }, ], },} 配置 babel.config.js 12345678910module.exports = { plugins: [ [ '@babel/plugin-proposal-decorators', { legacy: true, }, ], ],} 打包发布package.json 配置 1234&quot;scripts&quot;: { // --mode production 指定发布时模式为 production &quot;build&quot;: &quot;webpack --mode production&quot;} 优化js路径 1234output: { path: path.join(__dirname, './dist'), filename: 'js/main.js',} 优化img路径 12345678910{ test: /\\.jpg|png|gif$/, use: { loader: 'url-loader', options: { limit: 10240, outputPath: 'images', }, },}, 配置清理 dist 目录 clean-webpack-plugin 安装 npm i clean-webpack-plugin -D 导入与配置 webpack.config.js const {CleanWebpackPlugin} = require('clean-webpack-plugin'); 1234567plugins: [ new HtmlPlugin({ template: './src/index.html', filename: './index.html', }), new CleanWebpackPlugin(),], Source Map信息文件，保存打包前代码的详细位置信息 webpack.config.js 添加 devTools: 'eval-source-map' 选项 建议发布时去除 source map 选项 只定位行号，不暴露源码：nosources-source-map 设定定位行号且暴露源码：source-map 会生成一个独立文件 使用@导入文件 配置 12345resolve: { alias: { '@': path.join(__dirname, './src/'), },}, 使用import msg from '@/msg.js';","link":"/2022/12/14/webpack/"},{"title":"性能优化","text":"构建相关路由懒加载最主要在于降低首屏加载资源大小，仅加载所需的页面资源文件，加快页面的显示 bad12345import C from 'c'{ component: C,} good123{ component: () =&gt; import('c'),} 原理即将导航中的路由组件从静态 import 导入改为动态 import() 导入 组件懒加载原理同路由懒加载 worse1234567import C from 'c'export default { components: { C, },} better1234567const C = () =&gt; import('c')export default { components: { C, },} 做组件懒加载一般在某些特别条件下使用，如组件仅在特定条件下才展示、当前页面文件过大、组件复用性较强 外部依赖懒加载较大外部依赖可动态导入 worse1import * as THREE from 'three' better1import('three').then((THREE) =&gt; { /* do */ }) 但建议谨慎采取此方式 Tree Shaking 和 SideEffects依赖 ESM 的静态特性，进行静态分析，在生成产物中去除无用的模块或代码，从而降低生成产物的大小 webpack 默认在构建阶段会启用 Tree Shaking，在开发阶段需手动配置 webpack.config.js123456module.exports = { mode: 'development', optimization: { usedExports: true, },} webpack.config.js123module.exports = { mode: 'production',} 使用副作用 package.json123{ &quot;sideEffects&quot;: false} 某些情况下需手动标记 /*#__PURE__*/ 以标记代码，以标记语句是可执行 Tree Shaking 的 vite 原生基于 rollup 支持在构建阶段启用 Tree Shaking 构建产物压缩webpack 可以使用 terser-webpack-plugin 插件来执行代码构建产物的压缩 webpack.config.js12345678const TerserPlugin = require(&quot;terser-webpack-plugin&quot;)module.exports = { optimization: { minimize: true, minimizer: [new TerserPlugin()], },} vite 内部默认集成 esbuild 进行代码构建产物的压缩，同时支持配置为使用 terser 来执行压缩 vite.config.js1234567891011export default { esbuild: {}, build: { cssMinify: 'esbuild', minify: 'esbuild', terserOptions: {}, }, optimizeDeps: { esbuildOptions: {}, },} 静态资源构建产物（特别是图片）的压缩可以使用一些插件实现，如 compression-webpack-plugin 等 外部库按需加载外部库（特别是 UI 组件库）使用插件（如 babel-plugin-import 等）进行按需加载 代码分割可以适当进行代码分割，避免一次性加载过大的资源文件，阻碍页面的展示；也需要避免过度分割，一次性执行过多的资源获取请求 vite.config.js1234567891011export default { build: { rollupOptions: { output: { manualChunks: {}, // or: manualChunks: (id) =&gt; id, }, }, cssCodeSplit: {}, },} 内联代码文件部分小体量的 JS 文件或 CSS 文件，可以内联到 HTML 文件中，减少请求的数量 分析外部依赖可通过 webpack-bundle-analyzer 插件或 rollup-plugin-visualizer 插件来分析查看 webpack.config.js1234567const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer')module.exports = { plugins: [ new BundleAnalyzerPlugin(), ],} vite.config.js1234567import { visualizer } from 'rollup-plugin-visualizer'export default { plugins: [ visualizer(), ],} 检查项目的依赖包是否有重复引用的情况，避免出现使用同样名称不同版本的依赖包引用的情况 渲染相关骨架屏主要应用于缩短白屏时长，特别是 SPA 单页应用 原理是直接把展示骨架屏的内容放在 html 文件内，在真正内容加载完后再隐藏骨架屏的内容 虚拟滚动只渲染可视区域的列表项，非可见区域的不渲染 原理为计算列表的总高度，并在触发滚动事件时根据滚动高度更新起始下标和结束下标，从而取出相应的数据渲染元素 Worker 长任务优化将一些长任务逻辑移入到 Worker 中，避免长任务的执行阻碍 UI 渲染而影响用户体验 是否使用 Worker，需要比较 Worker 通信时长与运算时长相比是否具有足够的优势 利用 requestAnimationFrame 周期任务可以利用 requestAnimationFrame 处理周期任务 特别是需要较严格固定周期频率执行的情况（setInterval 和 setTimeout 无法保证准确的时间间隔） 同时 requestAnimationFrame 支持在页面隐藏或最小化时暂停执行周期任务，以节省性能（setInterval 和 setTimeout 不会因页面隐藏或最小化等因素暂停执行） 使用 CSS 动画过渡变换替代 JSCSS 动画 Animation、过渡 Transition、变换 Transform 相较于 JS 性能通过上更具优势，并且浏览器更易于针对性地做优化 简化 CSS 选择器避用通配符选择器 * 减少使用标签选择器 优先使用默认的样式继承 避免层数过大的选择器 代码复用及代码封装提升代码复用率，进行功能代码封装等 CSS 的样式简化，可以使用 TailwindCSS、UnoCSS 等方案 使用防抖节流防抖，使得指定函数至少间隔 n 秒才会执行一次 节流，使得指定函数在 n 秒中最多执行一次 对于容易连续触发的事件，如 mousemove、pointermove、scroll、touchmove、wheel、resize 等，通过将事件处理方法绑定为防抖节流版本的方法，避免持续多次重复执行方法 使用 will-change 优化动态效果预先将执行动画的元素设置 will-change CSS 属性，以便浏览器引擎将其视为单独图层来进行优化 注意点是，避免过度应用 will-change 属性；建议仅在需要时候 JS 动态设置该属性 减少页面重排重绘重绘指元素的非几何样式改变引起的浏览器重新渲染目标元素的现象 重绘指元素的几何样式改变引起的浏览器重新渲染整个渲染树或的现象 使用 GPU 渲染CSS中可使用如下一些方式将目标元素独立为合成层，从而进行独立渲染，以触发 GPU 渲染 指定 will-change 属性 3D 或者透视变换 perspective transform 使用加速视频解码的 video 元素 拥有 3D 上下文（WebGL）或者加速 2D 上下文的 canvas 元素 使用 opacity、filter 实现 CSS 动画或使用一个动画 webkit 变换的元素 拥有加速 CSS 过滤器的元素 元素有一个包含复合层的后代节点 元素有一个兄弟元素在复合图层渲染，且具备较低的 z-index 避免无效请求避免出现无效请求，例如表单提交频繁点击的问题，或路由切换时还有未完成的请求；对于服务器和用户来说，会造成不必要的困扰 网络相关使用 HTTP2HTTP2 支持头部压缩，能够减少数据传输量，节省消息投占用的网络的流量 且 HTTP2 支持多路复用、服务器推送等功能 gzip 压缩HTTP 头部及资源启用 gzip 压缩，能够大大减少网络传输的数据量 可以使用 compression-webpack-plugin 或 vite-plugin-compression 压缩打包资源至 gzip webpack.config.js12345const compression = require('compression-webpack-plugin')module.exports = { plugins: [new compression()],} vite.config.js12345import compression from 'vite-plugin-compression'export default { plugins: [compression()]} 对资源服务开启 gzip 支持 nginx.conf123456789gzip on;gzip_min_length 1k;gzip_comp_level 5;gzip_buffers 16 8k;gzip_http_version 1.1;gzip_types text/plain application/javascript application/x-javascript text/javascript text/xml text/css;gzip_disable &quot;MSIE [1-6]\\.&quot;;gzip_proxied any;gzip_vary on; 一般推荐提前处理完成 gzip 文件，再直接交由 nginx 服务 Cookie 简化执行网络请求时，浏览器会自动带上同源的 Cookie 信息，一定程度上会增大请求头的大小 可以通过精简 Cookie 的内容，来降低请求信息的大小 同时可以对静态资源单独部署，避免请求携带不必要的 Cookie 信息 启用 Keep-Alive通过给请求头或响应头设置 Keep-Alive 头，通常用于提示连接超时时间和最大请求量 12Connection: Keep-AliveKeep-Alive: timeout=5, max=1000 减少预检请求发起可以在跨域请求设置 Access-Control-Max-Age 响应头指定预检请求的缓存期限，从而在指定期限内的跨域请求无需进行预检请求可以直接发起请求 有效期 10min1Access-Control-Max-Age: 600 资源相关script 加载方式 正常模式 JS 会阻碍 DOM 渲染 &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt; async 模式 异步加载 JS，执行无顺序，加载完成后立即执行 可以用于加载与 DOM 无关的 JS 资源，如埋点统计等 &lt;script async src=&quot;main.js&quot;&gt;&lt;/script&gt; defer 模式 异步加载 JS，执行有顺序，加载完成后统一在 DOMContentLoaded 事件触发前执行 一般情况均可使用 defer 优化 JS 资源的加载，避免 JS 脚本加载与执行阻碍网页的渲染 &lt;script defer src=&quot;main.js&quot;&gt;&lt;/script&gt; module 模式 行为上会类似于 defer 模式 &lt;script type=&quot;module&quot; src=&quot;main.js&quot;&gt;&lt;/script&gt; fetchpriority 资源加载优先级 可以利用 fetchpriority HTML 属性指定 script 脚本加载的优先级，优先加载级别高的脚本，延后加载级别低的脚本 资源预加载需要避免 preload 和 prefetch 的混用，以避免不必要的二次自由加载 preload 预先下载当前页面将使用的资源并缓存（不会执行），会提升资源的优先级 需同时指定 as 属性与 href 属性 &lt;link rel=&quot;preload&quot; href=&quot;style.css&quot; as=&quot;style&quot; /&gt; &lt;link rel=&quot;preload&quot; href=&quot;main.js&quot; as=&quot;script&quot; /&gt; 建议指定 type 属性，以避免浏览器下载格式不支持的资源 建议同时指定 crossorigin 属性 prefetch 预加载未来页面将使用的资源，并保存在缓存内一段时间，会降低资源的优先级 要求当前页面需为安全上下文 &lt;link rel=&quot;prefetch&quot; href=&quot;main.js&quot; /&gt; modulepreload 类似于 preload 预加载当前页面将使用的模块脚本资源，并进行解析与执行 &lt;link rel=&quot;modulepreload&quot; href=&quot;main.js&quot; /&gt; prerender 预加载目标资源并提前在后台处理执行 仅部分浏览器支持该非标准特性 网络预连接一般情况下，dns-prefetch 与 preconnect 都是配对使用 但不建议过度使用 preconnect，仅用于未来一段时间极可能访问或请求的 origin；否则仅应用 dns-prefetch 同时 dns-prefetch 的浏览器兼容性优于 preconnect 建议使用以上两属性的同时指定 crossorigin 属性 dns-prefetch 提前执行目标 origin 的 DNS 解析，可以加快未来将访问或请求的 origin 的处理速度（直接使用已预先解析的 DNS 缓存） &lt;link rel=&quot;dns-prefetch&quot; href=&quot;https://fonts.googleapis.com/&quot; /&gt; preconnect 提前执行目标 origin 的连接 —— DNS 解析、TCP 连接（及 TLS 握手），可以加快未来将访问或请求的 origin 的处理速度 &lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.googleapis.com/&quot; /&gt; 避用外部依赖尽量减少对非必要的外部依赖的使用，使用轻量级别替代方案或者自行实现 常见的如： 使用轻量级 day.js 替代 moment.js 使用 ESM 的 lodash-es 替代 CJS 的 lodash 使用 CDN 服务静态资源CDN 即 Content Delivery Network，其具有分布于多个地域的服务器阵列 CDN 可以降低私有服务器的访问压力 地理位置的距离可能相对更近，一定程度上可以降低网络资源加载的时延 CDN 保证了比较正确的缓存配置 合理配置缓存策略服务器在响应资源时，通过指定 Expires 响应头或 Cache-Control 响应头来控制浏览器该资源的缓存策略；若被指定为强缓存并且在有效期内直接使用缓存；反之若为被禁止使用缓存，则进行协商缓存，通过 If-Modified-Since 头向服务器提供浏览器缓存的资源的修改时间（在获取资源时服务器通过 Last-Modified 头指定）或通过 If-None-Match 头向服务器提供浏览器缓存的资源的标识符（在获取资源时服务器通过 ETag 头指定） Expires（推荐使用 Cache-Control 代替，其优先级更高）【响应头】 指定缓存失效的时间 Cache-Control【响应头，请求头】 配置缓存的策略及有效期 no-store 不允许缓存 no-cache 允许缓存，但使用前需进行服务端验证 must-revalidate 允许缓存，有效期内直接使用缓存，超出有效期需进行服务端验证，通常结合 max-age=N 使用 max-age=N 指定缓存的有效期 Last-Modified【响应头】/ If-Modified-Since【请求头】 资源最近修改时间 ETag【响应头】/ If-None-Match【请求头】 资源唯一标识符 ServiceWorker 实现可控缓存利用 ServiceWorker 结合 CacheStorage 实现可控缓存，原理是基于受 ServiceWorker 控制的上下文会在 ServiceWorker 全局触发 fetch 事件，可以通过调用返回的 FetchEvent 的 respondWith() 方法自定义响应 图片字体相关webp 图片webp 格式图片大小通常比同等情况下的其他格式图片大小有较大优势，因此若浏览器支持 webp 格式图片，优先使用 webp 格式图片 可以利用离线或在线 webp 图片格式转换工具转换图片格式为 webp 图片懒加载 JS 手动控制 初始不指定图片标签的 src 属性，直到图片需要展示时再指定其 src 属性，避免图片的自动预加载 1&lt;img data-src=&quot;/img/png&quot; /&gt; 1234// 适当情况下调用该方法function loadImg(el) { el.src = el.getAttribute('data-src')} 利用 img 标签特性（更推荐） 可以设置 img 标签的 loading 属性实现懒加载功能，将属性值指定为 lazy 以惰性加载图片 同时可以指定 img 标签的 fetchpriority 属性，以控制获取图片资源的优先级，设定为 high 以提升获取的优先级，设定为 low 以降低获取的优先级 同时可以指定 img 标签的 decoding 属性，以设定解码图片的模式（是否允许在图片解码完成前展示图片），设定为 sync 以同步解码图片，设定为 async 以异步解码图片 1&lt;img src=&quot;/img/png&quot; alt=&quot;&quot; loading=&quot;lazy&quot; fetchpriority=&quot;auto&quot; decoding=&quot;auto&quot; /&gt; 字体图标将小图标利用字体形式加载，如 IconFont 1@import url('//at.alicdn.com/t/font_8d5l8fzk5b87iudi.css'); 1&lt;i class=&quot;iconfont icon-xxx&quot;&gt;&lt;/i&gt; 通常加载资源大小会更小，并且能够避免重复加载图片并降低请求数量，且支持修改各类字体样式 内联图片将小图片转换为 base64 编码内联入 html 文档，可以减少请求数量 webpack 中可以使用 url-loader 插件自动转换内联图片 webpack.config.js1234567891011121314151617module.exports = { module: { rules: [ { test: /\\.(png|jpg|gif)$/i, use: [ { loader: 'url-loader', options: { limit: 1024 * 8, }, }, ], }, ], },} vite 原生支持内联图片，默认在图片大小小于 4KB 时启用 可以通过 build.assetsInlineLimit 选项配置启用的阈值 vite.config.js12345export default { build: { assetsInlineLimit: 4096, }} 图片裁剪对图片生成多个尺寸的备用图片，使用时根据需要加载不同尺寸的图片，减少不必要的资源流量 图片单独部署将图片等静态资源部署在单独的静态资源服务器或是 CDN 上，避免直接打包到项目中 图片尺寸指定设置图片标签的尺寸大小，防止图片加载中导致页面布局抖动，影响 CLS 指标 字体按需生成使用第三方字体库时，尽可能按需生成，避免不必要的全量引入字体库 代码相关JSON 字符串使用对于大对象数据，尽量采用 JSON 格式而非 JS 对象格式，因为 JSON 语法比 JS 简单，解析速度更快 如 vite 支持将 JSON 文件打包为 JSON 字符串而非 JS 对象 vite.config.js12345export default { json: { stringify: true, },} if 逻辑提前跳出提前结束的逻辑利于编译器的优化 bad1234567891011function () { if (A) { if (B) { return 'good' } else { return 'bad' } } else { return 'bad' }} good1234567function () { if (A &amp;&amp; B) { return 'good' } return 'bad'} 逻辑能提前结束就提前结束 switch 连续值优化switch 对于连续值会处理成数组，而数组会具有更高效率的随机访问性能 bad1234567function get(/* @type {1 - 10} */ level) { if (level &gt;= 10) return 100 if (level &gt;= 9) return 80 if (level &gt;= 6) return 50 if (level &gt;= 1) return 20 return 10} good123456789101112131415function getPrice(level) { switch(level) { case 10: return 100 case 9: return 80 case 8: case 7: case 6: return 50 case 5: case 4: case 3: case 2: case 1: return 20 default: return 10 }} 若条件可以处理成连续的数字，可以使用 switch 来进行优化 循环减少执行次数对于循环，满足条件或完成任务后即刻跳出，避免不必要的执行损耗 bad123456789function find(data) { let result = null for (let i = 0; i &lt; data.length; i++) { if (data[i].key === KEY) { result = data[i] } } return result} good1234567function find(data) { for (let i = 0; i &lt; data.length; i++) { if (data[i].key === KEY) { return data[i] } }} 提取集合数组长度在循环处理数组、集合等容器的元素，若可以保证容器的容量不会发生变化，可以提前提取容器的容量，避免在循环中重复获取 适当使用位运算对于一些和 2 相关的乘除法或者条件相关的，可以用位运算替代 bad1const A = 2 ** 8 good12const A = 2 &lt;&lt; 3const isPowerOfTwo = n =&gt; (n &gt; 0) &amp;&amp; (n &amp; (n - 1) === 0)","link":"/2023/09/18/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"title":"面试-CSS","text":"","link":"/2023/09/27/%E9%9D%A2%E8%AF%95-CSS/"},{"title":"前端学习路线","text":"基础 学习资料 初学时可以参考菜鸟教程及W3School文档 学习到一定程度后推荐使用MDN（特别是英文文档，因为中文文档存在更新不及时的情况）或参考相应的官方文档 IDE 推荐使用 VSCode IDE 亦可使用 WebStorm IDE（可以申请学生版） HTML基础语法、标签、元素、表单、表格列表、媒体标签、语义化标签 CSS基础语法、盒模型、浮动布局、定位、显示、弹性盒子布局、网格布局、响应式设计、媒体查询 JavaScript基础语法、严格模式、作用域、变量提升、面向对象OOP、DOM模型、事件与事件冒泡、BOM模型、JSON、ES6+、WebAPI AjaxXMLHttpRequest 对象、Ajax 请求与响应、axios 库 计算机网络基础网络层次划分、OSI 七层网络模型、子网掩码及网络划分、IP地址、TCP/IP协议、UDP协议、DNS协议、NAT协议、DHCP协议、HTTP协议 GitGit 是编程领域中目前最主流的版本管理工具，基本上不管是日常开发还是工作开发都在广泛地使用 Git 同时，Github 作为全球最大的技术交流平台，积极参与社区建设也是很重要的一环 学习角度来说，学习 Git，需要了解一些 Git 的基本概念、一些 Git 的基本命令以及 GitHub 的基本操作 Node.jsNode.js 允许在浏览器之外的环境运行 JavaScript 代码 学习角度来说，学习 Node.js，需要了解 Node.js 的使用以及一些 Node.js 的常见模块 包管理工具目前主流的包管理工具主要是 npm yarn pnpm 项目构建工具目前主流的项目构建工具主要是 webpack vite Vue模板、条件语句、循环语句、样式绑定、计算属性、监听属性、表单双向绑定、自定义事件、组件生命周期、自定义组件、单页面组件、路由 Vue Router TypeScript基本类型、变量声明、运算符、条件语句、循环语句、内建对象、数组、元组、对象、类、接口、模块、命名空间、命名文件 React元素渲染、JSX、组件、状态、属性、事件处理、条件渲染、组件API、组件生命周期 参考黑马程序员前端学习路线 个人比较推荐这个学习路线，更加突出重点尚硅谷前端学习路线 个人觉得这个的内容非常全面，但需要注意没必要都学习其中的内容","link":"/2022/07/20/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"title":"面试-HTML","text":"语义化标签作用 优化 SEO，提升页面的搜索引擎的优先级 便于其他设备解析，如屏幕阅读器等，方便残障人员的访问 优化整体代码格式，增强语义化，便于代码的开发与维护 便于用户阅读，特别是针对样式丢失的情形","link":"/2023/09/27/%E9%9D%A2%E8%AF%95-HTML/"},{"title":"面试-JavaScript","text":"","link":"/2023/09/27/%E9%9D%A2%E8%AF%95-JavaScript/"},{"title":"面试-计算机网络","text":"HTTP2 与 HTTP1 区别 HTTP2 是一个二进制协议 HTTP1.1 的报头必须是文本，数据体可以是文本或是二进制HTTP2 的报头和数据体均为二进制，分别被称为头信息帧和数据帧 HTTP2 实现头信息压缩 HTTP2 中头信息使用 gzip 或 compress 压缩后再发送HTTP2 中客户端和服务器同时维护一张头信息表，所有字段存储在表中并生成索引号，头信息不会重复多次发送，后续头信息利用索引号避免重复发送 HTTP2 支持多路复用 HTTP2 支持同时无序的发送多个请求或响应，从而避免队头堵塞的问题 HTTP2 使用数据流的概念 因为 HTTP2 的数据包不是按序发送的，同个连接内的数据包可能属于不同的请求；因此 HTTP2 中将每个请求或响应的数据包均作为数据流给出唯一的编号，每个数据包均需标记数据流 ID，以表示其所属的数据流 ID HTTP2 支持服务器推送 HTTP2 允许服务器未经请求，主导向客户端发送资源，可以一定程度上减少延迟时间 HTTP3 与 HTTP2 区别 流量控制、传输可靠性 集成 TLS 加密功能 多路复用 - 同一物理连接上可以有多个独立的逻辑数据流 快速连接 - 基于 UDP，仅需 1~2 RTT 建立连接 TCP 与 UDP 区别 TCP 是面向连接；UDP 是面向无连接 TCP 发送数据前必须建立连接后发送数据UDP 发送数据前不建立连接直接发送 TCP 是可靠传输，使用流量控制和拥塞控制；UDP 是不可靠传输，不支持流量控制和拥塞控制 TCP 连接通过给包编号并通过接收到数据后返回的 ACK 判断传输是否成功，从而确定是否重传数据；在出现拥塞时，会通过减小注入网络数据的速率和数量以缓解拥塞UDP 不会进行检测包的发送成功与否，以恒定速率发送数据，不会根据网络状况调整发送速率 TCP 只能是一对一；UDP 可以一对一或一对多或多对一或多对多 TCP 连接只有两个端点，只能进行点对点的数据传输UDP 支持单播、多播、广播功能 TCP 是面向字节流传输；UDP 是面向报文传输 TCP 连接在不保留报文边界情况下以字节流传输数据UDP 连接在保留报文边界情况下以报文形式传输数据 TCP 首部最小 20 字节到 60 字节；UDP 首部为 8 字节 TCP 使用要求可靠连接的应用；UDP 适用于实时应用 常见 HTTP 状态码 200 OK 服务器成功处理 301 Moved Permanently 永久重定向 302 Found 临时重定向资源 304 Not Modified 使用客户端缓存 403 Forbidden 服务器拒绝资源访问 404 Not Found 服务器未找到资源或无原因的拒绝访问 500 Internal Server Error 服务器执行出错 TCP/IP五层协议 应用层 - 直接为应用进程提供服务 | HTTP HTTPS DNS FTP SMTP 传输层 - 负责为主机的进程提供通信服务 | TCP UDP 网络层 - 负责为主机提供通信服务 | IP寻址 数据链路层 - 负责将数据封装为帧并在链路间传输 | MAC地址 物理层 - 负责保证数据在物理介质上传输","link":"/2023/09/25/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"title":"面试-工程","text":"Git 常用指令 git init 创建一个空 git 代码库或初始化现有的 git 代码库 git clone 从远程克隆一个代码库到本地 git pull 从远程仓库或其他本地分支获取更新并与当前仓库分支合并 git push 将本地分支更新推送到远程仓库 git fetch 从远程仓库获取更新 git add 添加更新到暂存区 git commit 提交暂存区到仓库区 常见前端网络安全漏洞 XSS 攻击 - 跨站脚本攻击 攻击者向网站中注入恶意代码，使得其在浏览器中执行，并用于恶意目的如盗取客户端信息等 浏览器将恶意代码当成正常代码的一部分执行而导致 避免服务端拼接代码；充分转义将插入代码的内容；指定 CSP 策略，控制允许加载和执行的外部资源；敏感资源保护，如 Cookie 的 HttpOnly 策略、验证码等 CSRF 攻击 - 跨站请求伪造攻击 攻击者诱导用户进入第三方网站，随后第三方网站向被攻击网站发送跨站请求，利用用户保存的登录态执行恶意操作 Cookie 会在同源请求中自动携带并发送给服务器 进行同源检测，利用 origin 头和 referer 头；设置 Cookie 为 SameOrigin，阻止第三方页面使用该 Cookie；启用 Cookie 双重验证，将 Cookie 放入请求参数；使用 CSRF Token，请求参数中使用专属 token 验证身份","link":"/2023/09/28/%E9%9D%A2%E8%AF%95-%E5%B7%A5%E7%A8%8B/"},{"title":"面试-Vue","text":"Vue diff 算法 首先比较新老节点是否为同一节点，若不是的话则删除该节点并创建新节点以进行替换 若为相同节点，则会对节点的子节点进行判断 先判断是否属于一方无子节点而一方有子节点的情况 若双方均有子节点，则判断如何对新老节点的子节点进行操作；若找到相同的子节点，则对子节点的子节点也递归进行比较 Vue3 相较于 Vue2 的区别 Vue3 的响应式基于 Proxy 实现；Vue2 的响应式基于 Object.defineProperty 实现 Vue3 更推荐使用 Composition API；Vue2 更推荐使用 Options API Vue3 相较 Vue2 更利用 TypeScript 开发 Vue3 相对于 Vue2 更支持 TreeShaking 组件通信方式 props &amp; emits 父=&gt;子 &amp; 子=&gt;父 provide &amp; inject 祖=&gt;孙 ref|$refs 引用 &amp; expose 事件总线 EventBus &amp; $on|$emit $parent &amp; $root $attrs &lt;keep-alive&gt; 理解在组件切换的时候，保存一些组件的状态防止重复渲染 DOM LRU 缓存策略 - 找出最久未使用的数据并置换新的数据通常基于链表实现，将新数据插至链表头部，若命中已有数据则将老数据移至链表头部，链表满后则丢弃链表尾部的数据 此时组件会增加 deactivated 与 activated 生命周期钩子，而替代 mounted 和 unmounted 生命周期钩子 nextTick() 理解作为 Vue 内部的异步队列的调用方法同时提供给开发者使用，核心是利用了如 Promise、MutationObserver、setImmediate、setTimeout 等原生 JavaScript 方法来模拟对应的微/宏任务的实现，本质是对 JavaScript 执行原理 EventLoop 的一种应用 通常在数据变化后执行的某个操作需要使用随数据变化而变化的 DOM 结构的时候或需在 created 生命周期内修改 DOM 结构时使用 MVVM 概念Model - 数据模型，定义数据和业务逻辑 View - UI 视图，负责数据展示 ViewModel - 负责监听 Model 数据改变并控制视图更新，同时处理用户交互操作","link":"/2023/09/25/%E9%9D%A2%E8%AF%95-Vue/"}],"tags":[{"name":"Frontend","slug":"Frontend","link":"/tags/Frontend/"},{"name":"Web API","slug":"Web-API","link":"/tags/Web-API/"},{"name":"Backend","slug":"Backend","link":"/tags/Backend/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"FrameWork","slug":"FrameWork","link":"/tags/FrameWork/"},{"name":"Other","slug":"Other","link":"/tags/Other/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Tool","slug":"Tool","link":"/tags/Tool/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"Library","slug":"Library","link":"/tags/Library/"},{"name":"Interview","slug":"Interview","link":"/tags/Interview/"}],"categories":[{"name":"Frontend","slug":"Frontend","link":"/categories/Frontend/"},{"name":"Web API","slug":"Frontend/Web-API","link":"/categories/Frontend/Web-API/"},{"name":"Backend","slug":"Backend","link":"/categories/Backend/"},{"name":"Other","slug":"Frontend/Other","link":"/categories/Frontend/Other/"},{"name":"FrameWork","slug":"Backend/FrameWork","link":"/categories/Backend/FrameWork/"},{"name":"CSS","slug":"Frontend/CSS","link":"/categories/Frontend/CSS/"},{"name":"Tool","slug":"Frontend/Tool","link":"/categories/Frontend/Tool/"},{"name":"Other","slug":"Other","link":"/categories/Other/"},{"name":"HTML","slug":"Frontend/HTML","link":"/categories/Frontend/HTML/"},{"name":"Library","slug":"Frontend/Library","link":"/categories/Frontend/Library/"},{"name":"JavaScript","slug":"Frontend/JavaScript","link":"/categories/Frontend/JavaScript/"},{"name":"FrameWork","slug":"Frontend/FrameWork","link":"/categories/Frontend/FrameWork/"},{"name":"Interview","slug":"Interview","link":"/categories/Interview/"}],"pages":[{"title":"","text":"个人简介信息安全专业 全栈方向，主前端方向 相信技术能够改变世界 时间轴记录","link":"/about/"},{"title":"","text":"🎈🎈微笑墙🎈🎈 彭小苒 唐艺昕 李一桐 gakki 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/album/"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://removeif.github.io/images/avatar.jpg 网站名称：辣椒の酱 网站地址：https://removeif.github.io 网站简介：后端开发，技术分享 加载中，稍等几秒...","link":"/friend/"},{"title":"","text":"哪怕世界在历史三峡中漂流，你我有彼此在 命运以痛吻我，我愿报之以歌 凡是过往，皆为序章 每一次抉择都期盼一场苦尽甜来 总有奋不顾身的相信，总要坚韧恒久的勇气","link":"/message/"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: '46a9f3481b46ea0129d8', clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24', id: '666666', repo: 'issue_database', owner: 'removeif', admin: \"removeif\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/"},{"title":"","text":"温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/"}]}