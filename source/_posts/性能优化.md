---
title: 性能优化
date: 2023-09-18 12:36:26
tags:
- Frontend
- Other
categories:
- Frontend
- Other
thumbnail: 
cover: 
toc: true
recommend: 1
keywords: 
uniqueId: '2023-09-18 12:36:26/性能优化.html'
mathJax: false
---

## 构建相关

### 路由懒加载

最主要在于降低首屏加载资源大小，仅加载所需的页面资源文件，加快页面的显示

```js
import C from 'c'

{
  component: C,
}
```

```js
{
  component: () => import('c'),
}
```

原理即将导航中的路由组件从静态 `import` 导入改为动态 `import()` 导入

### 组件懒加载

原理同路由懒加载

```js
import C from 'c'

export default {
  components: {
    C,
  },
}
```

```js
const C = () => import('c')

export default {
  components: {
    C,
  },
}
```

做组件懒加载一般在某些特别条件下使用，如组件仅在特定条件下才展示、当前页面文件过大、组件复用性较强

### Tree Shaking

依赖 ESM 的静态特性，进行静态分析，在生成产物中去除无用的模块或代码，从而降低生成产物的大小

webpack 默认在构建阶段会启用 Tree Shaking，在开发阶段需手动配置

```js webpack.config.js
module.exports = {
 mode: 'development',
 optimization: {
   usedExports: true,
 },
}
```

```js webpack.config.js
module.exports = {
 mode: 'production',
}
```

使用副作用

```json package.json
{
  "sideEffects": false
}
```

某些情况下需手动标记 `/*#__PURE__*/` 以标记代码，以标记语句是可执行 Tree Shaking 的

vite 原生基于 rollup 支持在构建阶段启用 Tree Shaking

## 渲染相关

### 骨架屏

主要应用于缩短白屏时长，特别是 SPA 单页应用

原理是直接把展示骨架屏的内容放在 html 文件内，在真正内容加载完后再隐藏骨架屏的内容

### 虚拟滚动

只渲染可视区域的列表项，非可见区域的不渲染

原理为计算列表的总高度，并在触发滚动事件时根据滚动高度更新起始下标和结束下标，从而取出相应的数据渲染元素

### Worker 长任务优化

将一些长任务逻辑移入到 Worker 中，避免长任务的执行阻碍 UI 渲染而影响用户体验

是否使用 Worker，需要比较 Worker 通信时长与运算时长相比是否具有足够的优势

### 利用 requestAnimationFrame 周期任务

可以利用 requestAnimationFrame 处理周期任务

特别是需要较严格固定周期频率执行的情况（setInterval 和 setTimeout 无法保证准确的时间间隔）

同时可以在页面隐藏或最小化时暂停执行周期任务，以节省性能（setInterval 和 setTimeout 不会因页面隐藏或最小化等因素暂停执行）

## 资源相关

### script 加载方式

* 正常模式

JS 会阻碍 DOM 渲染

`<script src="main.js"></script>`

* `async` 模式

异步加载 JS，执行无顺序，加载完成后立即执行

可以用于加载与 DOM 无关的 JS 资源，如埋点统计等

`<script async src="main.js"></script>`

* `defer` 模式

异步加载 JS，执行有顺序，加载完成后统一在 DOMContentLoaded 事件触发前执行

一般情况均可使用 defer 优化 JS 资源的加载，避免 JS 脚本加载与执行阻碍网页的渲染

`<script defer src="main.js"></script>`

* `module` 模式

行为上会类似于 defer 模式

`<script type="module" src="main.js"></script>`

### 资源预加载

需要避免 `preload` 和 `prefetch` 的混用，以避免不必要的二次自由加载

* `preload`

预先下载当前页面将使用的资源并缓存（不会执行），会提升资源的优先级

需同时指定 `as` 属性与 `href` 属性

`<link rel="preload" href="style.css" as="style" />`

`<link rel="preload" href="main.js" as="script" />`

建议指定 `type` 属性，以避免浏览器下载格式不支持的资源

建议同时指定 `crossorigin` 属性

* `prefetch`

预加载未来页面将使用的资源，并保存在缓存内一段时间，会降低资源的优先级

要求当前页面需为安全上下文

`<link rel="prefetch" href="main.js" />`

* `modulepreload`

类似于 `preload`

预加载当前页面将使用的模块脚本资源，并进行解析与执行

`<link rel="modulepreload" href="main.js" />`

* `prerender`

预加载目标资源并提前在后台处理执行

仅部分浏览器支持该非标准特性

### 网络预连接

一般情况下，`dns-prefetch` 与 `preconnect` 都是配对使用

但不建议过度使用 `preconnect`，仅用于未来一段时间极可能访问或请求的 origin；否则仅应用 `dns-prefetch`

同时 `dns-prefetch` 的浏览器兼容性优于 `preconnect`

建议使用以上两属性的同时指定 `crossorigin` 属性

* `dns-prefetch`

提前执行目标 origin 的 DNS 解析，可以加快未来将访问或请求的 origin 的处理速度（直接使用已预先解析的 DNS 缓存）

`<link rel="dns-prefetch" href="https://fonts.googleapis.com/" />`

* `preconnect`

提前执行目标 origin 的连接 —— DNS 解析、TCP 连接（及 TLS 握手），可以加快未来将访问或请求的 origin 的处理速度

`<link rel="preconnect" href="https://fonts.googleapis.com/" />`

## 图片相关

### webp 图片

webp 格式图片大小通常比同等情况下的其他格式图片大小有较大优势，因此若浏览器支持 webp 格式图片，优先使用 webp 格式图片

可以利用 webp 图片格式转换工具转换图片格式为 webp

### 图片懒加载

* JS 手动控制

初始不指定图片标签的 `src` 属性，直到图片需要展示时再指定其 `src` 属性，避免图片的自动预加载

```html
<img data-src="/img/png" />
```

```js
function loadImg(el) {
  el.src = el.getAttribute('data-src')
}
```

* 利用 img 标签特性

亦可以设置 `img` 标签的 `loading` 属性实现，将属性值指定为 `lazy` 以惰性加载图片

同时可以指定 `img` 标签的 `fetchpriority` 属性，以控制获取图片资源的优先级，设定为 `high` 以提升获取的优先级，设定为 `low` 以降低获取的优先级

同时可以指定 `img` 标签的 `decoding` 属性，以设定解码图片的模式（是否允许在图片解码完成前展示图片），设定为 `sync` 以同步解码图片，设定为 `async` 以异步解码图片

```html
<img src="/img/png" alt="" loading="lazy" fetchpriority="auto" decoding="auto" />
```

### 字体图标

将小图标利用字体形式加载，如 IconFont

```css
@import url('//at.alicdn.com/t/font_8d5l8fzk5b87iudi.css');
```

```html
<i class="iconfont icon-xxx"></i>
```

通常加载资源大小会更小，并且能够避免重复加载图片并降低请求数量，且支持修改各类字体样式

### 内联图片

将小图片转换为 base64 编码内联入 html 文档，适当情况可以减少请求数量

webpack 中可以使用 `url-loader` 插件自动转换内联图片

```ts webpack.config.js
module.exports = {
  module: {
    rules: [
      {
        test: /\.(png|jpg|gif)$/i,
        use: [
          {
            loader: 'url-loader',
            options: {
              limit: 1024 * 8,
            },
          },
        ],
      },
    ],
  },
}
```

vite 原生支持内联图片，默认在图片大小小于 4KB 时启用

可以通过 `build.assetsInlineLimit` 选项配置启用的阈值

```js

export default {
  build: {
    assetsInlineLimit: 4096,
  }
}
```

---

加载过程中

尽可能的减小资源的大小

业务代码本身尽可能的不要重复，提高组件化的使用，提示代码的复用率，这里不止是JS，CSS样式也是一样
压缩静态资源，一般脚手架都默认会处理，自建项目可检查是否有压缩
html中的DOM层级控制不要太深以及减少不必要的DOM使用，尽可能发挥伪元素及CSS的使用
检查项目的依赖包是否有重复引用的情况，不同的依赖包可能引用了同一个不同版本的包，可通过webpack-bundle-analyzer插件分析查看
UI组件库或其他库使用babel-plugin-import插件进行按需加载
组件按需加载，使用AsyncComponent仅加载首屏组件
动态导入第三方比较大的模块，import('/modules/echart.js) .then((module) => {})，但不要滥用，结合实际场景使用
减小第三方库的大小，如Moment.js/lodash等，使用轻量级别替代方案或者自己重新实现
对首评秒开要求较高的，可对首屏请求的接口进行拆分，快速响应首屏需要用到的字段，其他的数据异步加载
HTTP头部Cookie的精简，去除不必要的Cookie，静态资源做独立域名部署，避免请求携带Cookie
HTTP头部开启gzip压缩，可大大减小网络传输的数据量
HTTP头部开启keep-alive
升级HTTP到2.0，2.0的头部压缩，减少了数据传输量，能够节省消息头占用的网络的流量，且还有多路复用等优势

尽可能的减少资源的次数

JS/CSS数量不可太分散，避免一下发起太多的请求，必要将部分资源合并在一起，减少请求的数量。但是在合并的过程中需求在体积和数量之间权衡，并不是越少越好，可将最大的体积控制在一个范围内进行合并
部分小体量级别的JS/CSS可内联到HTML中，减少请求数量
减小预检请求OPTIONS的发起，可通过服务端设置Access-Control-Max-Age字段或改为发起简单请求
取消无效请求，表单提交频繁点击，路由切换时还有未完成的请求。这些都会产生无效请求，对服务器和用户体验都是不好的
缓存策略
开启http强缓存与协商缓存，对于不同类型的资源使用不同的缓存策略
静态资源开启CDN服务
对于不常变化的数据包括外部JS/CSS资源，可进行前端浏览器缓存，减少请求，但此类缓存需设定好清除及更新的机制

其他资源优化

图片裁剪，针对使用场景进行相应的裁剪
大图不要打包在项目中，上传到单独的静态资源服务器或是CDN中
图片上传前进行压缩，切记不要使用原图
设置图片标签尺寸大小，防止图片加载中导致页面布局抖动，影响CLS指标的数值
使用第三方字体库时尽可能按需文字生成
加载字体的时候会导致页面文字有一定的闪烁抖动，可在进入需要用到的页面前使用preload提前进行加载

页面渲染时

尽量多使用CSS3动画
合理使用CSS，避免通配符，最大化样式继承，少用标签选择器，减少过深嵌套等

用户界面交互

减少页面重排、重绘
防抖节流的使用
开启GPU加速，CSS中可使用以下属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、webGL、Video）来触发 GPU 渲染
对未来某个时间内需要执行动画的元素，将其标记为 will-change，这样渲染引擎会将该元素单独生成一个图层
