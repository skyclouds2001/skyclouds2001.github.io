---
title: 性能优化
date: 2023-09-18 12:36:26
tags:
- Frontend
- Other
categories:
- Frontend
- Other
thumbnail: 
---

## 打包相关

### 路由懒加载

最主要在于降低首屏加载资源大小，仅加载所需的页面资源文件，加快页面的显示

```js
import C from 'c'

{
  component: C,
}
```

```js
{
  component: () => import('c'),
}
```

原理即将导航中的路由组件从静态 ESM 导入改为动态 import() 导入

### 组件懒加载

原理同路由懒加载

```js
import C from 'c'

export default {
  components: {
    C,
  },
}
```

```js
const C = () => import('c')

export default {
  components: {
    C,
  },
}
```

做组件懒加载的场景：组件仅在特定条件下才展示、当前页面文件过大、组件复用性较强

### Tree Shaking

依赖 ESM 特性，进行静态依赖分析，在产物代码文件中去除未使用的部分

因此建议使用函数式编程，以便利 Tree Shaking

## 渲染相关

### 骨架屏

主要应用于缩短白屏时长，特别是 SPA 单页应用

原理是直接把展示骨架屏的内容放在 html 文件内，在真正内容加载完后再隐藏骨架屏的内容

### 虚拟滚动

只渲染可视区域的列表项，非可见区域的不渲染

原理为计算列表的总高度，并在触发滚动事件时根据滚动高度更新起始下标和结束下标，从而取出相应的数据渲染元素

### Worker 长任务优化

将一些长任务逻辑移入到 Worker 中

无论是 Web Worker、Shared Worker 或 Service Worker 均可

是否使用 Worker，需要比较 Worker 通信时长与运算时长相比是否具有足够的优势

### requestAnimationFrame 周期任务

可以利用 requestAnimationFrame 处理周期任务

特别是需要较严格固定周期频率执行的情况

同时可以在页面隐藏或最小化时暂停执行周期任务，以节省性能

## 资源相关

### script 加载方式

* 正常模式

JS 会阻碍 DOM 渲染

`<script src="main.js"></script>`

* async 模式

异步加载 JS，执行无顺序，加载完成后立即执行

可以用于加载与 DOM 无关的 JS 资源，如埋点统计等

`<script async src="main.js"></script>`

* defer 模式

异步加载 JS，执行有顺序，加载完成后统一在 DOMContentLoaded 事件触发前执行

一般情况均可使用 defer 优化 JS 资源的加载

`<script defer src="main.js"></script>`

* module 模式

行为上会类似于 defer 模式

`<script type="module" src="main.js"></script>`

### 资源预加载

需要避免 preload 和 prefetch 的混用，以避免不必要的二次自由加载

* preload

预先下载当前页面将使用的资源并缓存（不会执行），会提升资源的优先级

需同时指定 as 属性与 href 属性

`<link rel="preload" href="style.css" as="style" />`

`<link rel="preload" href="main.js" as="script" />`

建议指定 type 属性，以避免浏览器下载格式不支持的资源

建议同时指定 crossorigin 属性

* prefetch

预加载未来页面将使用的资源，并保存在缓存内一段时间，会降低资源的优先级

要求当前页面需为安全上下文

`<link rel="prefetch" href="main.js" />`

* modulepreload

类似于 preload

预加载当前页面将使用的模块脚本资源，并进行解析与执行

`<link rel="modulepreload" href="main.js" />`

* prerender

预加载目标资源并提前在后台处理执行

### 预连接

一般情况下，dns-prefetch 与 preconnect 都是配对使用

但不建议过度使用 preconnect，仅用于未来一段时间极可能访问或请求的 origin；否则仅应用 dns-prefetch

同时 dns-prefetch 的浏览器兼容性优于 preconnect

建议同时指定 crossorigin 属性

* dns-prefetch

提前执行目标 origin 的 DNS 解析，可以加快未来将访问或请求的 origin 的处理速度（直接使用已预先解析的 DNS 缓存）

`<link rel="dns-prefetch" href="https://fonts.googleapis.com/" />`

* preconnect

提前执行目标 origin 的连接 —— DNS 解析、TCP 连接（及 TLS 握手），可以加快未来将访问或请求的 origin 的处理速度

`<link rel="preconnect" href="https://fonts.googleapis.com/" />`

## 图片相关

### webp 图片

webp 图片大小通常比同等情况下的其他格式图片有优势，因此在浏览器支持情况下尽量启用 webp 图片

### 图片懒加载

* JS 方式

动态在图片需要展示时再指定其 src 属性，避免图片的自动预加载

### 字体图标

将小图标利用字体形式加载

通常加载资源大小会更小，并且能够避免重复加载图片并降低请求数量，且能够自由地修改各类样式

### 内联图片

将小图片转换为 base64 编码内联入 html 文档，适当情况可以减少请求数量

webpack 中可以使用 `url-loader` 插件处理

---

加载过程中

尽可能的减小资源的大小

业务代码本身尽可能的不要重复，提高组件化的使用，提示代码的复用率，这里不止是JS，CSS样式也是一样
压缩静态资源，一般脚手架都默认会处理，自建项目可检查是否有压缩
html中的DOM层级控制不要太深以及减少不必要的DOM使用，尽可能发挥伪元素及CSS的使用
检查项目的依赖包是否有重复引用的情况，不同的依赖包可能引用了同一个不同版本的包，可通过webpack-bundle-analyzer插件分析查看
UI组件库或其他库使用babel-plugin-import插件进行按需加载
组件按需加载，使用AsyncComponent仅加载首屏组件
动态导入第三方比较大的模块，import('/modules/echart.js) .then((module) => {})，但不要滥用，结合实际场景使用
减小第三方库的大小，如Moment.js/lodash等，使用轻量级别替代方案或者自己重新实现
对首评秒开要求较高的，可对首屏请求的接口进行拆分，快速响应首屏需要用到的字段，其他的数据异步加载
使用tree shaking，当我们在项目中引入其他模块时，他会自动将我们用不到的代码，或者永远不会执行的代码摇掉，在Uglify阶段查出，不打包到bundle中
HTTP头部Cookie的精简，去除不必要的Cookie，静态资源做独立域名部署，避免请求携带Cookie
HTTP头部开启gzip压缩，可大大减小网络传输的数据量
HTTP头部开启keep-alive
升级HTTP到2.0，2.0的头部压缩，减少了数据传输量，能够节省消息头占用的网络的流量，且还有多路复用等优势

尽可能的减少资源的次数

JS/CSS数量不可太分散，避免一下发起太多的请求，必要将部分资源合并在一起，减少请求的数量。但是在合并的过程中需求在体积和数量之间权衡，并不是越少越好，可将最大的体积控制在一个范围内进行合并
部分小体量级别的JS/CSS可内联到HTML中，减少请求数量
减小预检请求OPTIONS的发起，可通过服务端设置Access-Control-Max-Age字段或改为发起简单请求
取消无效请求，表单提交频繁点击，路由切换时还有未完成的请求。这些都会产生无效请求，对服务器和用户体验都是不好的
缓存策略
开启http强缓存与协商缓存，对于不同类型的资源使用不同的缓存策略
静态资源开启CDN服务
对于不常变化的数据包括外部JS/CSS资源，可进行前端浏览器缓存，减少请求，但此类缓存需设定好清除及更新的机制

其他资源优化

图片webp使用，对于支持的设备使用webp
图片裁剪，针对使用场景进行相应的裁剪
大图不要打包在项目中，上传到单独的静态资源服务器或是CDN中
图片上传前进行压缩，切记不要使用原图
设置图片标签尺寸大小，防止图片加载中导致页面布局抖动，影响CLS指标的数值
超出屏幕外的图片开启懒加载
对于项目中大量的小图标可使用iconfont字体方案
使用第三方字体库时尽可能按需文字生成
加载字体的时候会导致页面文字有一定的闪烁抖动，可在进入需要用到的页面前使用preload提前进行加载

页面渲染时

开启骨架屏，提升用户体验，避免加载到渲染过程中都是白屏阶段
对于大量列表的滚到使用虚拟列表
尽量多使用CSS3动画
使用 requestAnimationFrame 监听帧变化，使得在正确的时间进行渲染
合理使用CSS，避免通配符，最大化样式继承，少用标签选择器，减少过深嵌套等

用户界面交互

减少页面重排、重绘
防抖节流的使用
合理使用 requestAnimationFrame 动画代替 setTimeout
开启GPU加速，CSS中可使用以下属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、webGL、Video）来触发 GPU 渲染
减少 JavaScript 脚本执行时间，把一些和 DOM 操作无关且耗时的任务放到 Web Workers 中去执行
对未来某个时间内需要执行动画的元素，将其标记为 will-change，这样渲染引擎会将该元素单独生成一个图层
